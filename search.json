[{"title":"2025Lilctf(Reverse)","url":"/2025/08/15/2025Lilctf(Revese)/","content":"\n# 2025Lilctf(Reverse)\n\n## 1.**ARM ASM**\n\n发现是apk，放到jadx看一下，发现：\n\n![image-20250815220846564](2025Lilctf(Revese)/image-20250815220846564.png)\n\n然后ida打开看到：\n\n![image-20250815220944516](2025Lilctf(Revese)/image-20250815220944516.png)\n\n找到这三个关键函数以及：\n\n![image-20250815221012488](2025Lilctf(Revese)/image-20250815221012488.png)\n\n推测是变表和移位的base64，扔给ai分析一下，生成脚本：\n\n```py\nimport base64\n\n# 自定义Base64表\ncustom_b64_table = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ3456780129+/\"\nstandard_b64_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\n# 目标密文\ntarget_b64 = \"KRD2c1XRSJL9e0fqCIbiyJrHW1bu0ZnTYJvYw1DM2RzPK1XIQJnN2ZfRMY4So09S\"\n\n# 转换到标准Base64\ndef to_standard_b64(s):\n    return s.translate(str.maketrans(custom_b64_table, standard_b64_table))\n\n# 解码Base64\nstd_b64_str = to_standard_b64(target_b64)\ndecoded = base64.b64decode(std_b64_str)\ndata = list(decoded)  # 解码后的48字节数据\n\n# 移位逆操作（每3字节一组）\ndef reverse_shift(data):\n    result = []\n    for i in range(0, len(data), 3):\n        # 第1字节：循环右移3位（加密时循环左移3位）\n        b0 = data[i]\n        b0 = ((b0 >> 3) | (b0 << 5)) & 0xFF\n        \n        # 第2字节：循环左移1位（加密时循环右移1位）\n        b1 = data[i+1]\n        b1 = ((b1 << 1) | (b1 >> 7)) & 0xFF\n        \n        # 第3字节不变\n        b2 = data[i+2]\n        result.extend([b0, b1, b2])\n    return result\n\n# 置换表t\nt0 = [0x0D, 0x0E, 0x0F, 0x0C, 0x0B, 0x0A, 0x09, 0x08, \n      0x06, 0x07, 0x05, 0x04, 0x02, 0x03, 0x01, 0x00]\n\n# 构造逆置换表\ninv_t = [0] * 16\nfor i in range(16):\n    inv_t[t0[i]] = i\n\n# 三轮变换逆操作（正确密钥）\ndef reverse_blocks(blocks):\n    # 块0：使用密钥 t0\n    block0 = [blocks[0][i] ^ t0[i] for i in range(16)]\n    block0 = [block0[inv_t[i]] for i in range(16)]\n    \n    # 块1：使用密钥 t0\n    block1 = [blocks[1][i] ^ t0[i] for i in range(16)]\n    block1 = [block1[inv_t[i]] for i in range(16)]\n    \n    # 块2：使用密钥 t0⊕1（关键修正！）\n    key2 = [b ^ 0x01 for b in t0]\n    block2 = [blocks[2][i] ^ key2[i] for i in range(16)]\n    block2 = [block2[inv_t[i]] for i in range(16)]\n    \n    return block0 + block1 + block2\n\n# 步骤1: 移位逆操作\ndata = reverse_shift(data)\n\n# 分块（16字节/块）\nblocks = [\n    data[0:16],   # 块0: 0-15字节\n    data[16:32],  # 块1: 16-31字节\n    data[32:48]   # 块2: 32-47字节\n]\n\n# 步骤2: 三轮逆操作（使用正确密钥）\noriginal_data = reverse_blocks(blocks)\n\n# 转换为字符串\nflag = ''.join(chr(b) for b in original_data)\n\nprint(\"完整的Flag:\", flag)\nprint(\"Flag长度:\", len(flag))\n```\n\n完整的Flag: LILCTF{ez_arm_asm_meow_meow_meowm_oe_wemwom_oe}w\nFlag长度: 48\n\n提交不上，猜了一下，最后试了试这个\n\nLILCTF{ez_arm_asm_meow_meow_meow_meow_meow_meow}\n\n提交成功\n\n","tags":["CTF","Reverse"],"categories":["CTF","Reverse"]},{"title":"2025Lilctf(Crypto)","url":"/2025/08/15/2025Lilctf(Crypto)/","content":"\n# 2025Lilctf(Crypto)\n\n## 1.**ez_math**\n\n原题：\n\n```python\nfrom sage.all import *\nfrom Crypto.Util.number import *\n\nflag = b'LILCTF{test_flag}'[7:-1]\nlambda1 = bytes_to_long(flag[:len(flag)//2])\nlambda2 = bytes_to_long(flag[len(flag)//2:])\np = getPrime(512)\ndef mul(vector, c):\n    return [vector[0]*c, vector[1]*c]\n\nv1 = [getPrime(128), getPrime(128)]\nv2 = [getPrime(128), getPrime(128)]\n\nA = matrix(GF(p), [v1, v2])\nB = matrix(GF(p), [mul(v1,lambda1), mul(v2,lambda2)])\nC = A.inverse() * B\n\nprint(f'p = {p}')\nprint(f'C = {str(C).replace(\" \", \",\").replace(\"\\n\", \",\").replace(\"[,\", \"[\")}')\n\n# p = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161\n# C = [7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645,7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801],[7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808,2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872]\n\n\n```\n\n根据矩阵求flag，跟moe那个有点像\n\n![image-20250815131251617](2025Lilctf(Crypto)/image-20250815131251617.png)\n\n\n\n```python\nfrom sage.all import *\nfrom Crypto.Util.number import long_to_bytes\n\n# 已知的p和C矩阵元素\np = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161\nc11 = 7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645\nc12 = 7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801\nc21 = 7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808\nc22 = 2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872\n\n# 在GF(p)域上进行计算\nF = GF(p)\nc11 = F(c11)\nc12 = F(c12)\nc21 = F(c21)\nc22 = F(c22)\n\n# 计算特征方程的系数\nsum_c = c11 + c22\nproduct_c = c11 * c22 - c12 * c21\n\n# 计算判别式和平方根\nD = sum_c^2 - 4 * product_c\nsqrt_D = D.sqrt()\n\n# 计算2的逆元\ninv2 = F(2)^-1\n\n# 求解特征值（λ₁和λ₂）\nlambda1 = int((sum_c + sqrt_D) * inv2)\nlambda2 = int((sum_c - sqrt_D) * inv2)\n\n# 转换为字节\npart1 = long_to_bytes(lambda1)\npart2 = long_to_bytes(lambda2)\n\n# 生成可能的flag（两种组合，因为λ₁和λ₂可能顺序互换）\nflag1 = b'LILCTF{' + part1 + part2 + b'}'\nflag2 = b'LILCTF{' + part2 + part1 + b'}'\n\nprint(\"可能的flag1:\", flag1)\nprint(\"可能的flag2:\", flag2)\n\n```\n\n可能的flag1: b'LILCTF{It_w4s_the_be5t_of_times_1t_wa5_the_w0rst_of_t1me5}'\n可能的flag2: b'LILCTF{1t_wa5_the_w0rst_of_t1me5It_w4s_the_be5t_of_times_}'\n\n## 2.linear\n\n原题：\n\n```python\nimport os\nimport random\nimport signal\n\nsignal.alarm(10)\n\nflag = os.getenv(\"LILCTF_FLAG\", \"LILCTF{default}\")\n\nnrows = 16\nncols = 32\n\nA = [[random.randint(1, 1919810) for _ in range(ncols)] for _ in range(nrows)]\nx = [random.randint(1, 114514) for _ in range(ncols)]\n\nb = [sum(A[i][j] * x[j] for j in range(ncols)) for i in range(nrows)]\nprint(A)\nprint(b)\n\nxx = list(map(int, input(\"Enter your solution: \").strip().split()))\nif xx != x:\n    print(\"Oh, your linear algebra needs to be practiced.\")\nelse:\n    print(\"Bravo! Here is your flag:\")\n    print(flag)\n\n```\n\n比较简单的一个线性代数题，但是一般求出来的结果好像不准确，那么我们可以使用格基来求解，问题是要求是10s限制比较麻烦，因为我不会在sagemath连端口，所以就用vscode连接端口，使用sagemath出x，这样的话再复制到交互端口就好了\n\nsagemath：\n\n```py\n# 读取文本数据\nwith open(\"E:/edge下载/CTF/2025LilCTF/Crypto/problem_data.txt\", \"r\", encoding=\"utf-8\") as file:\n    data = file.read()\n\n# 假设数据的格式是类似于JSON或Python列表的结构\n# 你可以手动解析文件内容，假设数据格式是这样的：\n# A = [[...], [...], ...] 和 b = [...], 你可以使用eval()或json.loads()来解析\nimport ast\n\n# 假设 data 中有 A 和 b 的定义\nA = ast.literal_eval(data.split(\"A = \")[1].split(\"b = \")[0].strip())  # 提取并解析A\nb = ast.literal_eval(data.split(\"b = \")[1].strip())  # 提取并解析b\n\n# 之后使用这些数据进行计算\nn = 32  # 变量数\nm = 16  # 方程数\nW = 2**40  # 权重\n\n# 构造格基矩阵\nM = matrix(ZZ, n+1, n+m)\nfor i in range(n):\n    M[i, i] = 1\n    for j in range(m):\n        M[i, n+j] = A[j][i] * W  # 注意：A是16行32列，所以A[j][i]是第j行第i列\n\nfor j in range(m):\n    M[n, n+j] = b[j] * W\n\n# LLL约简（使用更快参数）\nM_lll = M.LLL(delta=0.99, eta=0.51)\n\n# 寻找解\nsolution = None\nfor i in range(n+1):\n    # 检查后m个分量是否全为0\n    if all(M_lll[i, n+j] == 0 for j in range(m)):\n        x_sol = [abs(int(M_lll[i, j])) for j in range(n)]\n        # 将解限制在[1,114514]范围内\n        x_sol = [max(1, min(x, 114514)) for x in x_sol]\n        solution = x_sol\n        break\n\n# 如果LLL未找到解，使用伪逆作为备选\nif solution is None:\n    print(\"LLL未找到解，使用伪逆法...\")\n    A_np = matrix(RDF, A)\n    b_np = vector(RDF, b)\n    x_float = A_np.pseudoinverse() * b_np\n    solution = [int(round(num)) for num in x_float]\n    solution = [max(1, min(x, 114514)) for x in solution]\n\n# 打印解（复制这个到client.py）\nprint(\"\\n\" + \"=\"*80)\nprint(\"解x (复制这个到client.py):\")\nprint(\" \".join(map(str, solution)))\nprint(\"=\"*80)\n\n# 验证解（可选）\nb_calculated = [sum(A[i][j] * solution[j] for j in range(n)) for i in range(m)]\nif b_calculated == b:\n    print(\"验证成功: Ax = b\")\nelse:\n    print(\"验证失败: Ax ≠ b\")\n    print(f\"原始b: {b}\")\n    print(f\"计算b: {b_calculated}\")\n\n```\n\nvscode\n\n```py\nfrom pwn import *\nimport time\nimport os\n\ndef main():\n    # 连接到服务器\n    io = remote(\"challenge.xinshi.fun\", 46755)\n    \n    # 接收数据直到出现输入提示\n    data = b\"\"\n    start_time = time.time()\n    while b\"Enter your solution:\" not in data:\n        chunk = io.recv(1024)\n        if not chunk:\n            break\n        data += chunk\n        \n        # 超时检查\n        if time.time() - start_time > 15:\n            print(\"Timeout waiting for data!\")\n            io.close()\n            return\n    \n    # 提取并保存矩阵A和向量b\n    A_start = data.find(b\"[[\")\n    A_end = data.find(b\"]]\") + 2\n    b_start = data.find(b\"[\", A_end)\n    b_end = data.find(b\"]\", b_start) + 1\n    \n    A_str = data[A_start:A_end].decode()\n    b_str = data[b_start:b_end].decode()\n    \n    # 保存到文件\n    with open(\"problem_data.txt\", \"w\") as f:\n        f.write(f\"A = {A_str}\\n\")\n        f.write(f\"b = {b_str}\\n\")\n    \n    print(\"问题数据已保存到 problem_data.txt\")\n    print(\"请立即运行SageMath脚本计算解...\")\n    \n    # 等待用户粘贴解\n    print(\"\\n计算完成后，将解x粘贴在这里（空格分隔的32个整数）\")\n    print(\"注意：您有10秒时间完成计算！\")\n    xx = input(\">>> \").strip()\n    \n    # 提交解\n    io.sendline(xx.encode())\n    \n    # 获取结果\n    try:\n        result = io.recvall(timeout=5).decode()\n        print(\"\\nServer response:\")\n        print(result)\n    except:\n        print(\"\\nTimeout waiting for server response\")\n    \n    io.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n![image-20250815171516880](2025Lilctf(Crypto)/image-20250815171516880.png)\n\nflag：     LILCTF{60b2bfea-b0f7-4aed-9c94-b2301afd828f}\n\n\n\n## 3.**mid_math**\n\n原题：\n\n```py\nfrom sage.all import *\nfrom Crypto.Util.number import *\nfrom tqdm import tqdm\nfrom random import randint\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\n\nflag = b'LILCTF{test_flag}'\n\np = getPrime(64)\nP = GF(p)\n\nkey = randint(2**62, p)\n\ndef mul(vector, c):\n    return [vector[0]*c, vector[1]*c, vector[2]*c, vector[3]*c, vector[4]*c]\n\nv1 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]\nv2 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]\nv3 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]\nv4 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]\nv5 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]\na, b, c, d, e = getPrime(64), getPrime(64), getPrime(64), getPrime(64),  0\n\nA = matrix(P, [v1, v2, v3, v4, v5])\nB = matrix(P, [mul(v1,a), mul(v2,b), mul(v3, c), mul(v4, d), mul(v5, e)])\nC = A.inverse() * B\nD = C**key\n\nkey = pad(long_to_bytes(key), 16)\naes = AES.new(key,AES.MODE_ECB)\nmsg = aes.encrypt(pad(flag, 64))\n\nprint(f\"p = {p}\")\nprint(f'C = {[i for i in C]}'.replace('(', '[').replace(')', ']'))\nprint(f'D = {[i for i in D]}'.replace('(', '[').replace(')', ']'))\nprint(f\"msg = {msg}\")\n\n#p = 14668080038311483271\n#C = [[11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212], [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914], [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670], [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413], [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707]]\n#D = [[1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044], [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372], [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427], [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551], [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395]]\n#msg = b\"\\xcc]B:\\xe8\\xbc\\x91\\xe2\\x93\\xaa\\x88\\x17\\xc4\\xe5\\x97\\x87@\\x0fd\\xb5p\\x81\\x1e\\x98,Z\\xe1n`\\xaf\\xe0%:\\xb7\\x8aD\\x03\\xd2Wu5\\xcd\\xc4#m'\\xa7\\xa4\\x80\\x0b\\xf7\\xda8\\x1b\\x82k#\\xc1gP\\xbd/\\xb5j\"\n\n\n\n\n```\n\n\n\n由于 `D = C ** key`，我们可以利用矩阵的特征值（eigenvalues）来恢复 `key`：\n\n1. **计算 `C` 和 `D` 的特征值**：\n   - `C` 的特征值 `eigC` 包含 `0` 和 4 个非零值。\n   - `D` 的特征值 `eigD` 包含 `0` 和 `eigC` 的非零值的 `key` 次幂。\n2. **过滤掉 `0`，得到非零特征值**：\n   - `L1 = [x for x in eigC if x != 0]`\n   - `L2 = [x for x in eigD if x != 0]`\n3. **通过离散对数恢复 `key`**：\n   - 对 `L1` 和 `L2` 中的每一对 `(x, y)`，解 `y = x ** key mod p`。\n   - 由于 `key` 的范围是 `[2^62, p]`，解出的 `k` 必须满足这个范围。\n4. **验证 `key`**：\n   - 检查是否 `{x ** key for x in L1} == set(L2)`。\n5. **解密 `msg`**：\n   - 将 `key` 转为字节，填充到16字节，用AES-ECB解密 `msg`\n\nai拷打两下就梭出来了\n\n```py\nfrom sage.all import *\nfrom Crypto.Util.number import *\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad  # Import pad and unpad\n\n# Given data\np = 14668080038311483271\nC_list = [\n    [11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212],\n    [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914],\n    [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670],\n    [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413],\n    [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707]\n]\nD_list = [\n    [1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044],\n    [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372],\n    [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427],\n    [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551],\n    [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395]\n]\nmsg = b\"\\xcc]B:\\xe8\\xbc\\x91\\xe2\\x93\\xaa\\x88\\x17\\xc4\\xe5\\x97\\x87@\\x0fd\\xb5p\\x81\\x1e\\x98,Z\\xe1n`\\xaf\\xe0%:\\xb7\\x8aD\\x03\\xd2Wu5\\xcd\\xc4#m'\\xa7\\xa4\\x80\\x0b\\xf7\\xda8\\x1b\\x82k#\\xc1gP\\xbd/\\xb5j\"\n\n# Set up finite field and matrices\nF = GF(p)\nC = matrix(F, C_list)\nD = matrix(F, D_list)\n\n# Compute eigenvalues\neigC = C.eigenvalues()\neigD = D.eigenvalues()\n\n# Remove zero eigenvalues (one for each matrix)\nL1 = [x for x in eigC if x != F(0)]\nL2 = [x for x in eigD if x != F(0)]\n\nif len(L1) != 4 or len(L2) != 4:\n    print(\"Error: Expected 4 non-zero eigenvalues for both matrices.\")\n    exit(1)\n\n# Find key by matching eigenvalues via discrete logarithm\nkey_candidate = None\nfor i in range(4):\n    x0 = L1[i]\n    for j in range(4):\n        y0 = L2[j]\n        try:\n            k0 = discrete_log(y0, x0)  # Solve y0 = x0^k0 mod p\n            candidates = []\n            # Check if k0 is in the valid range\n            if 2**62 <= k0 <= p:\n                candidates.append(k0)\n            # If k0 is too small, try k0 + order of x0\n            if k0 < 2**62:\n                ord_val = x0.multiplicative_order()\n                k1 = k0 + ord_val\n                if 2**62 <= k1 <= p:\n                    candidates.append(k1)\n            # Verify candidate keys\n            for k_cand in candidates:\n                S = set(x**k_cand for x in L1)\n                if S == set(L2):\n                    key_candidate = k_cand\n                    print(f\"Found key: {key_candidate}\")\n                    break\n            if key_candidate is not None:\n                break\n        except Exception as e:\n            continue\n    if key_candidate is not None:\n        break\n\nif key_candidate is None:\n    print(\"Failed to find key.\")\n    exit(1)\n\n# Decrypt the message using the recovered key\nkey_bytes = long_to_bytes(key_candidate)\n# Pad the key to 16 bytes for AES\nkey_padded = pad(key_bytes, 16)  # Now pad is imported\naes = AES.new(key_padded, AES.MODE_ECB)\nflag_padded = aes.decrypt(msg)\nflag = unpad(flag_padded, 64)  # Original padding was 64 bytes\n\nprint(f\"Flag: {flag.decode()}\")\n```\n\n key: 5273966641785501202\n\nflag：LILCTF{Are_y0u_5till_4wake_que5t1on_m4ker!}\n\n\n\n## 4.**Space Travel**\n\n原题：\n\n```py\nfrom Crypto.Cipher import AES\nfrom hashlib import md5\nfrom params import vecs\nfrom os import urandom\n\nkey = int(\"\".join([vecs[int.from_bytes(urandom(2)) & 0xfff] for _ in range(50)]), 2)\n\nprint(\"🎁 :\", [[nonce := int(urandom(50*2).hex(), 16), (bin(nonce & key).count(\"1\")) % 2] for _ in range(600)])\nprint(\"🚩 :\", AES.new(key=md5(str(key).encode()).digest(), nonce=b\"Tiffany\", mode=AES.MODE_CTR).encrypt(open(\"flag.txt\", \"rb\").read()))\n```\n\n1.题面逻辑（来自 `task.py`）\n\n- 先从 `params.py` 里的 `vecs`（4096 个 16 位二进制串）中，用 12 位随机索引各取 50 次，拼成 50×16 = 800 位的二进制串，作为大整数 `key`。\n- 接着生成 600 组样本：每组里有一个 800 位随机数 `nonce`，以及一个比特 `parity`，它等于 `bin(nonce & key)` 中 1 的个数的奇偶（即 `(nonce · key) mod 2` 的内积）。\n- 最后用 `md5(str(key))` 作为 AES-CTR 的 key，nonce 固定为 `\"Tiffany\"`，加密出密文 `🚩`。\n\n2.观测与困难\n\n- 600 组样本提供了 600 条线性方程（GF(2) 上的内积），但未知量 `key` 有 800 个比特，直接解有 200 维自由度，不唯一。\n- 关键是 `key` 的结构：它是 50 个 16 位小块的串联，每块都来自 `vecs`。而 `vecs` 的 4096 项，其差分集合（取任意一个基准 `v0`，看 `vecs ⊕ v0` 的行空间）维度是 **12**。这意味着 `vecs` 其实是一个 **12 维线性****子空间****的仿射陪集**（coset），大小正好 2^12=4096。\n  - 于是每个 16 位小块都可表示为 `v0 ⊕ (B * α)`，其中 `B` 是 12×16 的基矩阵，`α` 是 12 比特坐标。\n  - 50 个小块 → 一共 50×12 = **600 个**未知比特。\n  - 与 600 条线性方程正好匹配！从而把原本 800 维未知，降成 600 维，得到可解的线性系统。\n\n3.建模方式（对齐 bit 顺序很重要！）\n\n- 把 `vecs` 的 16 位字符串视作 **LSB-first**（与 `(nonce & key)` 的位对齐一致），否则会解出错误的 key。\n- 设第 `t` 个小块的未知 12 比特为 `α_t`。对每条样本方程，有\n- `parity_i = ⊕_t <nonce_chunk_i_t, v0 ⊕ (B * α_t)> ``         = ⊕_t <nonce_chunk_i_t, v0> ⊕ ⊕_t <nonce_chunk_i_t, B * α_t>`\n- 把常量项 `⊕_t <nonce_chunk_i_t, v0>` 移到右边，剩余是关于所有 `α_t` 的 600×600 线性方程组，直接在 GF(2) 解之即可。\n- 方程组秩通常是 599（有 1 维自由度），但这 **不影响**：任意解出的 `(α_t)` 都映射到 `v0 ⊕ B*α_t`，这个集合刚好就是 `vecs` 的那个仿射陪集，不会跑出集合之外。对那 1 维自由度，测试两种可能都很快，直接看哪一个能把密文正确解出可读明文（一般是标准 CTF flag）。\n\n4.解出 key 并还原明文\n\n- 用解出来的 50 个 16 位小块拼成 800 位 key（注意保持 LSB-first 与构造一致）。\n- 取 `md5(str(key))`（Python 的 `str(key)` 即十进制串）当 AES-CTR key，nonce 用 `b\"Tiffany\"`，解密 `🚩`。\n- 能得到清晰的 ASCII flag。\n\n\n\n```py\nimport re, ast, numpy as np, hashlib\nfrom Crypto.Cipher import AES\n\n# ---- 工具：GF(2) 线性代数 ----\ndef gf2_rref(M, rhs=None):\n    M = M.copy().astype(np.uint8)\n    if rhs is not None:\n        rhs = rhs.copy().astype(np.uint8)\n        M = np.concatenate([M, rhs.reshape(-1,1)], axis=1)\n    m, n_aug = M.shape\n    n = n_aug if rhs is None else n_aug - 1\n    row = 0\n    pivots = []\n    for col in range(n):\n        pivot = None\n        for r in range(row, m):\n            if M[r,col]:\n                pivot = r; break\n        if pivot is None:\n            continue\n        if pivot != row:\n            M[[row,pivot]] = M[[pivot,row]]\n        for r in range(m):\n            if r != row and M[r,col]:\n                M[r,:] ^= M[row,:]\n        pivots.append(col)\n        row += 1\n        if row == m: break\n    return M, pivots\n\ndef int_to_bits_lsb(n, width):\n    return np.array([(n>>i) & 1 for i in range(width)], dtype=np.uint8)\n\ndef bits_to_int(bits_lsb):\n    v = 0\n    for i,b in enumerate(bits_lsb):\n        if b: v |= (1<<i)\n    return v\n\n# ---- 读取 vecs（params.py）并转为 LSB-first ----\nwith open('params.py','r',encoding='utf-8',errors='ignore') as f:\n    text = f.read()\nvecs_list = re.findall(r\"'([01]{16})'\", text)\nvecs = np.array([[int(b) for b in s[::-1]] for s in vecs_list], dtype=np.uint8)  # reverse to LSB-first\n\n# 取一个基向量 v0，并构造差分集合的行空间基 B（12×16）\nv0 = vecs[0]\ndiffs = (vecs ^ v0) % 2\n\ndef gf2_basis_rows(M):\n    A = M.copy().astype(np.uint8)\n    m,n = A.shape\n    row=0\n    pivcols=[]\n    for col in range(n):\n        pivot=None\n        for r in range(row,m):\n            if A[r,col]:\n                pivot=r; break\n        if pivot is None: continue\n        if pivot!=row: A[[row,pivot]] = A[[pivot,row]]\n        for r in range(m):\n            if r!=row and A[r,col]:\n                A[r,:] ^= A[row,:]\n        pivcols.append(col); row+=1\n        if row==m: break\n    # 抽取基行\n    basis_rows=[]\n    used=set()\n    for lead in pivcols:\n        for r in range(m):\n            if r in used: continue\n            if A[r,lead]==1 and all(A[r,c]==0 for c in range(lead)):\n                basis_rows.append(A[r].copy()); used.add(r); break\n    return np.array(basis_rows, dtype=np.uint8)\n\nB = gf2_basis_rows(diffs)   # 12 x 16\n\n# ---- 解析样本和密文（output.txt）----\nwith open('output.txt','r',encoding='utf-8',errors='ignore') as f:\n    data = f.read()\n\ngift_text = re.search(r\"🎁\\s*:\\s*(\\[\\[.*?\\]\\])\", data, flags=re.S).group(1)\ncipher_text_literal = re.search(r\"🚩\\s*:\\s*(b?['\\\"][^'\\\"]+['\\\"])|🚩\\s*:\\s*([0-9a-fA-Fx,\\s\\[\\]]+)\", data).group(1) \\\n                      or re.search(r\"🚩\\s*:\\s*(b?['\\\"][^'\\\"]+['\\\"])|🚩\\s*:\\s*([0-9a-fA-Fx,\\s\\[\\]]+)\", data).group(2)\n\ngift = ast.literal_eval(gift_text)\ncipher_literal = ast.literal_eval(cipher_text_literal)\nif isinstance(cipher_literal, bytes):\n    ct = cipher_literal\nelif isinstance(cipher_literal, list):\n    ct = bytes(cipher_literal)\nelif isinstance(cipher_literal, str):\n    ct = bytes.fromhex(cipher_literal)\nelse:\n    raise RuntimeError(\"Unknown ciphertext!\")\n\n# ---- 建立 600×600 线性方程组，未知为 50 个块的 12 比特坐标 ----\nm = len(gift)\nT = 50\nk = B.shape[0]  # 12\nWIDTH = 16*T\n\nA2 = np.zeros((m, T*k), dtype=np.uint8)\nb2 = np.zeros(m, dtype=np.uint8)\n\nfor i,(nonce, par) in enumerate(gift):\n    bits = int_to_bits_lsb(nonce, WIDTH)\n    const = 0\n    for t in range(T):\n        chunk = bits[16*t:16*(t+1)]\n        const ^= (np.dot(chunk, v0) % 2)\n        # 对 α_t（12 维），其系数即 <chunk, B_row>，等价于 (B @ chunk)\n        A2[i, t*k:(t+1)*k] = (B @ chunk) % 2\n    b2[i] = (par ^ const) % 2\n\n# ---- 解方程（可能秩 599，尝试两个候选）----\nrref_A2, pivs = gf2_rref(A2, b2)\nnvar = A2.shape[1]\n\nx_alpha = np.zeros(nvar, dtype=np.uint8)\nrow=0\nfor col in range(nvar):\n    if row < len(pivs) and pivs[row]==col:\n        x_alpha[col] = rref_A2[row,-1]; row+=1\n\nrrefA_only, pivs_only = gf2_rref(A2, None)\nnull = np.zeros(nvar, dtype=np.uint8)\nif len(pivs_only) < nvar:\n    fcol = [c for c in range(nvar) if c not in pivs_only][0]\n    null[fcol]=1\n    row=0\n    for col in range(nvar):\n        if row < len(pivs_only) and pivs_only[row]==col:\n            s=0\n            for kcol in range(col+1, nvar):\n                if rrefA_only[row,kcol] and null[kcol]:\n                    s ^= 1\n            null[col]=s%2\n            row+=1\n\ndef build_key_bits(alpha_concat):\n    blocks=[]\n    for t in range(T):\n        alpha_t = alpha_concat[t*k:(t+1)*k]\n        vec_t = (v0 ^ (alpha_t @ B) % 2) % 2  # LSB-first 16 bits\n        blocks.append(vec_t)\n    return np.concatenate(blocks)\n\ncands = [x_alpha, (x_alpha ^ null) % 2]\nfor cand in cands:\n    key_bits = build_key_bits(cand)\n    key_int = bits_to_int(key_bits)\n    aes_key = hashlib.md5(str(key_int).encode()).digest()\n    cipher = AES.new(key=aes_key, nonce=b\"Tiffany\", mode=AES.MODE_CTR)\n    pt = cipher.decrypt(ct)\n    try:\n        s = pt.decode('utf-8')\n        if \"{\" in s and \"}\" in s:\n            print(\"FLAG:\", s)\n            break\n    except:\n        pass\n\n```\n\nflag： LILCTF{Un1qUe_s0luti0n_1N_sUbSp4C3!}\n\n\n\n## 5.**baaaaaag**\n\n原题：\n\n```py\nfrom Crypto.Util.number import *\nimport random\nfrom Crypto.Cipher import AES\nimport hashlib\nfrom Crypto.Util.Padding import pad\nfrom secret import flag\n\np = random.getrandbits(72)\nassert len(bin(p)[2:]) == 72\n\na = [getPrime(90) for _ in range(72)]\nb = 0\nt = p\nfor i in a:\n    temp = t % 2\n    b += temp * i\n    t = t >> 1\n\nkey = hashlib.sha256(str(p).encode()).digest()\ncipher = AES.new(key, AES.MODE_ECB)\nflag = pad(flag,16)\nciphertext = cipher.encrypt(flag)\n\nprint(f'a = {a}')\nprint(f'b = {b}')\nprint(f\"ciphertext = {ciphertext}\")\n\n'''\na = [965032030645819473226880279, 699680391768891665598556373, 1022177754214744901247677527, 680767714574395595448529297, 1051144590442830830160656147, 1168660688736302219798380151, 796387349856554292443995049, 740579849809188939723024937, 940772121362440582976978071, 787438752754751885229607747, 1057710371763143522769262019, 792170184324681833710987771, 912844392679297386754386581, 906787506373115208506221831, 1073356067972226734803331711, 1230248891920689478236428803, 713426848479513005774497331, 979527247256538239116435051, 979496765566798546828265437, 836939515442243300252499479, 1185281999050646451167583269, 673490198827213717568519179, 776378201435505605316348517, 809920773352200236442451667, 1032450692535471534282750757, 1116346000400545215913754039, 1147788846283552769049123803, 994439464049503065517009393, 825645323767262265006257537, 1076742721724413264636318241, 731782018659142904179016783, 656162889354758353371699131, 1045520414263498704019552571, 1213714972395170583781976983, 949950729999198576080781001, 1150032993579134750099465519, 975992662970919388672800773, 1129148699796142943831843099, 898871798141537568624106939, 997718314505250470787513281, 631543452089232890507925619, 831335899173370929279633943, 1186748765521175593031174791, 884252194903912680865071301, 1016020417916761281986717467, 896205582917201847609656147, 959440423632738884107086307, 993368100536690520995612807, 702602277993849887546504851, 1102807438605649402749034481, 629539427333081638691538089, 887663258680338594196147387, 1001965883259152684661493409, 1043811683483962480162133633, 938713759383186904819771339, 1023699641268310599371568653, 784025822858960757703945309, 986182634512707587971047731, 1064739425741411525721437119, 1209428051066908071290286953, 667510673843333963641751177, 642828919542760339851273551, 1086628537309368288204342599, 1084848944960506663668298859, 667827295200373631038775959, 752634137348312783761723507, 707994297795744761368888949, 747998982630688589828284363, 710184791175333909291593189, 651183930154725716807946709, 724836607223400074343868079, 1118993538091590299721647899]\nb = 34962396275078207988771864327\nciphertext = b'Lo~G\\xf46>\\xd609\\x8e\\x8e\\xf5\\xf83\\xb5\\xf0\\x8f\\x9f6&\\xea\\x02\\xfa\\xb1_L\\x85\\x93\\x93\\xf7,`|\\xc6\\xbe\\x05&\\x85\\x8bC\\xcd\\xe6?TV4q'\n'''\n```\n\n一个背包密码，解出p就能梭出来了。但是问题是怎么解出p：\n\n据我已知的背包密码：b是背包容量，a是将要装进背包的物品。p可以由十进制转化为二进制，其中满足a[i],pi。pi只能为0或1,0代表对应的a[i]没有被装进背包，1代表对应的a[i]被装进背包。b会被a装满。\n\n大概是这个意思，但是列数学表达式得出p的二进制需要线性代数知识。lll算法和bkz规约\n\n这是deepseek给出的详细：\n\n### 如何解出 `p`？\n\n为了解决这个问题，我们使用格基归约算法（如 LLL 或 BKZ）。格基归约可以将子集和问题转化为寻找格中的短向量问题。具体步骤如下：\n\n1. **格基构造**：构造一个 `(n+1) x (n+1)` 的矩阵（`n` 是 `a` 的长度），其中：\n\n   - 前 `n` 行：对角线元素为 2，最后一列为 `a[i]`。\n   - 最后一行：前 `n` 个元素为 1，最后一个元素为 `b`。\n\n   这种构造确保了解向量 `(2*m_0 - 1, 2*m_1 - 1, ..., 2*m_{n-1} - 1, 0)` 在格中，其中 `m_i` 是 `p` 的二进制位。转换 `v_i = 2*m_i - 1` 将二进制位映射到 ±1，使得解向量更短且更易识别。\n\n2. **格基归约**：使用 BKZ 或 LLL 算法对格基进行归约。BKZ 通常更强（能找到更短的向量），但计算成本更高。如果 BKZ 失败，可以回退到 LLL。\n\n3. **搜索解向量**：在归约后的基中搜索满足条件的向量：\n\n   - 前 `n` 个坐标为 ±1。\n   - 最后一个坐标为 0（或接近 0，容错处理）。\n\n   如果找到，则从解向量恢复二进制位：`m_i = (v_i + 1) / 2`。\n\n4. **恢复 `p`**：将二进制位组合成整数 `p`（注意：最低位对应 `m_0`）。\n\n```python\nfrom sage.all import Matrix, ZZ\n\n\n# --------- 已知参数 ----------\na = [965032030645819473226880279, 699680391768891665598556373, 1022177754214744901247677527, 680767714574395595448529297,\n     1051144590442830830160656147, 1168660688736302219798380151, 796387349856554292443995049, 740579849809188939723024937,\n     940772121362440582976978071, 787438752754751885229607747, 1057710371763143522769262019, 792170184324681833710987771,\n     912844392679297386754386581, 906787506373115208506221831, 1073356067972226734803331711, 1230248891920689478236428803,\n     713426848479513005774497331, 979527247256538239116435051, 979496765566798546828265437, 836939515442243300252499479,\n     1185281999050646451167583269, 673490198827213717568519179, 776378201435505605316348517, 809920773352200236442451667,\n     1032450692535471534282750757, 1116346000400545215913754039, 1147788846283552769049123803, 994439464049503065517009393,\n     825645323767262265006257537, 1076742721724413264636318241, 731782018659142904179016783, 656162889354758353371699131,\n     1045520414263498704019552571, 1213714972395170583781976983, 949950729999198576080781001, 1150032993579134750099465519,\n     975992662970919388672800773, 1129148699796142943831843099, 898871798141537568624106939, 997718314505250470787513281,\n     631543452089232890507925619, 831335899173370929279633943, 1186748765521175593031174791, 884252194903912680865071301,\n     1016020417916761281986717467, 896205582917201847609656147, 959440423632738884107086307, 993368100536690520995612807,\n     702602277993849887546504851, 1102807438605649402749034481, 629539427333081638691538089, 887663258680338594196147387,\n     1001965883259152684661493409, 1043811683483962480162133633, 938713759383186904819771339, 1023699641268310599371568653,\n     784025822858960757703945309, 986182634512707587971047731, 1064739425741411525721437119, 1209428051066908071290286953,\n     667510673843333963641751177, 642828919542760339851273551, 1086628537309368288204342599, 1084848944960506663668298859,\n     667827295200373631038775959, 752634137348312783761723507, 707994297795744761368888949, 747998982630688589828284363,\n     710184791175333909291593189, 651183930154725716807946709, 724836607223400074343868079, 1118993538091590299721647899]\n\nb = 34962396275078207988771864327\n\nciphertext = b'Lo~G\\xf46>\\xd609\\x8e\\x8e\\xf5\\xf83\\xb5\\xf0\\x8f\\x9f6&\\xea\\x02\\xfa\\xb1_L\\x85\\x93\\x93\\xf7,`|\\xc6\\xbe\\x05&\\x85\\x8bC\\xcd\\xe6?TV4q'\n\nn = len(a)   # 72\n\n# --------- 构造格基 ----------\nGe = Matrix(ZZ, n+1, n+1)\nfor i in range(n):\n    Ge[i, i] = 2\n    Ge[i, -1] = a[i]\n\nfor i in range(n):\n    Ge[-1, i] = 1\nGe[-1, -1] = b\n\n# --------- BKZ / LLL 归约 ----------\nprint(\"Running BKZ...\")\ntry:\n    B = Ge.BKZ(block_size=28)\nexcept Exception as e:\n    print(\"BKZ 失败，退回 LLL：\", e)\n    B = Ge.LLL()\n\nprint(\"Reduction done. Searching for solution vector...\")\n\nfound = False\ncandidate = None\n\n# 搜索解向量\nfor row_idx in range(B.nrows()):\n    v = [int(B[row_idx, j]) for j in range(n+1)]\n    last = v[-1]\n    front = v[:-1]\n    if last == 0 and all(x in (-1, 1) for x in front):\n        candidate = front\n        found = True\n        print(f\"Found exact candidate in basis row {row_idx}\")\n        break\n\nif not found:\n    for row_idx in range(B.nrows()):\n        v = [int(B[row_idx, j]) for j in range(n+1)]\n        front = v[:-1]\n        last = v[-1]\n        if abs(last) <= 1 and all(abs(x) in (0,1,2) for x in front):\n            possibly = []\n            ok = True\n            for x in front:\n                if x >= 1:\n                    possibly.append(1)\n                elif x <= -1:\n                    possibly.append(-1)\n                else:\n                    ok = False\n                    break\n            if ok:\n                candidate = possibly\n                found = True\n                print(f\"Found tolerant candidate in basis row {row_idx} (last={last})\")\n                break\n\nif not found:\n    print(\"没有在基中直接找到满足 (±1,...,0) 形式的向量。\")\n    print(\"你可以：\\n - 提高 BKZ 的 block_size（更强但更慢），\\n - 或尝试搜索基向量的短线性组合 / 使用 fpylll 的 shortest_vector.\")\n    exit(1)\n\n# 恢复 p\nm_bits = [(x + 1) // 2 for x in candidate]\np_recovered = 0\nfor i, bit in enumerate(m_bits):\n    p_recovered |= (bit << i)\n\nprint(\"Recovered p (decimal):\", p_recovered)\nprint(\"Recovered p (bin length):\", len(bin(p_recovered)) - 2)\n\n```\n\nRunning BKZ...\nReduction done. Searching for solution vector...\nFound exact candidate in basis row 0\nRecovered p (decimal): 4208626653103825685156\nRecovered p (bin length): 72\n\n```python\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import unpad\nimport hashlib\n\nciphertext=b'Lo~G\\xf46>\\xd609\\x8e\\x8e\\xf5\\xf83\\xb5\\xf0\\x8f\\x9f6&\\xea\\x02\\xfa\\xb1_L\\x85\\x93\\x93\\xf7,`|\\xc6\\xbe\\x05&\\x85\\x8bC\\xcd\\xe6?TV4q'\np_recovered=4208626653103825685156\n\n\nkey = hashlib.sha256(str(p_recovered).encode()).digest()\ncipher = AES.new(key, AES.MODE_ECB)\ntry:\n    plaintext = unpad(cipher.decrypt(ciphertext), 16)\nexcept ValueError:\n    plaintext = cipher.decrypt(ciphertext)\n    print(\"Warning: unpad failed; raw decrypted bytes shown.\")\n\nprint(\"Decrypted plaintext (bytes):\", plaintext)\ntry:\n    print(\"Decrypted plaintext (utf-8):\", plaintext.decode())\nexcept Exception:\n    pass\n```\n\nDecrypted plaintext (bytes): b'LILCTF{M4ybe_7he_brut3_f0rce_1s_be5t}'\nDecrypted plaintext (utf-8): LILCTF{M4ybe_7he_brut3_f0rce_1s_be5t}\n","tags":["CTF","Crypto"],"categories":["CTF","Crypto"]},{"title":"SwitchHosts下载安装使用","url":"/2025/08/11/SwitchHosts下载安装使用/","content":"\n# SwitchHosts下载安装使用\n\ngithub直接搜然后下载\n\n![image-20250811232346188](SwitchHosts下载安装使用/image-20250811232346188.png)\n\n然后直接修改\n\n![image-20250811235635131](SwitchHosts下载安装使用/image-20250811235635131.png)\n\n注意，要关代理并且重启浏览器！！！","tags":["Java","util"],"categories":["Java","util"]},{"title":"2025天机学堂","url":"/2025/08/11/2025天机学堂/","content":"\n# 2025天机学堂\n\n\n\n## day01：初始化项目\n\n虚拟机密码：root      123321\n\n```\n192.168.150.101 git.tianji.com  tjxt  123321\n192.168.150.101 jenkins.tianji.com    root  123\n192.168.150.101 mq.tianji.com\n192.168.150.101 nacos.tianji.com      nacos   nacos\n192.168.150.101 xxljob.tianji.com\n192.168.150.101 es.tianji.com\n192.168.150.101 api.tianji.com\n192.168.150.101 www.tianji.com      jack  123   Rose  123456\n192.168.150.101 manage.tianji.com\n192.168.150.101 cpolar.tianji.com\n```\n\n\n\n\n\n点击init初始化虚拟机：\n\n在VMware得到：\n\n![image-20250811230026583](2025天机学堂/image-20250811230026583.png)\n\n\n\n然后初始化网络配置，改成这样：\n\n![image-20250811230229943](2025天机学堂/image-20250811230229943.png)\n\n启动虚拟机，虚拟机中的环境会自启动，我们可以访问一个进行测试，访问是要访问我画红框的url：192.168.150.101:8848\n\n![image-20250811230339618](2025天机学堂/image-20250811230339618.png)\n\n然后我们也可以使用switchhost来代理，具体可以看我switchhost的文章\n\n\n\nnginx无法启动问题，尝试重启进行解决：解决失败，但最后耗时四小时左右解决了，问题在于nginx的conf的语法问题，大概改成这样就好了：\n\n![image-20250813173345522](2025天机学堂/image-20250813173345522.png)\n\n\n\n然后复制初始化项目到本地：\n\nhttp://192.168.150.101:10880/tjxt/tianji.git\n\ngit clone http://192.168.150.101:10880/tjxt/tianji.git -b lesson-init\n\n![image-20250813151129175](2025天机学堂/image-20250813151129175.png)\n\n然后打开项目刷新一下maven下下依赖就好了\n\n\n\n遇到bug：\n\n![image-20250813174959296](2025天机学堂/image-20250813174959296.png)\n\n解决了一下午，到最后还是依赖问题：把这个注释的# 删掉\n\n![image-20250814001958375](2025天机学堂/image-20250814001958375.png)\n\n\n\n查找bug，Rose删除订单时显示不能删除他人订单\n\n想远程调试，改成这样：\n\n![image-20250814141612054](2025天机学堂/image-20250814141612054.png)\n\n然后关掉tj-trade，启动tj-trade-debug\n\n当然也可以直接本地调试，但是注意调试前编辑配置改为local\n\n![image-20250814144004334](2025天机学堂/image-20250814144004334.png)\n\n回到bug问题，将=改成equals或者==就好了\n\n然后推送到本地的git就好了\n\n\n\n## day02：我的课表\n\n","tags":["Java","complete_item"],"categories":["Java","complete_item"]},{"title":"2025moectf(Crypto)","url":"/2025/08/09/2025moectf(Crypto)/","content":"\n# 2025moectf(Crypto)\n\n## 1.moectf(Crypto)\n\n```python\n#!/usr/bin/env python3\nfrom Crypto.PublicKey import ElGamal\nfrom Crypto.Random import get_random_bytes, random\nfrom Crypto.Util.number import *\nfrom random import *\nfrom secret import flag\ndef generate_elgamal_keypair(bits=512):\np = getPrime(bits)\nfor _ in range(1000):\ng = getRandomRange(2, 5)\nif pow(g, (p - 1) // 2, p) != 1:\nbreak\nx = randrange(2, p - 1)\n注:此处的secret模块可以理解为存储了明文flag的python文件，属于未知信息，而非公开的可用模\n块。你需要尝试从密文去恢复原始的flag，而不是去下载secret模块。secrets则是一个用于生成管\n理密码的安全随机数的python标准库。\nbytes_to_long函数用于将flag编码为整数。\nHint：什么是 Elgamal\n还是附个链接吧Elgamal\ny = pow(g, x, p)\nreturn p, g, y, x\nkey=generate_elgamal_keypair(bits=512)\np, g, y ,x= key\nprint(\"=== 公钥 (p, g, y) ===\")\nprint(\"p =\", p)\nprint(\"g =\", g)\nprint(\"y =\", y)\nprint()\nk = randrange(1, p - 2)\nm = bytes_to_long(flag)\nc1 = pow(g, k, p)\nc2 = (m * pow(y, k, p)) % p\nprint(\"=== 密文 (c1, c2) ===\")\nprint(\"c1 =\", c1)\nprint(\"c2 =\", c2)\n#不小心把x输出了()\nprint(\"x =\", x)\n\"\"\"\n=== 公钥 (p, g, y) ===\np =\n115409637159621449517635782553574175289667159048490149855475976576983048910448410\n99894993117258279094910424033273299863589407477091830213468539451196239863\ng = 2\ny =\n831342478336601128701462358277352159533328529138054068946707321221293164841558006\n5207081449784135835711205324186662482526357834042013400765421925274271853\n=== 密文 (c1, c2) ===\nc1 =\n665205355305564535827536225955485652597693184131825115294046454317510856013294961\n0916012490837970851191204144757409335011811874896056430105292534244732863\nc2 =\n231491356808152642824798171910095233144493885239903182663547597194748466341836253\n3363591441216570597417789120470703548843342170567039399830377459228297983\nx =\n801095707808655428402095966412478447961091359656003501195114326955976122911402773\n8791440961864150225798049120582540951874956255115884539333966429021004214\n\"\"\"\n注:此处的secret模块可以理解为存储了明文flag的python文件，属于未知信息，而非公开的可用模\n块。你需要尝试从密文去恢复原始的flag，而不是去下载secret模块。secrets则是一个用于生成管\n理密码的安全随机数的python标准库。\nbytes_to_long函数用于将flag编码为整数。\n```\n\nai可以一把梭，明个再来写解题过程：\n\n![image-20250810004708703](2025moectf(Crypto)/image-20250810004708703.png)\n\n\n\n```python\nfrom Crypto.Util.number import long_to_bytes\n\n# 给定的公钥和私钥\np = 11540963715962144951763578255357417528966715904849014985547597657698304891044841099894993117258279094910424033273299863589407477091830213468539451196239863\ng = 2\ny = 8313424783366011287014623582773521595333285291380540689467073212212931648415580065207081449784135835711205324186662482526357834042013400765421925274271853\nc1 = 6652053553055645358275362259554856525976931841318251152940464543175108560132949610916012490837970851191204144757409335011811874896056430105292534244732863\nc2 = 2314913568081526428247981719100952331444938852399031826635475971947484663418362533363591441216570597417789120470703548843342170567039399830377459228297983\nx = 8010957078086554284020959664124784479610913596560035011951143269559761229114027738791440961864150225798049120582540951874956255115884539333966429021004214\n\n# 计算共享密钥 s = c1^x mod p\ns = pow(c1, x, p)\n\n# 计算 s 的模逆元\ns_inv = pow(s, -1, p)\n\n# 解密消息 m = c2 * s_inv mod p\nm = (c2 * s_inv) % p\n\n# 将整数转换为字节串\nflag = long_to_bytes(m)\n\nprint(\"解密后的 flag:\", flag.decode())\n```\n\nflag:   moectf{th1s_1s_y0ur_f1rst_ElG@m@l}\n\n\n\n## 2.ez_DES\n\n原题：\n\n```python\nfrom Crypto.Cipher import DES\nimport secrets\nimport string\n\nflag = 'moectf{???}'\ncharacters = string.ascii_letters + string.digits + string.punctuation\nkey = 'ezdes'+''.join(secrets.choice(characters) for _ in range(3))\nassert key[:5] == 'ezdes'\nkey = key.encode('utf-8')\nl = 8\n\ndef encrypt(text, key):\n    cipher = DES.new(key, DES.MODE_ECB)\n    padded_text = text + (l - len(text) % l) * chr(len(text))\n    data = cipher.encrypt(padded_text.encode('utf-8'))\n    return data\n\nc = encrypt(flag, key)\nprint('c =', c)\n\n# c = b'\\xe6\\x8b0\\xc8m\\t?\\x1d\\xf6\\x99sA>\\xce \\rN\\x83z\\xa0\\xdc{\\xbc\\xb8X\\xb2\\xe2q\\xa4\"\\xfc\\x07'\n```\n\n爆破秘钥就好，ai能一把梭：\n\n```python\nfrom Crypto.Cipher import DES\nimport string\nfrom itertools import product\n\n# 给定的密文\nc = b'\\xe6\\x8b0\\xc8m\\t?\\x1d\\xf6\\x99sA>\\xce \\rN\\x83z\\xa0\\xdc{\\xbc\\xb8X\\xb2\\xe2q\\xa4\"\\xfc\\x07'\n\n# 可能的字符集\ncharacters = string.ascii_letters + string.digits + string.punctuation\n\ndef decrypt(ciphertext, key):\n    \"\"\"尝试使用给定的密钥解密，使用题目特定的填充方案\"\"\"\n    try:\n        cipher = DES.new(key, DES.MODE_ECB)\n        data = cipher.decrypt(ciphertext)\n        \n        # 获取原始消息长度（填充字符的值）\n        msg_len = data[-1]\n        \n        # 计算填充长度\n        pad_len = 8 - (msg_len % 8)\n        if pad_len == 0:  # 如果长度是8的倍数\n            pad_len = 8\n        \n        # 验证填充是否正确\n        if all(byte == msg_len for byte in data[-pad_len:]):\n            # 移除填充并返回原始消息\n            return data[:-pad_len]\n    except:\n        pass\n    return None\n\ndef main():\n    \"\"\"主函数，爆破密钥并解密\"\"\"\n    # 生成所有可能的3字符组合\n    total = len(characters) ** 3\n    count = 0\n    \n    print(f\"开始爆破 {total} 种可能的密钥组合...\")\n    \n    # 使用笛卡尔积生成所有可能的3字符后缀\n    for suffix in product(characters, repeat=3):\n        count += 1\n        if count % 100000 == 0:\n            print(f\"进度: {count}/{total} ({count/total*100:.1f}%)\")\n        \n        # 构建完整密钥\n        key_str = 'ezdes' + ''.join(suffix)\n        key = key_str.encode('utf-8')\n        \n        # 尝试解密\n        result = decrypt(c, key)\n        \n        # 如果解密成功并且结果包含 moectf 标志\n        if result and b'moectf{' in result:\n            print(f\"\\n找到有效密钥: {key_str}\")\n            print(f\"解密结果: {result.decode()}\")\n            return\n    \n    print(\"爆破完成，未找到有效密钥。尝试检查填充逻辑或密钥空间。\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n找到有效密钥: ezdes8br\n解密结果: moectf{_Ju5t envmEra+e.!}\n\n\n\n\n\n## 3.baby_next\n\n原题：\n\n```python\nfrom Crypto.Util.number import *\nfrom gmpy2 import next_prime\nfrom functools import reduce\nfrom secret import flag\n\nassert len(flag) == 38\nassert flag[:7] == b'moectf{'\nassert flag[-1:] == b'}'\n\ndef main():\n    p = getPrime(512)\n    q = int(reduce(lambda res, _: next_prime(res), range(114514), p))\n\n    n = p * q\n    e = 65537\n\n    m = bytes_to_long(flag)\n\n    c = pow(m, e, n)\n\n    print(f'{n = }')\n    print(f'{c = }')\n\nif __name__ == '__main__':\n    main()\n\n\"\"\"\nn = 96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397\nc = 17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967\n\"\"\"\n```\n\nnext_prime的应用，也是爆破一下，因为数据量不大，给点描述就能一把梭了\n\n```python\nfrom gmpy2 import isqrt, next_prime, mpz\nfrom Crypto.Util.number import long_to_bytes\n\nn = mpz(96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397)\nc = mpz(17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967)\ne = 65537\n\ndef factor_n(n):\n    \"\"\"高效分解接近的素数因子\"\"\"\n    a = isqrt(n)  # 精确整数平方根\n    \n    # 从平方根开始向前搜索素数作为候选p\n    p = next_prime(a - 10**7)  # 从稍低于平方根的位置开始\n    \n    # 尝试p和p后面的114514个素数作为q\n    for _ in range(10000000):  # 安全范围内搜索\n        q = n // p\n        \n        # 检查是否找到有效因子\n        if p * q == n:\n            return p, q\n        \n        # 移动到下一个候选p\n        p = next_prime(p)\n    \n    return None, None\n\np, q = factor_n(n)\n\nif p and q:\n    phi = (p-1)*(q-1)\n    d = pow(e, -1, phi)\n    m = pow(c, d, n)\n    flag = long_to_bytes(int(m))\n    print(\"Flag:\", flag.decode())\nelse:\n    print(\"未找到因子\")\n```\n\n\n\nflag：  moectf{vv0W_p_m1nu5_q_i5_r34l1y_sm4lI}\n\n\n\n## 4.ez_square\n\n原题：\n\n```python\nfrom Crypto.Util.number import *\nfrom secret import flag\n\nassert len(flag) == 35\nassert flag[:7] == b'moectf{'\nassert flag[-1:] == b'}'\n\ndef main():\n    p = getPrime(512)\n    q = getPrime(512)\n\n    n = p * q\n    e = 65537\n\n    m = bytes_to_long(flag)\n\n    c = pow(m, e, n)\n    hint = pow(p + q, 2, n)\n\n    print(f'{n = }')\n    print(f'{c = }')\n    print(f'{hint = }')\n\nif __name__ == '__main__':\n    main()\n\n\"\"\"\nn = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149\nc = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190\nhint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304\n\"\"\"\n```\n\nrsa加密公式的考察，不难，也能一把梭\n\n```python\nimport math\nfrom Crypto.Util.number import long_to_bytes\n\n# 已知参数\nn = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149\nc = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190\nhint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304\ne = 65537\n\n# 关键推导：(p+q)² = (p-q)² + 4pq，而hint = (p+q)² mod n = (p-q)² mod n\n# 计算s = (p+q)² = 4n + hint（因为hint = (p-q)²且小于n）\ns = 4 * n + hint\n\n# 求s的平方根得到p+q\ns_sqrt = math.isqrt(s)\nassert s_sqrt * s_sqrt == s, \"s不是完全平方数，推导错误\"\n\n# 求hint的平方根得到p-q\nd_sqrt = math.isqrt(hint)\nassert d_sqrt * d_sqrt == hint, \"hint不是完全平方数，推导错误\"\n\n# 计算p和q\np = (s_sqrt + d_sqrt) // 2\nq = (s_sqrt - d_sqrt) // 2\n\n# 验证p*q是否等于n\nassert p * q == n, \"分解n失败\"\n\n# 计算欧拉函数φ(n)\nphi = (p - 1) * (q - 1)\n\n# 计算私钥d（e的逆元）\nd = pow(e, -1, phi)\n\n# 解密得到明文m\nm = pow(c, d, n)\n\n# 转换为flag\nflag = long_to_bytes(m)\nprint(\"解密得到的flag:\", flag.decode())\n\n```\n\n\n\nflag：   moectf{Ma7hm4t1c5_is_@_k1nd_0f_a2t}\n\n\n\n## 5.**ezlegendre**\n\n原题：\n\n```python\nfrom Crypto.Util.number import getPrime, bytes_to_long\nfrom secret import flag\n\np = 258669765135238783146000574794031096183\na = 144901483389896508632771215712413815934\n\ndef encrypt_flag(flag):\n    ciphertext = []\n    plaintext = ''.join([bin(i)[2:].zfill(8) for i in flag])\n    for b in plaintext:\n        e = getPrime(16)\n        d = randint(1,10)\n        n = pow(a+int(b)*d, e, p)\n        ciphertext.append(n)\n    return ciphertext\n\nprint(encrypt_flag(flag))\n\n```\n\n数据都给你了，直接读数据得出未知数就好了\n\n```python\nfrom Crypto.Util.number import isPrime\nfrom tqdm import tqdm\n\n# 已知参数\np = 258669765135238783146000574794031096183\na = 144901483389896508632771215712413815934\n\n# 假设我们有部分密文\nciphertext = [102230607782303286066661803375943337852, 196795077203291879584123548614536291210, 41820965969318717978206410470942308653, 207485265608553973031638961376379316991, 126241934830164184030184483965965358511, 20250852993510047910828861636740192486, 103669039044817273633962139070912140023, 97337342479349334554052986501856387313, 159127719377115088432849153087501377529, 45764236700940832554086668329121194445, 35275004033464216369574866255836768148, 52905563179465420745275423120979831405, 17032180473319795641143474346227445013, 29477780450507011415073117531375947096, 55487351149573346854028771906741727601, 121576510894250531063152466107000055279, 69959515052241122548546701060784004682, 173839335744520746760315021378911211216, 28266103662329817802592951699263023295, 194965730205655016437216590690038884309, 208284966254343254016582889051763066574, 137680272193449000169293006333866420934, 250634504150859449051246497912830488025, 124228075953362483108097926850143387433, 232956176229023369857830577971626577196, 149441784891021006224395235471825205661, 118758326165875568431376314508740278934, 222296215466271835013184903421917936512, 49132466023594939909761224481560782731, 406286678537520849308828749751513339, 215122152883292859254246948661946520324, 81283590250399459209567683991648438199, 150395133067480380674905743031927410663, 5710878479977467762548400320726575491, 83627753774286426170934105100463456109, 164968224377869331545649899270867630850, 241057183685774160581265732812497247167, 109136287048010096863680430193408099828, 116313129605409961931811582899075031153, 202739016625709380026000805340243458300, 25408225921774957745573142542576755590, 151336258796933656160956289529558246702, 2947189044370494063643525166023973095, 228678413963736672394976193093568181979, 40627063032321835707220414670018641024, 55446789315226949622969082042881319148, 32219108726651509070669836923591948459, 134454924722414419191920784435633637634, 97952023967728640730045857104376826039, 20659076942504417479953787092276592682, 93281761173713729777326842152860901050, 133634773495582264000160065317239987936, 79976720152435218818731114555425458470, 234654694673289327542859971371886984118, 51332273108989067644245919615090753756, 134120280423303717489979349737802826605, 182001158305920226320085758522717203725, 98408798757865562737462169470346158516, 78200435603900368619334272308272773797, 232796357836930341547987600782979821555, 589106968861493082018132081244848952, 24186003230092331554886767628744415123, 236070626491251466741246103662922841423, 238699080882667864827094121849090696547, 141659873734297659078160283051728812410, 228977113517120063860252637394240795552, 236613527842969921794004708284265628300, 145522034982744654991661857596541755396, 249608374387044047328725156440984678776, 325110572051913836681821746093704556, 171492052199838424502681030556098576483, 156498865212994371079795360268866413702, 196747701509389071931992996873572785043, 70811811603137896158765356680364490781, 83672551582385607422240464086955462541, 117961603623637997457153763936550310698, 224448821395214505399297116719025174412, 4598815373009554321735225938200807251, 194892269604260726530091473301914449005, 127484628022155760909820605666827662175, 208706240846212140439291547368645656474, 14102286481104997303651684152195298336, 6129503335471304345451795609683770657, 103799668048593149396277157385628834185, 185813375481410513002496683918106238351, 233491689316882978147517340230794025796, 46274083097168831187719988888816378961, 119487551553664772614629936285345836934, 84340029922118279362389419277915602509, 88253743193124528032223101368846247085, 227895357640018330099501504941388167432, 92189947144174433744195727086236905626, 83114957902192791332190922428847199876, 173535754090441937731619031520699325122, 192309407933789484835602071782330798398, 255421921600128994923738650157598053776, 155535082468314012733563336837641958625, 49064798421022327310707074253263463055, 161216416471071644769301963857685054031, 252480348817188872515008985698620059851, 75854882798183185741756645038434215611, 256065006192683011190132982128640682537, 87507510173514424105732562474643251223, 163309795132131534875147566536485288212, 253583084320404985699510129361746869059, 253300112521651972637580307326576568313, 239027717080729650738678032571840680727, 117444657686971615526398894470673026034, 215470942802874046857958621181684551426, 58767098748728136687851735836323448020, 249357164697409977883764098879705065535, 174705348385893117518084017669958647345, 211108767177375215605155301209259781232, 57829566748907062397366819001461941421, 88265742700024922112974862134385921564, 80952107622167923709226013231566882261, 236078582132483864916117213281193714198, 193448482646563141692726575550417225891, 245972799166806058223048506073553726233, 10132977708896091601871557249244373666, 201785418152654519825849206312616081028, 15169816744048531212384271865884567710, 122545328290385950043826822277924297182, 202918646192255177261567701479991753600, 32696887488223731055835744711207261936, 88319352182963224921157305627381030375, 92381505322264045777004475690398861771, 189745654013352563126968415157143821842, 152254915005998949299817641843658795579, 198032433618991362619448347415342295581, 84073892809321676935569114878067118319, 82243805869584256211699602267760745768, 61994229948266781537191603999495995852, 253668765227759797787675352833142466255, 38865376724677211964966907748953557125, 134615436811268347303232550777225944929, 176932422465426107783498083830285780588, 207573742393618910694054452362826628208, 200033130835394442710748301293534928706, 127536063935293533700918451145963158658, 219125698281820710910675956971948816959, 179795893258398750139395156587561075767, 69649628109726874051635160004398498964, 241433717681314766463039563422535023524, 202664264135718511331695232476272832350, 205151096657425932591242432052912914182, 210305712465948130683966275157181140301, 196555690055906934925300527324955477733, 66817932643964538216259564711698986077, 95270796440975607179107356182889534333, 123226880424532374188134357659879826495, 53506495440223773538415807620524749240, 19253217887083870834249774316467647628, 165699356396365023442008488156823647206, 107809175498119862854792975070673056027, 250453989887421415931162217952559757164, 171492052199838424502681030556098576483, 133778166882550119563444625306816232463, 149009301604122447269581792013291889175, 9982418254629616281350713836647603294, 203486292122499140756846060502464655972, 157686696123400087437836943220926921848, 88338919773540412238116717043122711811, 113265824169274322024623493892867211478, 5549372099744960679418616304893848801, 12431828907518852062050349123660880165, 183957934738536914983862053251433028750, 42027289270308356303682029801998790750, 117406080036483925915502666019795783905, 154312255292300186042636734144948304054, 143706917273862261295046346995206133170, 50088136095338601440516112338120787526, 250634504150859449051246497912830488025, 8073010289877796888705519374892639903, 40049582814576788803483039836229025416, 227012342545923833983403067401561291645, 201776603581414625783054400184026088994, 55474945478884522762318445841998187357, 221515530211550293408010846844218019597, 172650752042211610909190315288155597255, 67046194931321172530462444254204111483, 207435868835185636819659137800256834557, 188063222224545200294767050268070647452, 58099349021260301211275261896736590564, 23598877596106927870697531042828774738, 58546308516383335224739442370238545000, 58125311541947998710088435169901475101, 238219925698115060748249043752036454438, 203910234934340893915761800653823457631, 190854889967769152565565000250829375099, 37573623890629846209257307181880876288, 226220240200270623843038279593586687278, 144246075981535671790438155977352345487, 14665770553338784222331493932533448756, 37992062606775322664977502677838074649, 47370175759976523832233910009306151684, 97047813247943880266351445874642842468, 237607444658797800072728280983357541134, 174853113478993738890584814806707459112, 17104608155861584438824639050715857607, 83639027011494777283064583268678718843, 237826165608708003941944469905843354705, 231707683915242052796886276983724691027, 146089830852925550139294146760718642221, 25604562707667550478623425477029052785, 108577663147976992047614498924706939204, 69040319834829375335287614995435269276, 169933229202934375632745753379104389929, 72693008284867494808267387710985847974, 158548279589965576940349068403862889270, 49458101234256610254825879149914255140, 24389558269688411084589654047215902968, 210567980379246548727819953025607019254, 110423375132252997825868399832298953831, 109589895677661968369424757992411668628, 66177577069199763925999718357846633613, 83602293803708828242273186265396676466, 172226271050176278536911356541786290551, 85799805809703976643034084477579915867, 179399990302447560847151603157937241688, 81687654752229170984692833277072534294, 160766441640281044008645821822296569868, 100306680611749750243920501921769642984, 42195187332833922597871030332905266026, 238918420772178508359295233180536910768, 221685929158944699801776621298532178665, 209349638787804999657456057184702655805, 183953393268431043006359511952782903516, 137364333131365794683132159746962959967, 15637689373906596015395350692459218048, 145956368418289159411911667337899986262, 197987711355277581048877821432652325207, 125421308989313724733467092345532539875, 90525081516582408488547894471421476595, 107405840115256692042814887586009104950, 71587500700172519801649824611045199280, 10155721246869986043302768283257682883, 100522792569358427133597834727509523742, 244473925018526409824670892423775482110, 50746138425761666610345252577572889037, 142188269919422432629363225167297071042, 8235113926890598897465093754260801947, 174540885017405784646782293055852044631, 171949847901434672429841435895697323702, 34391199559497599434575002007581170988, 7337868660819385932166025474594964373, 89608475952042154068811282935241824949, 162561097613906905390170334328135062933, 252566077272083954707900007055640560669, 4284637988579219107997224848114896904, 220026371387782427901244689037957398829, 86019060485320999498155965142619258089, 19304861731281576405798605142335886482, 123188238667151068575810494833929221938, 125089740978532716086813732154638565196, 252061524500088702951562270741214799294, 89528875472312768404823823905699760649, 63307407053590054220492282094909190524, 24389558269688411084589654047215902968, 43835777110183833958990705735152973942, 196543204310466258426232803779025620993, 225032412767857179129234169288824097261, 50292890880286260984317361296226049436, 64928956886509273090981701066528078331, 25408225921774957745573142542576755590, 235921667882292842303120860570747218086, 217132603855089441017750752624514343437, 11106129204256119599329380588789107048, 147501327490657927610543345089238991876, 158091159632919983870444592039392730373, 254215886971254771885657857148535673338, 129869106474614345624950211566868568809, 10425702332274469498479699675668087022, 136595953187315682777976356839442311764, 1607792140397737044118662059498732982, 23710000155612873207506044342091514799, 118571340370877720354330132780832828911, 194624784476702188629452374731837038856, 51332273108989067644245919615090753756, 240921043405288511960365826273938845156, 158670188709175825212687487436006138030, 133641825913283256858340618209700716053, 43054466484232130048301271684438593412, 20361972967806283315536154125012604660, 135700832615866572032111395529532615300, 160609169788639387827865051539103507016, 100576279475451993660766480883708996211, 215424685541583305069271024253690375127, 60018956375784961551937423504137141702, 107997941230633604720421526632224279451, 219482010609171816035007605036664317041, 22173526221024380740269311947729076493, 249746554302052221287371350978970766087, 93207359085331319264650563354951254906, 221421697282310997113867048083058096452, 61834092635779365101011109381392037516, 162215218701897689647766394615098617152, 141856131587452385513407955541400099703, 177910903795887762773545874929605680469, 228832704523723308335513552177377803295, 229427981969125094398744034150988525118, 217938760689082034514008764751385239765, 3238055163645731541423094980789895030, 42308449860804765793467328093112118974, 254764518926620089428032312378507653680, 215733901156118606036318409454786603209, 59640829345183339336712595595022506261, 33515071724475649656070325837411550208, 51175659069843551646353202764296812462, 211462959696081863041546889096760952490, 230559603938699838189391087728971115767, 85878911733601049548471257838175175563, 214134904074265214033878852207103328297, 160702405980652445507529591230654474171, 223755040649990285320102091954198427148, 166476753890268002826149533120107157745, 26283916639129998224675164834425763384, 232971495542024495583092055361321729894, 79741799146769724681649849525636816379, 228506526471280046809909301748098760369, 167502422063741368765891061653686283332, 26984184590668253713951516794937308166, 105952393031190074432183821281493254, 113823192955281698937767041115166174652, 93264047694114869263275726820602569731, 55481974783112950660682138071588408040, 108961894273530837550182447112767144669, 47975793549419083945738147934068241928, 204024371586357035343484206754422857590, 251859351272989525849999231358507018068, 75939709807860493804628805619699991501, 129031774446142139804436921156668129187, 110764318451937254261883856778359218969, 246404864722813298477426808193494673610, 153818236564405157581869620439634140065, 246125932167584353084676586883038397451]\n\n# 预计算16位素数\nprimes_16bit = [i for i in range(2, 2**16) if isPrime(i)]\n\ndef decrypt_bit(n):\n    for b in [0, 1]:  # 尝试0和1\n        for d in range(1, 11):  # 尝试d从1到10\n            for e in primes_16bit:  # 尝试所有16位素数\n                if pow(a + b*d, e, p) == n:\n                    return str(b)\n    return '?'  # 未找到\n\n# 解密所有位\nplain_bits = []\nfor n in tqdm(ciphertext):\n    plain_bits.append(decrypt_bit(n))\n\n# 将二进制字符串转换回字节\nplaintext = ''.join(plain_bits)\nflag = bytes(int(plaintext[i:i+8], 2) for i in range(0, len(plaintext), 8))\nprint(flag)\n```\n\nflag：b'moectf{Y0u_h@v3_ju5t_s01v3d_7h1s_pr0b13m!}'\n\n\n\n\n\n总结：为数不多能ak的密码（如果后续不上题的话），刚学两三个月的密码手适合做，可以增强一下信心以及练一下基本功\n\n最后，测试一下图片：\n\n\n\n![099f596209ac5396bf92b5f661c7ed24](2025moectf(Crypto)/099f596209ac5396bf92b5f661c7ed24.jpeg)\n\n哦，后续会继续上题","tags":["CTF","Crypto"],"categories":["CTF","Crypto"]}]