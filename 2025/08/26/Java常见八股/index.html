

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Agent">
  <meta name="keywords" content="Crypto,Reverse,算法,编程技术,日常">
  
    <meta name="description" content="Java常见八股一、Java 基础 (Java Basics)1. 接口 (Interface) vs 抽象类 (Abstract Class)面试官： 说一下接口和抽象类的区别。 我：好的，接口和抽象类主要有以下几个核心区别：  设计目的不同：抽象类描述的是 “is-a” 关系，强调类的本质是什么，比如 Manager 是一个 Employee。而接口描述的是 “has-a” 或 “can-do">
<meta property="og:type" content="article">
<meta property="og:title" content="Java常见八股">
<meta property="og:url" content="http://tow-086.github.io/2025/08/26/Java%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Agent的个人博客">
<meta property="og:description" content="Java常见八股一、Java 基础 (Java Basics)1. 接口 (Interface) vs 抽象类 (Abstract Class)面试官： 说一下接口和抽象类的区别。 我：好的，接口和抽象类主要有以下几个核心区别：  设计目的不同：抽象类描述的是 “is-a” 关系，强调类的本质是什么，比如 Manager 是一个 Employee。而接口描述的是 “has-a” 或 “can-do">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-26T04:00:00.000Z">
<meta property="article:modified_time" content="2025-08-26T14:52:30.142Z">
<meta property="article:author" content="Agent">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="为了实习说是">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Java常见八股 - Agent的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tow-086.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Agent的个人博客" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java常见八股"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-26 12:00" pubdate>
          2025年8月26日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          152 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java常见八股</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Java常见八股"><a href="#Java常见八股" class="headerlink" title="Java常见八股"></a><strong>Java常见</strong>八股</h1><h2 id="一、Java-基础-Java-Basics"><a href="#一、Java-基础-Java-Basics" class="headerlink" title="一、Java 基础 (Java Basics)"></a><strong>一、Java 基础 (Java Basics)</strong></h2><h3 id="1-接口-Interface-vs-抽象类-Abstract-Class"><a href="#1-接口-Interface-vs-抽象类-Abstract-Class" class="headerlink" title="1. 接口 (Interface) vs 抽象类 (Abstract Class)"></a><strong>1. 接口 (Interface) vs 抽象类 (Abstract Class)</strong></h3><p><strong>面试官：</strong> 说一下接口和抽象类的区别。</p>
<p><strong>我：</strong><br>好的，接口和抽象类主要有以下几个核心区别：</p>
<ol>
<li><strong>设计目的不同</strong>：抽象类描述的是 <strong>“is-a”</strong> 关系，强调类的本质是什么，比如 <code>Manager</code> 是一个 <code>Employee</code>。而接口描述的是 <strong>“has-a” 或 “can-do”</strong> 关系，强调类具备什么能力，比如 <code>Bird</code> 可以 <code>Fly</code>。</li>
<li><strong>方法实现</strong>：抽象类可以有抽象方法，也可以有实现了的具体方法，用于代码复用。在JDK 8之前，接口只能有抽象方法；JDK 8之后，接口可以拥有默认方法（<code>default</code>）和静态方法（<code>static</code>）。</li>
<li><strong>成员变量</strong>：抽象类中的变量可以是普通的，也可以是常量。而接口中定义的变量默认都是 <code>public static final</code> 的常量。</li>
<li><strong>构造方法</strong>：抽象类有构造方法，虽然不能实例化自己，但可以供子类初始化时调用。接口没有构造方法。</li>
<li><strong>继承性</strong>：这是最关键的差别。Java是单继承，一个类<strong>只能继承一个</strong>抽象类。但一个类可以<strong>实现多个</strong>接口，从而获得多种能力。</li>
</ol>
<p><strong>选用场景</strong>：</p>
<ul>
<li>如果需要定义一系列<strong>密切相关</strong>对象的共同模板和行为，优先使用<strong>抽象类</strong>。</li>
<li>如果需要定义一种<strong>能力或契约</strong>，让<strong>不相关</strong>的类都能拥有，或者需要实现多重继承的效果，就使用<strong>接口</strong>。</li>
</ul>
<hr>
<h3 id="2-单例模式-Singleton-Pattern-与双重检查锁-Double-Checked-Locking"><a href="#2-单例模式-Singleton-Pattern-与双重检查锁-Double-Checked-Locking" class="headerlink" title="2. 单例模式 (Singleton Pattern) 与双重检查锁 (Double-Checked Locking)"></a><strong>2. 单例模式 (Singleton Pattern) 与双重检查锁 (Double-Checked Locking)</strong></h3><p><strong>面试官：</strong> 了解单例模式吗？写一个线程安全的单例。</p>
<p><strong>我：</strong><br>单例模式的核心是保证一个类在任何情况下都只有一个实例，并提供一个全局访问点。</p>
<p>实现线程安全的单例有多种方式，比如饿汉式、懒汉式加锁、静态内部类等。其中，<strong>双重检查锁（DCL）</strong> 是一种性能和线程安全兼顾的懒加载方案。</p>
<p>（如果让写代码，我会写出DCL的代码。但按您要求，这里不做代码展示）</p>
<p><strong>它的核心思路是：</strong></p>
<ol>
<li>将实例引用用 <code>volatile</code> 关键字修饰。</li>
<li>在 <code>getInstance</code> 方法中，先进行一次判空，如果实例不存在，再进入同步代码块。</li>
<li>进入同步块后，再进行第二次判空，最后才创建实例。</li>
</ol>
<p><strong>面试官：</strong> 为什么这里必须要用 <code>volatile</code> 关键字？</p>
<p><strong>我：</strong><br><code>volatile</code> 在这里主要作用是<strong>禁止指令重排序</strong>。</p>
<p><code>instance = new Singleton()</code> 这行代码不是一个原子操作，它分为三步：1.分配内存、2.初始化对象、3.将引用指向内存地址。JVM可能对步骤2和3进行重排序。</p>
<p>如果没有 <code>volatile</code>，可能发生：线程A执行了1和3，此时 <code>instance</code> 不为null，但对象还未初始化（步骤2未执行）。这时线程B进来判断 <code>instance</code> 不为null，就直接返回了一个<strong>半成品对象</strong>去使用，从而导致错误。</p>
<p><code>volatile</code> 通过内存屏障禁止了这种重排序，保证了对象的初始化完成在前，引用赋值在后，从而解决了这个隐蔽的问题。</p>
<p><strong>其他实现方式的对比：</strong></p>
<ul>
<li><strong>饿汉式</strong>：最简单，线程安全，但不是懒加载，可能造成资源浪费。</li>
<li><strong>同步方法懒汉式</strong>：线程安全，但锁粒度太大，性能差。</li>
<li><strong>静态内部类</strong>：我个人认为是最优雅的实现之一。它利用类加载机制保证了线程安全，且实现了懒加载，无需加锁，性能高。</li>
<li><strong>枚举</strong>：最安全的方式，不仅能避免多线程问题，还能防止反射和反序列化破坏单例。</li>
</ul>
<h2 id="二、Java-集合框架-Java-Collections-Framework"><a href="#二、Java-集合框架-Java-Collections-Framework" class="headerlink" title="二、Java 集合框架 (Java Collections Framework)"></a><strong>二、Java 集合框架 (Java Collections Framework)</strong></h2><h4 id="1-HashMap-深度解析"><a href="#1-HashMap-深度解析" class="headerlink" title="1. HashMap 深度解析"></a><strong>1. HashMap 深度解析</strong></h4><p><strong>面试官：</strong> 能详细说说 HashMap 的实现原理吗？</p>
<p><strong>我：</strong><br>好的。HashMap 的核心实现是“数组 + 链表 + 红黑树”。</p>
<hr>
<p><strong>面试官：</strong> 具体讲讲它的数据结构？</p>
<p><strong>我：</strong></p>
<ol>
<li><strong>数据结构</strong>：<ul>
<li>底层是一个 <code>Node&lt;K,V&gt;[] table</code> 数组。</li>
<li>数组的每个位置称为一个“桶”（bucket）。存入时，根据 key 的 hash 值计算出数组下标。</li>
<li>如果不同的 key 落到了同一个桶里（哈希冲突），就用链表来存储。</li>
<li>当链表长度超过阈值（默认为8），并且数组总长度达到一定规模（默认为64）时，链表会转换为红黑树。</li>
<li>当树节点数小于阈值（默认为6）时，红黑树会退化成链表。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 为什么要引入红黑树？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>引入红黑树的原因</strong>：</li>
</ol>
<p>- 解决极端情况下（例如大量数据哈希冲突），链表过长导致的查询效率从 O(1) 退化为 O(n) 的问题。<br>- 红黑树是一种自平衡的二叉查找树，能将查询、插入、删除的时间复杂度控制在 O(log n)，保证了性能下限。</p>
<hr>
<p><strong>面试官：</strong> HashMap 什么时候扩容？怎么扩？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>扩容机制（Rehashing）</strong>：</li>
</ol>
<p>- 当元素数量超过 <code>容量 * 负载因子</code>（默认0.75）时，数组会进行扩容（通常扩为原来的2倍）。<br>- 扩容后，所有元素需要重新计算在新数组中的位置，这是一个比较耗时的操作。</p>
<hr>
<p><strong>面试官：</strong> 为什么 HashMap 的长度总是2的幂次方？</p>
<p><strong>我：</strong></p>
<ol start="4">
<li><strong>长度为何是2的幂次方</strong>：</li>
</ol>
<p>- 为了高效地通过 <code>(n - 1) &amp; hash</code> 计算 key 的索引位置。<br>- <code>&amp;</code> 操作比取模运算 <code>%</code> 效率高得多。当数组长度 n 为 2 的幂时，<code>(n - 1) &amp; hash</code> 等价于 <code>hash % n</code>，但效率更高，同时能保证计算结果均匀分布。</p>
<hr>
<p><strong>面试官：</strong> 从 JDK7 到 JDK8，HashMap 在解决冲突时有什么重要变化？</p>
<p><strong>我：</strong></p>
<ol start="5">
<li><strong>JDK7头插法 -&gt; JDK8尾插法</strong>：</li>
</ol>
<p>- <strong>JDK7</strong> 使用头插法，认为新插入的元素更可能被马上访问。但在多线程扩容时，头插法会改变链表的顺序，可能导致<strong>形成环形链表</strong>，引起死循环和数据丢失。<br>- <strong>JDK8</strong> 改为尾插法，扩容时链表元素顺序不变，解决了这个潜在问题。（但HashMap本身仍非线程安全，只是解决了这个特定的死循环Bug）。</p>
<hr>
<p><strong>面试官：</strong> 为什么选择这种链表和红黑树结合的方式？</p>
<p><strong>我：</strong></p>
<ol start="6">
<li><strong>为何采用链表+红黑树</strong>：</li>
</ol>
<p>- 这是一种在<strong>空间</strong>和<strong>时间</strong>上的权衡。<br>- 链表结构简单，占用内存少，但在节点多时性能差。<br>- 红黑树性能好，但结构复杂，占用内存更多。<br>- 这种设计保证了在绝大多数冲突较少的情况下使用高效的链表，仅在少数冲突严重时转为红黑树，以空间换时间，达到整体最优。</p>
<h3 id="2-ArrayList-vs-LinkedList"><a href="#2-ArrayList-vs-LinkedList" class="headerlink" title="2. ArrayList vs LinkedList"></a><strong>2. ArrayList vs LinkedList</strong></h3><p><strong>面试官：</strong> 对比一下 ArrayList 和 LinkedList。</p>
<p><strong>我：</strong><br>好的。它们核心区别在于底层数据结构和由此带来的性能差异。</p>
<ol>
<li><strong>底层结构</strong>：<ul>
<li><strong>ArrayList</strong> 基于<strong>动态数组</strong>。内存中是连续的存储空间。</li>
<li><strong>LinkedList</strong> 基于<strong>双向链表</strong>。内存中是通过节点指针连接的离散存储。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 它们在操作效率上有什么不同？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>操作效率</strong>：</li>
</ol>
<p>- <strong>随机访问 (get&#x2F;set)</strong>：ArrayList 的复杂度是 O(1)，因为它可以通过下标直接计算内存地址。LinkedList 是 O(n)，需要遍历链表。<br>- <strong>头部插入&#x2F;删除</strong>：ArrayList 是 O(n)，因为需要移动后续所有元素。LinkedList 是 O(1)，只需修改指针。<br>- <strong>尾部插入&#x2F;删除</strong>：两者在已知尾节点的情况下都接近 O(1)。ArrayList 在无需扩容时是 O(1)；LinkedList 需要先遍历到尾部（如果没有尾指针记录）是 O(n)，但通常实现会记录尾指针，所以也是 O(1)。<br>- <strong>中间插入&#x2F;删除</strong>：ArrayList 平均需要移动一半元素，是 O(n)。LinkedList 查找位置是 O(n)，但插入&#x2F;删除操作本身是 O(1)。</p>
<hr>
<p><strong>面试官：</strong> 它们的内存占用有什么特点？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>内存占用</strong>：</li>
</ol>
<p>- <strong>ArrayList</strong> 只在数组尾部预留空间，内存利用率高。但扩容时会造成临时浪费。<br>- <strong>LinkedList</strong> 每个元素都需要消耗额外空间存放前后节点的指针，内存开销更大。</p>
<hr>
<p><strong>面试官：</strong> 实际开发中如何选择？</p>
<p><strong>我：</strong></p>
<ol start="4">
<li><strong>适用场景</strong>：</li>
</ol>
<p>- 优先选择 <strong>ArrayList</strong>。因为它CPU缓存友好（内存连续），综合性能在大多数读多写少的场景下更好。<br>- 只有在需要频繁在<strong>列表头部或中间</strong>进行插入&#x2F;删除操作时，才考虑使用 <strong>LinkedList</strong>。</p>
<h3 id="3-ConcurrentHashMap-原理与演进"><a href="#3-ConcurrentHashMap-原理与演进" class="headerlink" title="3. ConcurrentHashMap 原理与演进"></a><strong>3. ConcurrentHashMap 原理与演进</strong></h3><p><strong>面试官：</strong> 讲一下 ConcurrentHashMap 的原理，以及它在 JDK7 和 JDK8 的实现有什么不同。</p>
<p><strong>我：</strong><br>好的。ConcurrentHashMap 是 HashMap 的线程安全版本，它的实现原理在 JDK7 和 JDK8 有重大变化。</p>
<hr>
<p><strong>面试官：</strong> 先说下 JDK7 是怎么实现的？</p>
<p><strong>我：</strong></p>
<ol>
<li><strong>JDK7分段锁实现 (Segment Locking)</strong>：<ul>
<li>它内部有一个 <strong>Segment</strong> 数组，每个 Segment 本质上就是一个独立的、继承了 ReentrantLock 的 HashEntry[] 数组（一个小HashMap）。</li>
<li><strong>“分段锁”</strong> 的思想是：锁不再针对整个Map，而是只锁住其中一个 Segment。这样，不同 Segment 的读写操作可以完全并行，大大提升了并发度。</li>
<li>默认有 16 个 Segment，所以理论上最多可以支持 16 个线程同时写入。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 那 JDK8 呢？为什么又改了？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>JDK8 CAS + synchronized 实现</strong>：</li>
</ol>
<p>- JDK8 抛弃了 Segment 分段锁的概念，它的底层数据结构变得和 HashMap 一样，是 <strong>Node[] 数组 + 链表 + 红黑树</strong>。<br>- 实现线程安全的方式更加细化：<br>- <strong>CAS (无锁算法)</strong>：用于初始化数组、向桶中插入节点（当桶为空时）等无竞争场景，性能极高。<br>- <strong>synchronized (同步锁)</strong>：当发生哈希冲突，需要操作链表或红黑树时，则只<strong>锁住当前发生冲突的桶（链表头节点&#x2F;树根节点）</strong>。锁的粒度从 JDK7 的一个 Segment（管着很多桶）缩小到了一个桶，并发度更高。<br>- 这种设计结合了 CAS 的高性能和 synchronized 的稳定性，并且在锁粒度上做到了极致。</p>
<hr>
<p><strong>面试官：</strong> 从 JDK7 到 JDK8 这次升级主要带来了哪些好处？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>JDK7 到 JDK8 的升级</strong>：</li>
</ol>
<p>- <strong>锁粒度更小</strong>：从锁一段（Segment）到锁一桶（Bucket），并发性能得到极大提升。<br>- <strong>数据结构优化</strong>：引入了红黑树，解决了链表过长时查询慢的问题，保证了最坏情况下的性能。<br>- <strong>API 增强</strong>：提供了更多方便的流式 API（如 <code>forEach</code>, <code>reduce</code>）。<br>- <strong>代码更简化</strong>：移除了复杂的 Segment 结构，底层实现变得更简洁、更统一（和 HashMap 类似），更易于维护和理解。</p>
<h2 id="三、Java-并发编程-Java-Concurrency"><a href="#三、Java-并发编程-Java-Concurrency" class="headerlink" title="三、Java 并发编程 (Java Concurrency)"></a><strong>三、Java 并发编程 (Java Concurrency)</strong></h2><h4 id="1-乐观锁与悲观锁"><a href="#1-乐观锁与悲观锁" class="headerlink" title="1. 乐观锁与悲观锁"></a><strong>1. 乐观锁与悲观锁</strong></h4><p><strong>面试官：</strong> 说说你对乐观锁和悲观锁的理解。</p>
<p><strong>我：</strong><br>好的，这是两种不同的并发控制策略。</p>
<ol>
<li><strong>悲观锁</strong>：<ul>
<li><strong>思想</strong>：认为并发冲突是<strong>大概率事件</strong>，每次操作数据时，都假定别人会修改，所以先加锁再操作。</li>
<li><strong>实现</strong>：<code>synchronized</code> 关键字、<code>ReentrantLock</code> 等。</li>
<li><strong>类比</strong>：就像“写文档时先锁门”，防止别人打扰。</li>
</ul>
</li>
<li><strong>乐观锁</strong>：<ul>
<li><strong>思想</strong>：认为并发冲突是<strong>小概率事件</strong>，每次操作数据时，不会先加锁，而是在更新时判断此期间数据是否被他人修改过。</li>
<li><strong>实现</strong>：通常使用 <strong>CAS</strong> (Compare-And-Swap) 算法或版本号机制。</li>
<li><strong>类比</strong>：就像“写文档时不锁门”，提交时才检查有没有人动过原稿，没动过就提交，动了就放弃或重试。</li>
</ul>
</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>悲观锁</strong>：适合<strong>写多读少</strong>的场景，冲突严重时性能高。</li>
<li><strong>乐观锁</strong>：适合<strong>读多写少</strong>的场景，冲突少时性能远高于悲观锁，能减少上下文切换。</li>
</ul>
<h3 id="2-CAS-原理与原子类实现"><a href="#2-CAS-原理与原子类实现" class="headerlink" title="2. CAS 原理与原子类实现"></a><strong>2. CAS 原理与原子类实现</strong></h3><p><strong>面试官：</strong> 讲一下 CAS 的原理。</p>
<p><strong>我：</strong></p>
<ol>
<li><strong>CAS实现原理</strong>：<ul>
<li>CAS 的全称是 <code>Compare-And-Swap</code>，即<strong>比较并交换</strong>。它是一个<strong>CPU原子指令</strong>，保证了操作的原子性。</li>
<li>操作包含三个操作数：<strong>内存地址 V</strong>、<strong>旧的预期值 A</strong>、<strong>要更新的新值 B</strong>。</li>
<li><strong>原理</strong>：当且仅当内存地址 V 中的当前值等于预期值 A 时，处理器才会自动将地址 V 的值更新为新值 B，否则什么都不做。整个操作是一个原子操作。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> CAS 有什么优缺点？</p>
<p><strong>我：</strong><br><strong>优点</strong>：</p>
<ul>
<li><strong>高性能</strong>：它是一种无锁操作，避免了传统互斥锁（如 <code>synchronized</code>）带来的线程阻塞、上下文切换的开销，在低竞争环境下性能很高。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>ABA 问题</strong>：这是最经典的缺点。一个线程读取内存值为 A，此时另一个线程将值改为 B，然后又改回 A。等第一个线程执行 CAS 时，发现值还是 A，于是操作成功，但它并不知道这个 A 已经被“中间修改过”了。</li>
<li><strong>循环时间长开销大</strong>：如果 CAS 操作长时间不成功（竞争激烈），CPU 会一直进行自旋（循环重试），消耗资源。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：对于多个共享变量，CAS 无法保证原子性，可能需要加锁。</li>
</ul>
<hr>
<p><strong>面试官：</strong> 那怎么解决 ABA 问题呢？</p>
<p><strong>我：</strong></p>
<ul>
<li>可以通过给数据加上<strong>版本号（Stamp）</strong> 或时间戳来解决。</li>
<li>Java 提供了 <code>AtomicStampedReference</code> 类。它不仅在比较值，还会比较一个 <code>int</code> 型的版本号标记。任何对值的修改都会使版本号递增，这样即使值从 A 变回 A，版本号也变了，CAS 就会失败。</li>
</ul>
<hr>
<p><strong>面试官：</strong> 原子类（比如 AtomicInteger）是如何利用 CAS 实现的？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>原子类实现原理</strong>：</li>
</ol>
<p>- 原子类（如 <code>AtomicInteger</code>）内部的核心字段（如 <code>value</code>）都由 <code>volatile</code> 修饰，保证了可见性。<br>- 它们的所有原子性方法（如 <code>getAndIncrement()</code>）内部都调用了 <code>Unsafe</code> 类的 CAS 方法（<code>compareAndSwapInt</code>）。<br>- 以 <code>i++</code> 为例，<code>getAndIncrement()</code> 的实现是一个 <strong>CAS 自旋循环</strong>：先获取当前值，计算新值，然后用 CAS 尝试更新。如果失败（值已被其他线程修改），就重新获取当前值，再次计算和尝试，直到成功为止。</p>
<h3 id="3-synchronized-与-ReentrantLock-详解"><a href="#3-synchronized-与-ReentrantLock-详解" class="headerlink" title="3. synchronized 与 ReentrantLock 详解"></a><strong>3. synchronized 与 ReentrantLock 详解</strong></h3><p><strong>面试官：</strong> 对比一下 <code>synchronized</code> 和 <code>ReentrantLock</code>。</p>
<p><strong>我：</strong><br>好的，它们的核心区别如下：</p>
<ol>
<li><strong>本质不同</strong>：<code>synchronized</code> 是 <strong>Java 关键字</strong>，由 JVM 底层实现；<code>ReentrantLock</code> 是一个 <strong>Java 类</strong>，基于 AQS 实现。</li>
<li><strong>锁的释放</strong>：<code>synchronized</code> 在代码块执行完或发生异常时，由 <strong>JVM 自动释放锁</strong>；<code>ReentrantLock</code> 必须手动调用 <code>unlock()</code> 方法释放锁，通常在 <code>finally</code> 块中完成，否则容易造成死锁。</li>
<li><strong>功能丰富性</strong>：<code>ReentrantLock</code> 功能更丰富。<ul>
<li><strong>可中断</strong>：<code>lockInterruptibly()</code> 可以响应中断，在等待锁的过程中可以被中断。</li>
<li><strong>公平锁</strong>：可以选择创建公平锁（先等待的线程先获得锁），<code>synchronized</code> 是非公平锁。</li>
<li><strong>条件队列</strong>：可以通过 <code>Condition</code> 实现多路通知，更精细地控制线程的等待与唤醒。</li>
</ul>
</li>
<li><strong>灵活性</strong>：<code>synchronized</code> 的加锁和释放锁是固化的；<code>ReentrantLock</code> 可以在方法内加锁，在另一方法内解锁，更灵活。</li>
<li><strong>锁的实现机制</strong>：<code>synchronized</code> 在 JDK6 后引入了<strong>锁升级</strong>机制来优化性能；<code>ReentrantLock</code> 则通过 AQS 内部的 CAS 自旋来实现。</li>
</ol>
<p><strong>选用建议</strong>：</p>
<ul>
<li>除非需要 <code>ReentrantLock</code> 的高级功能（如可中断、公平锁、Condition），否则<strong>优先使用 <code>synchronized</code></strong>，因为它的写法更简洁，且由 JVM 维护和优化。</li>
</ul>
<hr>
<p><strong>面试官：</strong> 详细说一下 <code>synchronized</code> 的锁升级流程。</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>synchronized 的锁升级流程</strong>：</li>
</ol>
<p>为了在性能和开销之间取得平衡，JVM 将 <code>synchronized</code> 的锁状态分为4级，并可以<strong>从低到高</strong>进行升级，但<strong>不可降级</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> <span class="hljs-strong">**无锁 (No Lock)**</span>：对象未作为同步锁使用。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**偏向锁 (Biased Locking)**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**目的**</span>：在<span class="hljs-strong">**没有竞争**</span>的情况下，消除同步开销。假设锁总是由同一线程获得。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**流程**</span>：第一个线程访问同步块时，会通过 CAS 操作将对象头中的 Mark Word 里存储的线程 ID 改为自己的 ID。之后该线程再进入时，只需检查线程 ID 是否匹配，匹配则无需任何同步操作。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**轻量级锁 (Lightweight Lock)**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**触发条件**</span>：当有<span class="hljs-strong">**轻微竞争**</span>（第二个线程来尝试获取锁）时，偏向锁会升级为轻量级锁。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**流程**</span>：线程会在自己的栈帧中创建一个锁记录（Lock Record），然后通过 <span class="hljs-strong">**CAS**</span> 操作尝试将对象头的 Mark Word 更新为指向该锁记录的指针。如果成功，当前线程就获得了锁。如果失败，会<span class="hljs-strong">**自旋**</span>重试一定次数。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**重量级锁 (Heavyweight Lock)**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**触发条件**</span>：<span class="hljs-strong">**自旋失败**</span>（竞争加剧，线程数多或等待时间长）后，锁会升级为重量级锁。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**流程**</span>：此时，未获得锁的线程会<span class="hljs-strong">**被挂起**</span>，进入阻塞状态，等待操作系统调度，需要进行用户态到内核态的切换，开销最大。<br></code></pre></td></tr></table></figure>

<hr>
<p><strong>面试官：</strong> 什么是 <code>synchronized</code> 的可重入性？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>synchronized 的可重入性</strong>：</li>
</ol>
<p>- <strong>概念</strong>：指<strong>同一个线程</strong>在执行完外层同步方法&#x2F;块后，再次进入它的内层同步方法&#x2F;块时，<strong>可以直接获得锁</strong>而不会被自己阻塞。<br>- <strong>原理</strong>：JVM 会为每个锁对象维护一个<strong>计数器</strong>和一个<strong>持有者线程标识</strong>。当线程第一次获取锁时，计数器变为1。每次重入，计数器就+1。退出同步块，计数器就-1。直到计数器为0，锁才被真正释放。<br>- <strong>重要性</strong>：可重入性避免了线程死锁自己，是设计同步代码的基础。</p>
<h3 id="4-volatile-关键字的作用与原理"><a href="#4-volatile-关键字的作用与原理" class="headerlink" title="4. volatile 关键字的作用与原理"></a><strong>4. volatile 关键字的作用与原理</strong></h3><p><strong>面试官：</strong> 讲一下 <code>volatile</code> 关键字的作用和原理。</p>
<p><strong>我：</strong><br>好的。<code>volatile</code> 是 Java 提供的轻量级同步机制，它主要有两大核心作用：<strong>保证内存可见性</strong> 和 <strong>禁止指令重排序</strong>。</p>
<hr>
<p><strong>面试官：</strong> 先解释一下什么是内存可见性，<code>volatile</code> 是如何保证的？</p>
<p><strong>我：</strong></p>
<ol>
<li><strong>内存可见性 (Memory Visibility)</strong>：<ul>
<li><strong>问题</strong>：根据 Java 内存模型 (JMM)，每个线程有自己的工作内存，用于缓存共享变量的副本。当一个线程修改了共享变量，可能只是先修改了自己的工作内存，未能<strong>立即写回主内存</strong>，导致其他线程读取到的仍然是旧的副本值。</li>
<li><strong><code>volatile</code> 的作用</strong>：当一个变量被声明为 <code>volatile</code> 后：<ul>
<li>任何线程<strong>修改</strong>这个变量，都会<strong>立即强制</strong>将新值刷新到主内存。</li>
<li>任何线程<strong>读取</strong>这个变量，都会<strong>强制</strong>从主内存中重新读取最新的值，使当前工作内存中的副本失效。</li>
</ul>
</li>
<li><strong>原理</strong>：底层是通过<strong>内存屏障</strong> (Memory Barrier) 来实现的。写操作前后会插入屏障，强制将缓存数据刷回主存；读操作前后也会插入屏障，强制使本地缓存失效，从主存拉取新数据。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 那禁止指令重排序呢？这又是什么？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>禁止指令重排序 (Prevention of Instruction Reordering)</strong>：</li>
</ol>
<p>- <strong>问题</strong>：为了提升性能，编译器和处理器常常会<strong>对指令进行重排序</strong>。但在多线程环境下，不恰当的重排序可能会导致程序运行结果与预期不符。（最经典的例子就是双重检查锁单例模式中，<code>instance = new Singleton()</code> 这行代码可能被重排序，导致其他线程拿到一个未初始化完全的对象）。<br>- <strong><code>volatile</code> 的作用</strong>：通过添加<strong>内存屏障</strong>，<code>volatile</code> 关键字禁止了 JVM 和处理器对修饰了 <code>volatile</code> 的变量的<strong>读写操作</strong>与其他指令进行重排序，从而保证了操作的有序性。<br>- <strong>原理</strong>：内存屏障就像一个“栅栏”，告诉编译器和 CPU，必须在这个屏障之前的所有操作都完成后，才能执行屏障之后的操作。</p>
<p><strong>总结</strong>：<code>volatile</code> 的核心是通过<strong>内存屏障</strong>这一 CPU 指令来实现可见性和有序性。但它<strong>不保证原子性</strong>，像 <code>i++</code> 这种复合操作依然需要加锁或使用原子类。</p>
<h3 id="5-Java-内存模型-JMM-与-Happens-Before"><a href="#5-Java-内存模型-JMM-与-Happens-Before" class="headerlink" title="5. Java 内存模型 (JMM) 与 Happens-Before"></a><strong>5. Java 内存模型 (JMM) 与 Happens-Before</strong></h3><p><strong>面试官：</strong> 谈谈你对 Java 内存模型 (JMM) 的理解。</p>
<p><strong>我：</strong><br>好的。JMM 是一个<strong>抽象的概念</strong>，它定义了程序中各种变量（线程共享变量）的访问规则，以及如何在内存中进行读写操作的细节。它屏蔽了底层硬件内存结构的差异，旨在解决多线程下的<strong>可见性</strong>、<strong>原子性</strong>和<strong>有序性</strong>问题。</p>
<hr>
<p><strong>面试官：</strong> JMM 是如何抽象内存结构的？</p>
<p><strong>我：</strong></p>
<ol>
<li><p><strong>JMM抽象模型（主内存、工作内存）</strong>：</p>
<ul>
<li><strong>主内存 (Main Memory)</strong>：存储所有的共享变量。所有线程都能访问，但速度较慢。</li>
<li><strong>工作内存 (Working Memory)</strong>：每个线程都有自己的工作内存，可以看作是<strong>CPU高速缓存和寄存器的抽象</strong>。它存储了该线程使用到的共享变量的<strong>副本</strong>。</li>
<li><strong>交互协议</strong>：JMM 规定了线程如何与主内存进行交互：<ul>
<li><strong>read</strong>：从主内存读取数据到工作内存。</li>
<li><strong>load</strong>：将 read 得到的值放入工作内存的变量副本中。</li>
<li><strong>use</strong>：执行引擎使用工作内存中的变量值。</li>
<li><strong>assign</strong>：执行引擎将新值赋给工作内存中的变量。</li>
<li><strong>store</strong>：将工作内存中的变量值传送到主内存。</li>
<li><strong>write</strong>：将 store 传来的值写入主内存的变量中。</li>
</ul>
</li>
</ul>
<p>JMM 通过这8种原子操作（还有 lock 和 unlock）来控制主内存与工作内存之间的同步，从而决定一个线程对共享变量的写入何时对另一个线程可见。<strong><code>volatile</code> 的特殊规则就体现在它强制 read&#x2F;load&#x2F;use 和 assign&#x2F;store&#x2F;write 必须连续、按顺序执行</strong>。</p>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 什么是指令重排序？它为什么会带来问题？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>指令重排序</strong>：</li>
</ol>
<p>- <strong>原因</strong>：为了充分发挥 CPU 性能，编译器和处理器常常会在<strong>不改变程序单线程执行结果</strong>的前提下，对指令的执行顺序进行重新排序优化。<br>- <strong>问题</strong>：在<strong>多线程</strong>环境下，这种重排序可能会破坏程序的语义，导致线程执行结果出现不可预测的错误。（例如，双重检查锁单例模式中，由于 <code>new</code> 操作的非原子性可能被重排序，导致其他线程拿到一个未初始化完全的对象引用）。</p>
<hr>
<p><strong>面试官：</strong> JMM 如何解决可见性和有序性问题？什么是 Happens-Before 原则？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>Happens-Before 原则</strong>：</li>
</ol>
<p>- 这是 JMM 最核心的概念。它本质上是一种<strong>可见性保证规则</strong>，用于描述两个操作之间的内存可见性。如果操作 A <strong>Happens-Before</strong> 于操作 B，那么 A 操作所产生的所有内存更改（结果）对 B 操作都是<strong>可见的</strong>。<br>- 它是一些规则的集合，无需任何同步手段就天然具有 Happens-Before 关系：</p>
<ol>
<li><strong>程序次序规则</strong>：在一个线程内，书写在前面的操作 Happens-Before 于后面的操作。（注意：这仅指执行结果上的顺序，依然可能被重排序，但重排序后的结果必须与按代码顺序执行的结果一致）。</li>
<li><strong>监视器锁规则</strong>：对一个锁的 <strong>unlock</strong> 操作 Happens-Before 于后续对这个锁的 <strong>lock</strong> 操作。</li>
<li><strong>volatile变量规则</strong>：对一个 <code>volatile</code> 变量的<strong>写</strong>操作 Happens-Before 于后续对这个变量的<strong>读</strong>操作。</li>
<li><strong>线程启动规则</strong>：<code>Thread</code> 对象的 <code>start()</code> 方法调用 Happens-Before 于此线程的任何动作。</li>
<li><strong>线程终止规则</strong>：线程中的所有操作都 Happens-Before 于其他线程检测到该线程已经终止（如 <code>thread.join()</code> 返回）。</li>
<li><strong>传递性</strong>：如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**总结**</span>：Happens-Before 关系并不代表实际执行的时间顺序，而是<span class="hljs-strong">**内存可见性的保证**</span>。它是判断数据是否存在竞争、线程是否安全的主要依据。<br></code></pre></td></tr></table></figure>

<h3 id="6-AQS-原理浅析"><a href="#6-AQS-原理浅析" class="headerlink" title="6. AQS 原理浅析"></a><strong>6. AQS 原理浅析</strong></h3><p><strong>面试官：</strong> 讲一下 AQS 的核心原理。</p>
<p><strong>我：</strong><br>好的。AQS (<code>AbstractQueuedSynchronizer</code>) 是 JUC 并发包的核心基础组件，像 <code>ReentrantLock</code>、<code>CountDownLatch</code> 等工具都是基于它实现的。它的核心思想是 <strong>“一个状态位（state）+ 一个FIFO线程等待队列（CLH）”</strong>。</p>
<hr>
<p><strong>面试官：</strong> 具体说说 state 和 CLH 队列的作用。</p>
<p><strong>我：</strong></p>
<ol>
<li><strong>AQS核心思想（state、CLH队列）</strong>：<ul>
<li><strong>状态 (state)</strong>：这是一个由 <code>volatile</code> 修饰的 <code>int</code> 成员变量，表示<strong>共享资源的状态</strong>。具体含义由子类定义，例如：<ul>
<li>在 <code>ReentrantLock</code> 中，<code>state=0</code> 表示锁未被占用，<code>state&gt;0</code> 表示锁被占用，且数值表示<strong>重入次数</strong>。</li>
<li>在 <code>Semaphore</code> 中，<code>state</code> 表示<strong>剩余的许可证数量</strong>。</li>
</ul>
</li>
<li><strong>CLH队列</strong>：这是一个虚拟的<strong>双向 FIFO 队列</strong>，用于管理获取资源失败的线程。当线程争抢资源失败时，AQS 会将当前线程及其等待状态等信息构造成一个节点（Node）并加入队尾，然后阻塞该线程（<code>LockSupport.park()</code>）。队列头节点表示当前正持有资源的线程。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> AQS 是如何基于这个核心思想来实现公平锁的？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>如何实现公平锁</strong>：</li>
</ol>
<p>- <strong>公平锁</strong> 的核心原则是：<strong>先来后到</strong>，即等待时间最长的线程（队列头节点的后继节点）优先获取资源。<br>- <strong>实现机制</strong>：当一个线程（Thread-A）尝试通过 <code>lock()</code> 方法获取锁时，它的核心逻辑是：</p>
<ol>
<li>检查 <code>state</code> 是否为 0（锁是否空闲）。</li>
<li>在判断锁空闲后，公平锁的实现会<strong>先调用 <code>hasQueuedPredecessors()</code> 方法检查等待队列中是否有其他线程在排队</strong>。</li>
</ol>
<p>- 如果队列为空，或者当前线程自己就是队列的头节点（即将被唤醒的下一个），那么它才有资格去用 CAS 竞争锁。<br>- <strong>如果发现队列中有其他线程在等待，那么当前线程会放弃竞争，直接将自己加入队列末尾进行等待</strong>，这就保证了“先来后到”的公平性。<br>- <strong>与非公平锁的区别</strong>：非公平锁（<code>ReentrantLock</code> 的默认方式）在尝试获取锁时，不管队列里有没有线程在等，都会直接去用 CAS 抢锁。抢失败了才入队。这提高了吞吐量但可能导致“插队”现象，造成线程饥饿。</p>
<h2 id="四、Java-虚拟机-JVM"><a href="#四、Java-虚拟机-JVM" class="headerlink" title="四、Java 虚拟机 (JVM)"></a><strong>四、Java 虚拟机 (JVM)</strong></h2><h4 id="1-JVM-内存区域与分配"><a href="#1-JVM-内存区域与分配" class="headerlink" title="1. JVM 内存区域与分配"></a><strong>1. JVM 内存区域与分配</strong></h4><p><strong>面试官：</strong> 说一下 JVM 的内存区域是如何划分的。</p>
<p><strong>我：</strong><br>好的。JVM 内存区域主要分为线程共享区和线程私有区。</p>
<hr>
<p><strong>面试官：</strong> 线程共享区包含哪些？各自的作用是什么？</p>
<p><strong>我：</strong></p>
<ol>
<li><strong>线程共享区</strong>：<ul>
<li><strong>堆 (Heap)</strong>：<ul>
<li><strong>作用</strong>：这是<strong>最大</strong>的一块内存区域，用于存放<strong>对象实例</strong>和<strong>数组</strong>。GC（垃圾回收）主要发生在这里。</li>
<li><strong>细分</strong>：从垃圾回收角度，可分为新生代 (Young Generation) 和老年代 (Old Generation)。新生代又分为 Eden 区和两个 Survivor区 (S0&#x2F;S1)。</li>
</ul>
</li>
<li><strong>方法区 (Method Area)</strong>：<ul>
<li><strong>作用</strong>：用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li>
<li><strong>实现</strong>：在 JDK8 之前，它的实现是“永久代”(PermGen)。在 JDK8 及之后，改为了<strong>元空间 (Metaspace)</strong>，并使用本地内存 (Native Memory) 来实现，大大降低了OOM的风险。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 那线程私有区呢？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>线程私有区</strong>：</li>
</ol>
<p>- <strong>虚拟机栈 (VM Stack)</strong>：<br>- <strong>作用</strong>：描述的是 Java <strong>方法执行的内存模型</strong>。每个方法在执行时都会创建一个<strong>栈帧</strong>，用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。我们常说的“栈内存”就是指这里。<br>- <strong>异常</strong>：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 <code>StackOverflowError</code>；如果栈可以动态扩展但无法申请到足够内存，则抛出 <code>OutOfMemoryError</code>。<br>- <strong>本地方法栈 (Native Method Stack)</strong>：<br>- <strong>作用</strong>：与虚拟机栈非常相似，区别在于它为虚拟机使用的 <strong>Native 方法</strong>服务。<br>- <strong>程序计数器 (Program Counter Register)</strong>：<br>- <strong>作用</strong>：一块较小的内存空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p>
<hr>
<p><strong>面试官：</strong> 你刚才还提到了直接内存，它属于 JVM 内存区域吗？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>直接内存 (Direct Memory)</strong>：</li>
</ol>
<p>- <strong>不属于</strong> JVM 运行时数据区，也不是 JVM 规范中定义的内存区域。<br>- <strong>作用</strong>：它是由 <code>NIO</code> 的 <code>DirectByteBuffer</code> 引用的内存区域，通常<strong>直接在物理内存上分配</strong>，避免了在 Java 堆和 Native 堆之间来回复制数据，从而能显著提高性能。<br>- <strong>影响</strong>：虽然不受 JVM 内存管理，但其大小也会受到本机总内存的限制。如果各个内存区域的总和大于物理内存限制，动态扩展时可能导致 <code>OutOfMemoryError</code>。</p>
<h3 id="2-垃圾回收算法与收集器"><a href="#2-垃圾回收算法与收集器" class="headerlink" title="2. 垃圾回收算法与收集器"></a><strong>2. 垃圾回收算法与收集器</strong></h3><p><strong>面试官：</strong> 讲一下 JVM 如何确定一个对象是垃圾？以及有哪些垃圾回收算法。</p>
<p><strong>我：</strong><br>好的。垃圾回收主要分两步：首先确定对象是否存活（是垃圾），然后进行回收。</p>
<hr>
<p><strong>面试官：</strong> 先说下如何确定垃圾。</p>
<p><strong>我：</strong></p>
<ol>
<li><strong>确定垃圾的算法</strong>：<ul>
<li><strong>引用计数法</strong>：<ul>
<li><strong>原理</strong>：给对象中添加一个<strong>引用计数器</strong>，每当有一个地方引用它，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为0的对象就是不可能再被使用的。</li>
<li><strong>缺点</strong>：它<strong>无法解决对象之间循环引用</strong>的问题（即A引用B，B也引用A，但再无第三方引用它们俩），从而导致内存泄漏。因此，<strong>主流的 Java 虚拟机都没有选用引用计数法</strong>。</li>
</ul>
</li>
<li><strong>可达性分析算法</strong>：<ul>
<li><strong>原理</strong>：这是 JVM 采用的算法。通过一系列称为 <strong>“GC Roots”</strong> 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。如果某个对象到 GC Roots 间<strong>没有任何引用链相连</strong>（即从 GC Roots 到这个对象不可达），则证明此对象是不可能再被使用的。</li>
<li><strong>哪些对象可以作为 GC Roots</strong>：<ol>
<li>虚拟机栈（栈帧中的局部变量表）中引用的对象。</li>
<li>本地方法栈中 JNI（即 Native 方法）引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>Java 虚拟机内部的引用（如基本类型对应的 Class 对象，常驻的异常对象等）。</li>
<li>被同步锁（synchronized）持有的对象。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 确定了垃圾之后，有哪些回收算法？</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>回收垃圾的算法</strong>：</li>
</ol>
<p>- <strong>标记-清除算法</strong>：<br>- <strong>过程</strong>：分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。<br>- <strong>缺点</strong>：<strong>效率不高</strong>，且会产生大量<strong>不连续的内存碎片</strong>，导致以后需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次 GC。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> <span class="hljs-strong">**复制算法**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**过程**</span>：将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象<span class="hljs-strong">**复制**</span>到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**优点**</span>：实现简单，运行高效，且没有内存碎片。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**缺点**</span>：<span class="hljs-strong">**内存代价太高**</span>，可用内存缩小为了原来的一半。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**应用**</span>：是<span class="hljs-strong">**新生代**</span>垃圾回收的主要算法。商业虚拟机都采用这种算法来回收新生代，但并不是按1:1的比例划分，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**标记-整理算法**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**过程**</span>：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**优点**</span>：避免了内存碎片，也避免了复制算法的空间浪费。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**缺点**</span>：移动存活对象并更新所有引用地址是一项负重操作，需要暂停用户线程（Stop The World）。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**应用**</span>：主要用于<span class="hljs-strong">**老年代**</span>的垃圾回收。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**分代收集算法**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**本质**</span>：这不是一种具体的算法，而是一种<span class="hljs-strong">**理论**</span>。当前商业虚拟机的垃圾收集器都采用它。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**思想**</span>：根据对象存活周期的不同，将 Java 堆划分为<span class="hljs-strong">**新生代**</span>和<span class="hljs-strong">**老年代**</span>，然后根据各个年代的特点采用最适当的收集算法。<br><span class="hljs-bullet">        -</span> 在<span class="hljs-strong">**新生代**</span>中，每次垃圾收集时都有大批对象死去，只有少量存活，那就选用<span class="hljs-strong">**复制算法**</span>，只需要付出少量存活对象的复制成本就可以完成收集。<br><span class="hljs-bullet">        -</span> 在<span class="hljs-strong">**老年代**</span>中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<span class="hljs-strong">**标记-清除**</span>或<span class="hljs-strong">**标记-整理**</span>算法来进行回收。<br></code></pre></td></tr></table></figure>

<h3 id="3-性能调优、OOM与内存泄漏"><a href="#3-性能调优、OOM与内存泄漏" class="headerlink" title="3. 性能调优、OOM与内存泄漏"></a><strong>3. 性能调优、OOM与内存泄漏</strong></h3><p><strong>面试官：</strong> 谈谈JVM调优的目标和常用参数。</p>
<p><strong>我：</strong><br>好的。JVM调优的核心目标是在<strong>吞吐量</strong>、<strong>延迟</strong>和<strong>内存占用</strong>三者间找到最佳平衡。</p>
<ol>
<li><strong>JVM调优目标</strong>：<ul>
<li><strong>低延迟</strong>：减少 <strong>GC停顿时间</strong>（Stop-The-World），提高应用响应速度，适合Web等交互式应用。</li>
<li><strong>高吞吐量</strong>：减少GC总耗时，增大<strong>应用运行时间</strong>占比，适合后台计算型任务。</li>
<li><strong>减少内存占用</strong>：在满足需求的前提下，控制堆内存大小。</li>
</ul>
</li>
<li><strong>常用参数</strong>：<ul>
<li><strong>-Xms 和 -Xmx</strong>：设置堆的初始大小(<code>-Xms</code>)和最大大小(<code>-Xmx</code>)，通常设为相同值以避免扩容带来的性能抖动。</li>
<li><strong>-Xmn</strong>：设置新生代大小。整个JVM堆大小 &#x3D; 新生代 + 老年代。</li>
<li><strong>-XX:SurvivorRatio</strong>：设置Eden区与一个Survivor区的比例（默认为8，即Eden:S0:S1&#x3D;8:1:1）。</li>
<li><strong>-XX:+UseG1GC</strong>：指定使用G1垃圾收集器。</li>
<li><strong>-XX:+PrintGC &#x2F; -XX:+PrintGCDetails</strong>：打印GC日志，用于排查。</li>
<li><strong>-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize</strong>：设置元空间初始大小和最大大小。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试官：</strong> 什么是逃逸分析？栈上分配又是什么？</p>
<p><strong>我：</strong></p>
<ul>
<li><strong>逃逸分析</strong>：是JIT编译器的一种高级优化技术。它通过分析对象的<strong>作用域</strong>，判断一个对象是否会被外部方法或外部线程所引用。<ul>
<li><strong>方法逃逸</strong>：对象被作为参数传递给其他方法。</li>
<li><strong>线程逃逸</strong>：对象被赋值给其他线程可访问的实例变量。</li>
</ul>
</li>
<li><strong>栈上分配</strong>：<ul>
<li>如果逃逸分析证明一个对象<strong>不会逃逸出方法</strong>，那么这个对象就可以在<strong>栈上分配内存</strong>，而不是在堆上。</li>
<li><strong>好处</strong>：对象随方法栈帧出栈而自动销毁，<strong>无需垃圾回收器介入</strong>，极大减轻了GC压力，提升了性能。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>面试官：</strong> 常见的OutOfMemoryError有哪些？如何排查？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>OutOfMemoryError避免与排查</strong>：</li>
</ol>
<p>OOM错误有多种类型，每种原因不同：<br>- <strong>Java heap space</strong>：<strong>堆内存溢出</strong>。最常见，原因是对象太多或存在内存泄漏，堆空间不足。<br>- <strong>排查</strong>：使用<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数在OOM时自动生成堆转储文件，然后用<strong>MAT、JProfiler</strong>等工具分析，找到是哪些对象占用了大量内存以及它们的GC Roots引用链。<br>- <strong>Metaspace &#x2F; PermGen space</strong>：<strong>元空间（方法区）溢出</strong>。原因是加载的类过多，如大量动态代理、反射。<br>- <strong>GC overhead limit exceeded</strong>：GC overhead limit exceeded：GC回收效率过低导致的溢出。默认如果超过98%的时间都在做GC并且回收不到2%的堆空间，就会抛出此错误。本质是堆内存太小或内存泄漏。<br>- <strong>Unable to create new native thread</strong>：<strong>无法创建本地线程</strong>。原因是创建的线程数超过系统限制（如Linux的<code>ulimit</code>）或内存不足。</p>
<hr>
<p><strong>面试官：</strong> 什么是内存泄漏？举几个常见例子。</p>
<p><strong>我：</strong></p>
<ol start="4">
<li><strong>内存泄漏概念与常见案例</strong>：</li>
</ol>
<p>- <strong>概念</strong>：指程序中已<strong>动态分配的堆内存</strong>由于某种原因<strong>未能被释放</strong>或<strong>无法被释放</strong>，造成系统内存的浪费，最终可能导致OOM。<br>- <strong>它与内存溢出的关系</strong>：<strong>内存泄漏是原因，内存溢出是结果</strong>。持续的泄漏最终会导致溢出。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**常见案例**</span>：<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**缓存泄漏**</span>：使用了无大小限制的缓存（如<span class="hljs-code">`HashMap`</span>作为缓存），对象只放入不取出。应使用<span class="hljs-code">`WeakHashMap`</span>或类似Guava Cache的、具有LRU淘汰机制的缓存。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**监听器未移除**</span>：向全局集合（如一个静态List）注册了监听器，但在对象不用后没有取消注册，导致集合一直持有对象的引用，无法被回收。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**数据库连接、文件流未关闭**</span>：这些资源不仅占用内存，还占用系统句柄。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**内部类持有外部类引用**</span>：非静态内部类会隐式持有外部类的引用。如果这个内部类的实例被一个长生命周期对象引用，就会导致外部类也无法被回收。<br></code></pre></td></tr></table></figure>



<h2 id="五、Java-多线程-Java-Multithreading"><a href="#五、Java-多线程-Java-Multithreading" class="headerlink" title="五、Java 多线程 (Java Multithreading)"></a><strong>五、Java 多线程 (Java Multithreading)</strong></h2><h4 id="1-线程池核心原理与参数配置"><a href="#1-线程池核心原理与参数配置" class="headerlink" title="1. 线程池核心原理与参数配置"></a><strong>1. 线程池核心原理与参数配置</strong></h4><p><strong>面试官：</strong> 说一下线程池的7个核心参数。</p>
<p><strong>我：</strong><br>好的。通过 <code>ThreadPoolExecutor</code> 的构造函数，可以看到7个核心参数：</p>
<ol>
<li><strong><code>corePoolSize</code></strong>：<strong>核心线程数</strong>。线程池维护的最小线程数量，即使它们处于空闲状态，也不会被回收（除非设置了 <code>allowCoreThreadTimeOut</code>）。</li>
<li><strong><code>maximumPoolSize</code></strong>：<strong>最大线程数</strong>。线程池允许创建的最大线程数量。</li>
<li><strong><code>keepAliveTime</code></strong>：<strong>空闲线程存活时间</strong>。当线程数超过 <code>corePoolSize</code> 时，多余的空闲线程在终止前等待新任务的最长时间。</li>
<li><strong><code>unit</code></strong>：<code>keepAliveTime</code> 参数的<strong>时间单位</strong>。</li>
<li><strong><code>workQueue</code></strong>：<strong>任务队列</strong>。用于保存等待执行的任务的阻塞队列（如 <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>）。</li>
<li><strong><code>threadFactory</code></strong>：<strong>线程工厂</strong>。用于创建新线程，可以设置线程名、优先级等，便于排查问题。</li>
<li><strong><code>handler</code></strong>：<strong>拒绝策略</strong>。当线程池和队列都已满时，用于处理新提交任务的策略（如抛出异常、直接丢弃等）。</li>
</ol>
<hr>
<p><strong>面试官：</strong> 描述一下任务提交到线程池后的执行流程。</p>
<p><strong>我：</strong></p>
<ol start="2">
<li><strong>任务提交流程</strong>：</li>
</ol>
<p>当一个新任务被提交 (<code>execute()</code>) 时，流程如下：</p>
<ol>
<li>首先，判断当前运行的线程数是否小于 <code>corePoolSize</code>。如果是，则<strong>创建新的核心线程</strong>来执行该任务（即使有其他空闲线程）。</li>
<li>如果当前线程数已达到 <code>corePoolSize</code>，则尝试将任务<strong>放入工作队列</strong> (<code>workQueue</code>) 等待。</li>
<li>如果队列<strong>已满</strong>，则判断当前线程数是否小于 <code>maximumPoolSize</code>。如果是，则<strong>创建新的非核心线程</strong>来执行该任务。</li>
<li>如果线程数也已达到 <code>maximumPoolSize</code>，并且队列已满，则触发<strong>拒绝策略</strong> (<code>handler</code>)。</li>
</ol>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">**简单记法**：**先核心 -&gt; 再入队 -&gt; 后扩容 -&gt; 最后拒绝**。<br></code></pre></td></tr></table></figure>

<hr>
<p><strong>面试官：</strong> 在实际项目中，如何设置核心线程数？</p>
<p><strong>我：</strong></p>
<ol start="3">
<li><strong>核心参数计算</strong>：</li>
</ol>
<p>这是一个经验值，需要根据任务类型是 <strong>CPU密集型</strong> 还是 <strong>IO密集型</strong> 来调整。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> <span class="hljs-strong">**CPU密集型**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**特点**</span>：任务主要消耗CPU资源，需要进行大量计算（例如，计算圆周率、视频编码）。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**设置**</span>：线程数不宜过多，通常设置为 <span class="hljs-strong">**`CPU核心数 + 1`**</span>。设置过多会导致大量的线程上下文切换，反而降低性能。<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**IO密集型**</span>：<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**特点**</span>：任务大部分时间在等待IO操作（如数据库查询、网络请求、文件读写），CPU空闲。<br><span class="hljs-bullet">    -</span> <span class="hljs-strong">**设置**</span>：线程数可以设置得多一些，以充分利用CPU资源。通常可以设置为 <span class="hljs-strong">**`2 * CPU核心数`**</span>，或者更高。更精确的估算公式是：<span class="hljs-strong">**`线程数 = CPU核心数 * (1 + 平均等待时间 / 平均计算时间)`**</span>。<br><br><span class="hljs-strong">**注意**</span>：这只是一个理论上的起始值，<span class="hljs-strong">**实际生产中需要通过压测来找到最适合自己应用的参数**</span>。<br></code></pre></td></tr></table></figure>



<h2 id="六、数据库-Database"><a href="#六、数据库-Database" class="headerlink" title="六、数据库 (Database)"></a><strong>六、数据库 (Database)</strong></h2><h3 id="1-MySQL"><a href="#1-MySQL" class="headerlink" title="1. MySQL"></a><strong>1. MySQL</strong></h3><p><strong>1.1 事务与 ACID 属性</strong></p>
<p><strong>面试官：</strong> 你先说说 MySQL 的事务和它的 ACID 属性吧。</p>
<p><strong>我：</strong></p>
<p>好的。事务是数据库操作的基本单元，它是一个不可分割的工作序列，要么全部执行成功，要么全部执行失败，能保证数据的一致性和完整性。</p>
<p>事务的 ACID 属性是其核心特性，具体指：</p>
<ul>
<li><p><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不完成，不会存在部分执行的情况。比如转账时，“从 A 账户扣钱” 和 “给 B 账户加钱” 这两个操作要么都成功，要么都失败，不会出现 A 扣了钱但 B 没收到的情况。</p>
</li>
<li><p><strong>一致性（Consistency）</strong>：事务执行前后，数据库的完整性约束不会被破坏。例如，假设表中有 “总金额 &#x3D; A 账户金额 + B 账户金额” 的约束，转账事务执行后，这个等式依然成立。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应被其他事务干扰，每个事务都像在独立执行一样。避免因并发操作导致的数据不一致问题。</p>
</li>
<li><p><strong>持久性（Durability）</strong>：一旦事务提交成功，它对数据库中数据的修改就是永久性的，即使之后发生数据库崩溃等故障，修改的数据也不会丢失。</p>
</li>
</ul>
<p><strong>1.2 事务隔离级别与 MVCC 机制</strong></p>
<p><strong>面试官：</strong> 那事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？MVCC 机制你了解吗？</p>
<p><strong>我：</strong></p>
<p>事务隔离级别是为了应对并发事务可能出现的问题（如脏读、不可重复读、幻读）而设定的，主要有 4 种：</p>
<ul>
<li><p><strong>读未提交（Read Uncommitted）</strong>：最低的隔离级别。一个事务可以读取到另一个未提交事务修改的数据，可能导致脏读（读取到未提交的无效数据）。</p>
</li>
<li><p><strong>读已提交（Read Committed）</strong>：一个事务只能读取到另一个已提交事务修改的数据，解决了脏读问题，但可能出现不可重复读（同一事务中多次读取同一数据，结果因其他事务提交的修改而不同）。</p>
</li>
<li><p><strong>可重复读（Repeatable Read）</strong>：MySQL 的默认隔离级别。保证同一事务中多次读取同一数据时，结果一致，解决了不可重复读问题，但在默认情况下可能出现幻读（同一事务中，按同一条件多次查询，结果集行数因其他事务的插入 &#x2F; 删除而变化）。</p>
</li>
<li><p><strong>串行化（Serializable）</strong>：最高的隔离级别。事务串行执行，完全避免了并发问题，但性能极低，通常只在数据一致性要求极高且并发量低的场景使用。</p>
</li>
</ul>
<p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是 MySQL 实现读已提交和可重复读隔离级别的核心机制，它通过为数据保存多个版本，让读写操作不相互阻塞，提升并发性能。其实现原理主要涉及<strong>版本链</strong>和<strong>ReadView</strong>：</p>
<ul>
<li><p><strong>版本链</strong>：每行数据在被修改时，会生成一个新的版本，旧版本不会被立即删除，而是保留下来并通过隐藏列（如DB_TRX_ID记录修改事务 ID、DB_ROLL_PTR指向旧版本数据）形成链表，即版本链。</p>
</li>
<li><p><strong>ReadView</strong>：事务在进行快照读（普通 SELECT 操作）时，会生成一个 ReadView，它包含当前活跃事务的 ID 列表等信息。通过比较数据版本的DB_TRX_ID与 ReadView 中的信息，来判断该版本数据是否可见：若数据版本的事务 ID 不在活跃列表中且小于 ReadView 中的最大事务 ID 等（不同隔离级别下判断逻辑有差异），则数据可见。</p>
</li>
</ul>
<p>读已提交隔离级别下，每次执行 SELECT 都会生成一个新的 ReadView，所以能看到其他事务已提交的修改；可重复读隔离级别下，仅在第一次 SELECT 时生成 ReadView，之后复用该 ReadView，因此能保证同一事务中多次读取结果一致。</p>
<p><strong>面试官：</strong> 那可重复读级别下是怎么解决幻读的呢？</p>
<p><strong>我：</strong></p>
<p>MySQL 的可重复读级别通过 “MVCC 快照读 + Next-Key Lock 当前读” 的组合来解决幻读问题：</p>
<ul>
<li><p><strong>MVCC 快照读</strong>：对于普通的 SELECT 查询（快照读），由于复用第一次生成的 ReadView，即使其他事务插入了新数据，新数据的事务 ID 在当前 ReadView 中可能被判定为不可见，因此不会读取到新插入的数据，避免了快照读场景下的幻读。</p>
</li>
<li><p><strong>Next-Key Lock 当前读</strong>：对于加锁的查询（如SELECT … FOR UPDATE、UPDATE、DELETE等当前读操作），MySQL 会使用 Next-Key Lock。它是行锁和间隙锁的组合，不仅会锁定符合条件的行，还会锁定这些行所在间隙（即不存在的、可能被插入数据的区间），防止其他事务在间隙中插入新数据，从而避免了当前读场景下的幻读。</p>
</li>
</ul>
<p><strong>1.3 锁机制：间隙锁与临键锁</strong></p>
<p><strong>面试官：</strong> 聊完隔离级别，再说说 MySQL 的锁机制吧，特别是间隙锁和临键锁。</p>
<p><strong>我：</strong></p>
<p>MySQL 的锁机制按粒度可分为表锁、行锁等，行锁是并发控制的关键，而间隙锁和临键锁是行锁的扩展：</p>
<ul>
<li><p><strong>间隙锁（Gap Lock）</strong>：锁定的是一个区间，而不是具体的行。当事务对某条记录加锁时，若该记录所在索引区间存在未使用的间隙，会对这些间隙加锁。例如，表中有 id 为 1、3、5 的记录，对 id&#x3D;3 的记录加锁时，可能会锁定 (1,3)、(3,5) 这样的间隙，防止其他事务在这些间隙中插入 id&#x3D;2、4 的记录，主要用于解决幻读。</p>
</li>
<li><p><strong>临键锁（Next-Key Lock）</strong>：是行锁和间隙锁的结合，锁定的是 “记录 + 间隙”。它会锁定当前记录以及该记录前面的间隙。比如上述 id&#x3D;3 的例子，临键锁会锁定 (1,3] 这个区间（包含 3 这条记录和 1 到 3 之间的间隙）。在可重复读隔离级别下，MySQL 默认使用临键锁进行当前读操作，当查询条件是唯一索引且精确匹配时，临键锁会降级为行锁。</p>
</li>
</ul>
<p><strong>1.4 索引与优化：回表查询与覆盖索引</strong></p>
<p><strong>面试官：</strong> 索引相关的，回表查询和覆盖索引你清楚吗？</p>
<p><strong>我：</strong></p>
<p>这两个概念和索引的结构密切相关，MySQL 中最常用的索引是 B + 树索引：</p>
<ul>
<li><p><strong>回表查询</strong>：B + 树索引分为聚簇索引和非聚簇索引（二级索引）。聚簇索引的叶子节点存储的是完整的行数据，而非聚簇索引的叶子节点存储的是行数据的主键值。当使用非聚簇索引查询数据时，若查询的字段不在非聚簇索引中，需要先通过非聚簇索引找到主键值，再到聚簇索引中根据主键值查找完整的行数据，这个过程就叫回表查询。回表会增加 IO 操作，影响查询效率。</p>
</li>
<li><p><strong>覆盖索引</strong>：若查询的所有字段都包含在非聚簇索引中（即非聚簇索引的叶子节点已包含查询所需的全部数据），则不需要回表，直接通过非聚簇索引就能获取到数据，这种索引就是覆盖索引。例如，表有索引idx_name(name)，执行SELECT name, age FROM table WHERE name&#x3D;’xxx’，若age也在idx_name索引中（如联合索引idx_name_age(name, age)），则该索引就是覆盖索引，能避免回表，提升查询效率。</p>
</li>
</ul>
<p><strong>1.5 性能分析：EXPLAIN 与索引失效</strong></p>
<p><strong>面试官：</strong> 那怎么分析 SQL 性能？索引为什么会失效呢？</p>
<p><strong>我：</strong></p>
<p>分析 MySQL SQL 性能最常用的工具是EXPLAIN命令，在 SQL 语句前加上EXPLAIN，执行后会得到查询计划，通过查看各列（如type、key、rows、extra等）的信息，能判断索引是否被使用、查询效率如何：</p>
<ul>
<li><p>type：表示访问类型，从好到差有system、const、eq_ref、ref、range、index、ALL等，range及以上通常表示使用了索引，ALL是全表扫描，效率低。</p>
</li>
<li><p>key：显示实际使用的索引，若为NULL则未使用索引。</p>
</li>
<li><p>rows：预估需要扫描的行数，行数越少越好。</p>
</li>
<li><p>extra：包含额外信息，如Using index表示使用了覆盖索引，Using filesort表示需要额外排序（效率低），Using temporary表示使用了临时表（效率低）等。</p>
</li>
</ul>
<p>索引失效的原因有很多，常见的有：</p>
<ul>
<li><p>索引列上使用了函数或表达式，如WHERE SUBSTR(name, 1, 1)&#x3D;’a’，会导致索引无法被使用。</p>
</li>
<li><p>索引列进行了隐式类型转换，如索引列是varchar类型，查询时用WHERE id&#x3D;123（123 是数字），MySQL 会进行类型转换，导致索引失效。</p>
</li>
<li><p>使用NOT IN、!&#x3D;、&lt;&gt;等否定操作符，可能导致索引失效（视情况而定，部分场景下可能使用索引）。</p>
</li>
<li><p>LIKE查询以%开头，如WHERE name LIKE ‘%abc’，无法使用索引的前缀匹配，导致索引失效。</p>
</li>
<li><p>联合索引未遵循 “最左前缀原则”，即查询条件不包含联合索引的第一个列，如联合索引(a,b,c)，查询WHERE b&#x3D;1 AND c&#x3D;2，会导致索引失效。</p>
</li>
<li><p>表中数据量极少，MySQL 认为全表扫描比使用索引更高效，会放弃使用索引。</p>
</li>
</ul>
<p><strong>1.6 日志系统：三大日志解析（undo log、redo log、binlog）</strong></p>
<p><strong>面试官：</strong> 最后说说 MySQL 的三大日志吧，undo log、redo log、binlog。</p>
<p><strong>我：</strong></p>
<p>MySQL 的三大日志在数据一致性、事务恢复、主从复制等方面起着关键作用：</p>
<ul>
<li><p><strong>undo log（回滚日志）</strong>：</p>
</li>
<li><p><strong>作用</strong>：用于事务回滚和 MVCC。当事务修改数据时，会先将数据的旧版本记录到 undo log 中。若事务需要回滚（如执行ROLLBACK），可以通过 undo log 恢复数据到修改前的状态；同时，undo log 也是 MVCC 中版本链的重要组成部分，供快照读时获取旧版本数据。</p>
</li>
<li><p><strong>特点</strong>：是逻辑日志，记录的是 “做了什么操作可以恢复数据”，且会随着事务的提交或回滚被清理。</p>
</li>
<li><p><strong>redo log（重做日志）</strong>：</p>
</li>
<li><p><strong>作用</strong>：保证事务的持久性。事务执行过程中，对数据的修改会先写入内存的缓冲池，同时将修改操作记录到 redo log（先写 redo log buffer，再刷到磁盘）。若数据库发生崩溃，重启后可以通过 redo log 重新执行已提交的事务操作，恢复数据，避免因内存数据丢失导致的数据不一致。</p>
</li>
<li><p><strong>特点</strong>：是物理日志，记录的是 “某个数据页做了什么修改”，采用循环写的方式，有固定大小。</p>
</li>
<li><p><strong>binlog（二进制日志）</strong>：</p>
</li>
<li><p><strong>作用</strong>：用于主从复制和数据备份恢复。它记录了所有对数据库的修改操作（如INSERT、UPDATE、DELETE等），不记录查询操作。主库将 binlog 发送给从库，从库通过执行 binlog 中的操作实现主从数据同步；同时，若数据库发生故障，可通过 binlog 结合备份恢复到指定时间点的数据。</p>
</li>
<li><p><strong>特点</strong>：是逻辑日志，记录的是操作的逻辑（如 “插入一条 id&#x3D;1 的记录”），采用追加写的方式，不会覆盖旧日志，可通过expire_logs_days等参数设置自动清理策略。</p>
</li>
</ul>
<p>三者的配合：事务执行时，先写 undo log，再修改缓冲池数据，同时写 redo log（prepare 阶段），事务提交时，写 binlog，最后将 redo log 标记为提交（commit 阶段），确保数据的一致性和持久性。</p>
<h3 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2. Redis"></a><strong>2. Redis</strong></h3><p><strong>2.1 核心数据类型与应用场景（String, Hash, List, Set, ZSet 等）</strong></p>
<p><strong>面试官：</strong> 说说 Redis 的核心数据类型有哪些，各自的应用场景是什么？</p>
<p><strong>我：</strong></p>
<p>Redis 的核心数据类型是其基础，常见的有 String、Hash、List、Set、ZSet 这五种，每种都有独特的结构和适用场景：</p>
<ul>
<li><p><strong>String（字符串）</strong>：</p>
</li>
<li><p><strong>结构</strong>：最基础的数据类型，底层可存储字符串、整数或浮点数，最大能存储 512MB。</p>
</li>
<li><p><strong>应用场景</strong>：缓存简单数据（如用户信息 JSON 串）、计数器（用INCR&#x2F;DECR实现点赞数、访问量统计）、分布式锁（通过SETNX命令）、Session 共享等。</p>
</li>
<li><p><strong>Hash（哈希）</strong>：</p>
</li>
<li><p><strong>结构</strong>：键值对的集合，类似 Java 中的 HashMap，适合存储对象类数据，每个 Hash 可包含最多 2^32-1 个字段。</p>
</li>
<li><p><strong>应用场景</strong>：存储用户信息（如user:100为 key，name“age” 等为字段）、商品属性存储等，能只修改对象的某个字段，节省内存和带宽。</p>
</li>
<li><p><strong>List（列表）</strong>：</p>
</li>
<li><p><strong>结构</strong>：有序的字符串列表，底层是双向链表，支持从两端插入 &#x2F; 删除元素，按索引访问。</p>
</li>
<li><p><strong>应用场景</strong>：消息队列（用LPUSH生产消息、RPOP消费消息）、最新消息展示（如朋友圈点赞列表）、排行榜前 N 条数据等。</p>
</li>
<li><p><strong>Set（集合）</strong>：</p>
</li>
<li><p><strong>结构</strong>：无序且不重复的字符串集合，支持交集、并集、差集等运算。</p>
</li>
<li><p><strong>应用场景</strong>：好友关系（如共同好友用交集SINTER）、标签存储（如用户兴趣标签）、去重操作（如 UV 统计）等。</p>
</li>
<li><p><strong>ZSet（有序集合）</strong>：</p>
</li>
<li><p><strong>结构</strong>：在 Set 基础上给每个元素关联一个分数（score），按分数排序，元素唯一但分数可重复。</p>
</li>
<li><p><strong>应用场景</strong>：排行榜（如游戏积分排名用ZREVRANGE）、带权重的消息队列、范围查询（如查询分数在 80-100 的用户）等。</p>
</li>
</ul>
<p><strong>2.2 缓存问题：穿透、击穿、雪崩及解决方案</strong></p>
<p><strong>面试官：</strong> Redis 作为缓存时，常见的缓存穿透、击穿、雪崩问题怎么解决？</p>
<p><strong>我：</strong></p>
<p>这三类问题都是缓存使用中可能遇到的并发或数据一致性问题，具体及解决方案如下：</p>
<ul>
<li><p><strong>缓存穿透</strong>：</p>
</li>
<li><p><strong>问题</strong>：查询不存在的数据（如用户查 id&#x3D;-1 的用户），缓存和数据库都无结果，请求直接打向数据库，大量此类请求会压垮数据库。</p>
</li>
<li><p><strong>解决方案</strong>：① 空值缓存，对不存在的 key 缓存空值（设较短过期时间，避免占用内存）；② 布隆过滤器，在缓存前加布隆过滤器，先判断 key 是否存在，不存在直接返回，过滤无效请求；③ 接口层校验，对非法参数（如 id 为负）直接拦截。</p>
</li>
<li><p><strong>缓存击穿</strong>：</p>
</li>
<li><p><strong>问题</strong>：一个热点 key 突然过期，此时大量并发请求同时访问该 key，缓存未命中，都去查数据库，导致数据库瞬间压力骤增。</p>
</li>
<li><p><strong>解决方案</strong>：① 热点 key 永不过期，在业务层不设置过期时间，手动更新；② 互斥锁，缓存未命中时，用分布式锁（如 Redis 的SETNX）保证只有一个线程去查数据库，其他线程等待重试；③ 预热缓存，在高峰前主动加载热点数据到缓存并设合理过期时间。</p>
</li>
<li><p><strong>缓存雪崩</strong>：</p>
</li>
<li><p><strong>问题</strong>：大量缓存 key 在同一时间过期，或 Redis 集群宕机，导致大量请求穿透到数据库，数据库因压力过大崩溃。</p>
</li>
<li><p><strong>解决方案</strong>：① 过期时间随机化，给 key 的过期时间加随机值（如 10±2 秒），避免同时过期；② 多级缓存，用本地缓存（如 Caffeine）+ Redis 缓存，减少 Redis 压力；③ Redis 集群高可用，部署主从 + 哨兵或 Redis Cluster，避免单点故障；④ 限流降级，在数据库前加限流组件（如 Sentinel），超过阈值则降级返回默认数据。</p>
</li>
</ul>
<p><strong>2.3 数据一致性问题与解决方案（Cache-Aside 策略、延迟双删、监听 binlog）</strong></p>
<p><strong>面试官：</strong> Redis 和数据库如何保证数据一致性？有哪些常用方案？</p>
<p><strong>我：</strong></p>
<p>缓存与数据库的数据一致性指两者数据保持同步，常用方案需根据业务场景选择：</p>
<ul>
<li><p><strong>Cache-Aside 策略（旁路缓存）</strong>：</p>
</li>
<li><p><strong>流程</strong>：读操作时，先查缓存，命中直接返回；未命中查数据库，再把数据写入缓存。写操作时，先更数据库，再删除缓存（而非更新缓存，避免多次写缓存浪费资源）。</p>
</li>
<li><p><strong>适用场景</strong>：大多数普通业务场景，简单易实现，但可能因删除缓存失败导致不一致（可配合重试机制）。</p>
</li>
<li><p><strong>延迟双删</strong>：</p>
</li>
<li><p><strong>流程</strong>：写操作时，① 先删除缓存；② 再更新数据库；③ 过一段时间（如 500ms）再次删除缓存。</p>
</li>
<li><p><strong>作用</strong>：解决 “更新数据库时，其他线程可能已从旧数据库读数据写入缓存” 的问题，第二次删除可清除可能的旧缓存。</p>
</li>
<li><p><strong>适用场景</strong>：并发较高，对一致性要求稍高的场景，需合理设置延迟时间（根据业务耗时调整）。</p>
</li>
<li><p><strong>监听 binlog 同步</strong>：</p>
</li>
<li><p><strong>流程</strong>：借助数据库的 binlog（如 MySQL 的 binlog），通过中间件（如 Canal）监听 binlog 变化，解析后异步更新或删除 Redis 缓存。</p>
</li>
<li><p><strong>优势</strong>：解耦业务代码，可靠性高，适合复杂的更新场景。</p>
</li>
<li><p><strong>注意</strong>：异步更新有延迟，需接受短暂的不一致，且需保证中间件的高可用。</p>
</li>
</ul>
<p><strong>2.4 高性能原理：I&#x2F;O 多路复用模型（Reactor 模式、epoll）</strong></p>
<p><strong>面试官：</strong> Redis 为什么性能高？I&#x2F;O 多路复用模型是怎么回事？</p>
<p><strong>我：</strong></p>
<p>Redis 高性能的原因包括基于内存、单线程（避免线程切换开销）等，其中 I&#x2F;O 多路复用模型是关键：</p>
<ul>
<li><p><strong>I&#x2F;O 多路复用</strong>：允许单个线程同时监听多个文件描述符（Socket），当某个描述符就绪（如可读、可写）时，通知应用程序处理。Redis 用它解决了单线程下处理多客户端连接的问题，避免了阻塞等待。</p>
</li>
<li><p><strong>Reactor 模式</strong>：Redis 的 I&#x2F;O 模型基于 Reactor 模式实现，核心是 “事件驱动”：① 主线程负责监听 Socket，将就绪的事件（如连接、读写）放入事件队列；② 工作线程（Redis 单线程下主线程即工作线程）从队列取事件并处理（如解析命令、执行操作）。</p>
</li>
<li><p><strong>epoll</strong>：Redis 在 Linux 下采用 epoll 作为 I&#x2F;O 多路复用的实现（不同系统有差异，如 FreeBSD 用 kqueue），相比 select&#x2F;poll 更高效：① select&#x2F;poll 需轮询所有描述符，epoll 通过回调通知就绪描述符，无轮询开销；② select 支持的描述符数量有限（默认 1024），epoll 无此限制；③ epoll 能精准获取就绪描述符，减少无效操作。</p>
</li>
</ul>
<p>正是 I&#x2F;O 多路复用让 Redis 单线程也能高效处理数万并发连接。</p>
<p><strong>2.5 实战应用：登录机制与防抖节流实现</strong></p>
<p><strong>面试官：</strong> Redis 在实战中有哪些典型应用？比如登录和防抖节流怎么用它实现？</p>
<p><strong>我：</strong></p>
<p>Redis 在业务中有很多实用场景，登录机制和防抖节流是常见案例：</p>
<ul>
<li><p><strong>登录机制实现</strong>：</p>
</li>
<li><p><strong>流程</strong>：用户登录成功后，生成唯一 token（如 UUID），以token:xxx为 key，用户信息为 value 存入 Redis（设过期时间，如 2 小时）；客户端后续请求携带 token，服务端查 Redis 验证 token 是否有效，有效则允许访问。</p>
</li>
<li><p><strong>扩展</strong>：可结合 Redis 的EXPIRE续期（如用户操作时刷新过期时间），或用DEL实现登出；还能通过SETNX防止同一账号多设备登录（登录时先删旧 token，再存新 token）。</p>
</li>
<li><p><strong>防抖节流实现</strong>：</p>
</li>
<li><p><strong>防抖（避免重复触发）</strong>：如按钮点击，用 Redis 记录触发时间，规定 “n 秒内再次触发则重置时间”。例：用SET key timestamp NX PX n*1000，若 key 不存在则设置（触发操作），存在则不处理。</p>
</li>
<li><p><strong>节流（控制触发频率）</strong>：如接口限流，规定 “n 秒内最多触发 m 次”。例：用INCR key计数，EXPIRE key n设过期时间，若计数≤m 则允许，否则拒绝。</p>
</li>
</ul>
<p><strong>2.6 高可用与持久化：主从同步与 AOF&#x2F;RDB</strong></p>
<p><strong>面试官：</strong> Redis 如何保证高可用？持久化机制 AOF 和 RDB 有什么区别？</p>
<p><strong>我：</strong></p>
<p>高可用涉及主从、持久化等，确保 Redis 不丢失数据且持续可用：</p>
<ul>
<li><p><strong>主从同步</strong>：</p>
</li>
<li><p><strong>作用</strong>：实现数据备份和读写分离。主库负责写操作，从库通过复制主库数据实现备份，同时可分担读请求。</p>
</li>
<li><p><strong>流程</strong>：① 从库连接主库，发送SYNC命令；② 主库生成 RDB 文件并发送给从库，从库加载 RDB 同步全量数据；③ 之后主库将写命令异步发送给从库，从库执行命令保持增量同步。</p>
</li>
<li><p><strong>高可用</strong>：配合哨兵（Sentinel），哨兵监控主从节点，主库故障时自动将从库切换为主库，实现故障转移。</p>
</li>
<li><p><strong>持久化机制</strong>：</p>
</li>
<li><p><strong>RDB</strong>：在指定时间间隔生成数据集的快照（如save 60 1000表示 60 秒内 1000 次修改则触发），将数据写入二进制文件（dump.rdb）。</p>
</li>
<li><p><strong>优势</strong>：文件小，恢复速度快；适合全量备份。</p>
</li>
<li><p><strong>劣势</strong>：快照间隔内数据可能丢失（如宕机）；生成快照时可能阻塞主线程（用bgsave可异步，但有资源开销）。</p>
</li>
<li><p><strong>AOF</strong>：记录所有写命令（如SET、HSET），追加到日志文件（appendonly.aof），恢复时重新执行命令。</p>
</li>
<li><p><strong>优势</strong>：数据安全性高（可设appendfsync always实时写入）；日志可读懂，便于排查问题。</p>
</li>
<li><p><strong>劣势</strong>：文件大，恢复慢；写命令追加可能影响性能。</p>
</li>
<li><p><strong>实际选择</strong>：通常混合使用 AOF+RDB，RDB 用于快速恢复，AOF 弥补 RDB 的数据丢失风险。</p>
</li>
</ul>
<p><strong>2.7 生产优化：大 Key 与热 Key 处理</strong></p>
<p><strong>面试官：</strong> 生产环境中，Redis 的大 Key 和热 Key 怎么处理？</p>
<p><strong>我：</strong></p>
<p>大 Key 和热 Key 会影响 Redis 性能（如大 Key 导致阻塞，热 Key 导致节点过载），需针对性优化：</p>
<ul>
<li><p><strong>大 Key 处理</strong>：</p>
</li>
<li><p><strong>识别</strong>：用redis-cli –bigkeys命令扫描大 Key（如 String&gt;100MB，Hash&#x2F;List 元素过多）。</p>
</li>
<li><p><strong>拆分</strong>：① String 大 Key 拆分为多个小 Key（如user:info拆为user:info:name、user:info:age）；② Hash&#x2F;List 大 Key 按范围拆分（如 Hash 按字段首字母拆分，List 按索引分段）。</p>
</li>
<li><p><strong>删除</strong>：大 Key 直接DEL会阻塞线程，用UNLINK（异步删除）或逐步删除（如 List 用LPOP分批删）。</p>
</li>
<li><p><strong>热 Key 处理</strong>：</p>
</li>
<li><p><strong>识别</strong>：通过监控工具（如 Redis Insight）统计访问频率高的 Key，或根据业务判断（如秒杀商品 ID）。</p>
</li>
<li><p><strong>分散存储</strong>：① 给热 Key 加前缀 &#x2F; 后缀（如key:1、key:2），分散到不同 Redis 节点；② 用本地缓存（如应用内存）分担部分请求，减少 Redis 访问。</p>
</li>
<li><p><strong>优化缓存</strong>：热 Key 设永不过期，或用主从复制（从库分担读请求），避免单节点压力过大。</p>
</li>
</ul>
<h2 id="七、开发框架-Development-Framework"><a href="#七、开发框架-Development-Framework" class="headerlink" title="七、开发框架 (Development Framework)"></a><strong>七、开发框架 (Development Framework)</strong></h2><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a><strong>SpringBoot</strong></h3><p> <strong>1. 核心思想：IoC (控制反转) 与 DI (依赖注入)</strong></p>
<p><strong>面试官：</strong> 请说说 SpringBoot 的核心思想 IoC 和 DI 分别是什么，它们之间有什么关系？</p>
<p><strong>我：</strong></p>
<p>IoC（Inversion of Control，控制反转）是 Spring 框架的核心思想，它颠覆了传统程序中对象创建和依赖管理的方式：传统方式中，对象由开发者主动通过new关键字创建，依赖关系也由开发者手动维护；而在 IoC 思想下，对象的创建权、生命周期管理以及依赖关系的组装都交给了 Spring 容器，开发者只需定义对象的需求，由容器 “反向” 将所需对象注入，实现了 “控制权从开发者到容器的转移”。</p>
<p>DI（Dependency Injection，依赖注入）是 IoC 的具体实现方式。当一个对象需要依赖另一个对象时，Spring 容器会主动将被依赖的对象 “注入” 到依赖对象中，无需开发者手动设置。比如在 Service 层中需要 Dao 层对象，只需用@Autowired注解标记，Spring 就会自动将 Dao 实例注入到 Service 中。</p>
<p>简单来说，IoC 是设计思想，DI 是实现该思想的手段，二者相辅相成，共同降低了组件间的耦合度，让代码更易维护和扩展。</p>
<p><strong>2. 进阶特性：循环依赖解决机制（三级缓存）</strong></p>
<p><strong>面试官：</strong> SpringBoot 是如何解决 Bean 之间的循环依赖问题的？三级缓存在这里起到了什么作用？</p>
<p><strong>我：</strong></p>
<p>循环依赖指的是两个或多个 Bean 之间互相依赖，比如 A 依赖 B，B 又依赖 A。Spring 通过三级缓存机制来解决单例 Bean 的循环依赖问题，核心是提前暴露未初始化完成的 Bean 实例。</p>
<p>三级缓存具体指 Spring 容器中的三个 Map 结构：</p>
<ul>
<li><p><strong>一级缓存（singletonObjects）</strong>：存储已完全初始化完成的单例 Bean，是最终供外部使用的 Bean 实例。</p>
</li>
<li><p><strong>二级缓存（earlySingletonObjects）</strong>：存储提前暴露的、已完成实例化但未完成属性注入和初始化的 Bean 实例（半成品 Bean）。</p>
</li>
<li><p><strong>三级缓存（singletonFactories）</strong>：存储 Bean 的工厂对象（ObjectFactory），该工厂可以生成 Bean 的早期代理对象或原始实例。</p>
</li>
</ul>
<p>解决循环依赖的流程以 A 和 B 循环依赖为例：</p>
<ol>
<li><p>容器创建 A 时，先实例化 A（完成构造方法调用），然后将 A 的工厂对象放入三级缓存。</p>
</li>
<li><p>A 需要注入 B，容器开始创建 B，同样先实例化 B，将 B 的工厂对象放入三级缓存。</p>
</li>
<li><p>B 需要注入 A，容器先查一级缓存（无 A），再查二级缓存（无 A），最后查三级缓存，通过 A 的工厂对象获取 A 的早期实例，将 A 从三级缓存移到二级缓存，然后将 A 注入到 B 中。</p>
</li>
<li><p>B 完成属性注入和初始化，成为完整 Bean，放入一级缓存，之后将 B 注入到 A 中。</p>
</li>
<li><p>A 完成属性注入和初始化，放入一级缓存，循环依赖解决。</p>
</li>
</ol>
<p>三级缓存的关键作用是应对 Bean 被 AOP 代理的场景：若 Bean 需要生成代理对象，工厂对象会提前生成代理实例并暴露，避免注入原始实例导致的代理失效问题，二级缓存则用于快速获取提前暴露的实例，减少工厂对象的重复执行。不过三级缓存仅能解决单例 Bean 的循环依赖，原型 Bean（prototype）的循环依赖无法解决，会直接抛出异常。</p>
<p><strong>3. 面向切面编程：AOP 实现原理（JDK 动态代理 vs CGLIB）</strong></p>
<p><strong>面试官：</strong> SpringBoot 的 AOP 是如何实现的？JDK 动态代理和 CGLIB 代理有什么区别，Spring 会如何选择？</p>
<p><strong>我：</strong></p>
<p>AOP（Aspect-Oriented Programming，面向切面编程）通过将日志、事务、权限控制等通用功能抽取为 “切面”，在不修改业务代码的情况下，通过 “织入” 机制将切面与业务逻辑结合，实现代码复用。Spring AOP 的底层通过动态代理技术实现，主要有 JDK 动态代理和 CGLIB 代理两种方式。</p>
<p>二者的区别主要体现在实现方式和适用场景上：</p>
<ul>
<li><p><strong>JDK 动态代理</strong>：</p>
</li>
<li><p>基于 Java 反射机制实现，要求被代理的类必须实现接口，代理对象是接口的实现类。</p>
</li>
<li><p>原理是通过Proxy类生成代理实例，代理实例在调用方法时，会回调InvocationHandler中的invoke方法，在该方法中执行切面逻辑和目标方法。</p>
</li>
<li><p>优势：JDK 原生支持，无需依赖第三方库，效率较高（在代理逻辑简单时）。</p>
</li>
<li><p>局限：只能代理实现了接口的类，无法代理无接口的类。</p>
</li>
<li><p><strong>CGLIB 代理</strong>：</p>
</li>
<li><p>基于字节码生成技术实现，通过继承被代理类生成子类作为代理对象，无需被代理类实现接口。</p>
</li>
<li><p>原理是通过 ASM 框架修改字节码，在子类中重写父类的方法，在重写方法中嵌入切面逻辑和目标方法调用。</p>
</li>
<li><p>优势：可代理无接口的类，适用范围更广。</p>
</li>
<li><p>局限：若被代理类被final修饰（无法继承），则无法生成代理对象；由于是继承实现，父类的final方法无法被重写，也就无法被增强。</p>
</li>
</ul>
<p>Spring 对代理方式的选择逻辑：</p>
<ul>
<li><p>若被代理的类实现了接口，默认使用 JDK 动态代理。</p>
</li>
<li><p>若被代理的类未实现接口，默认使用 CGLIB 代理。</p>
</li>
<li><p>可通过配置spring.aop.proxy-target-class&#x3D;true强制使用 CGLIB 代理（SpringBoot 2.x 后该配置默认值为 true）。</p>
</li>
</ul>
<p><strong>4. 事务管理：@Transactional 注解失效场景分析</strong></p>
<p><strong>面试官：</strong> 在 SpringBoot 中使用@Transactional注解时，哪些情况会导致事务失效？</p>
<p><strong>我：</strong></p>
<p>@Transactional注解通过 AOP 实现事务管理，但在一些场景下会因不符合 AOP 代理机制或注解生效条件而失效，常见场景有：</p>
<ol>
<li><p><strong>非公共方法上使用注解</strong>：@Transactional默认只对公共（public）方法生效，若在 private、protected 或 default 修饰的方法上使用，Spring 不会生成事务代理，注解失效。</p>
</li>
<li><p><strong>自身方法调用（内部调用）</strong>：在同一个类中，一个无事务的方法调用另一个有@Transactional注解的方法，由于内部调用不会经过代理对象，事务切面无法生效。例如：</p>
</li>
</ol>
<p>TypeScript取消自动换行复制</p>
<p>public class Service {</p>
<p>​    public void methodA() {</p>
<p>​        methodB(); <em>&#x2F;&#x2F; 内部调用，method<strong>B</strong>的事务失效</em></p>
<p>​    }</p>
<p>​    @Transactional</p>
<p>​    public void methodB() {</p>
<p>​        <em>&#x2F;&#x2F; 业务逻辑</em></p>
<p>​    }</p>
<p>}</p>
<ol>
<li><p><strong>异常被捕获未抛出</strong>：事务默认在遇到未捕获的 RuntimeException 或 Error 时回滚，若方法内部捕获了异常且未重新抛出，事务管理器无法感知异常，会认为事务执行成功，导致不回滚。</p>
</li>
<li><p><strong>错误的异常类型</strong>：若注解指定了rollbackFor属性（如@Transactional(rollbackFor &#x3D; IOException.class)），但实际抛出的异常不是该类型且未被rollbackFor包含，事务不会回滚；若未指定rollbackFor，checked 异常（如 IOException）默认不会触发回滚。</p>
</li>
<li><p><strong>Bean 未被 Spring 管理</strong>：若类未通过@Service、@Component等注解交给 Spring 容器管理，@Transactional注解无法被解析，自然失效。</p>
</li>
<li><p><strong>事务传播机制设置不当</strong>：若传播机制设置为PROPAGATION_NOT_SUPPORTED（不支持事务）、PROPAGATION_NEVER（禁止事务）等，会导致当前方法不使用事务；或PROPAGATION_REQUIRES_NEW等在特定场景下因事务嵌套逻辑导致预期外的结果。</p>
</li>
</ol>
<p><strong>5. 设计模式应用（工厂、单例、代理、模板方法等）</strong></p>
<p><strong>面试官：</strong> SpringBoot 中应用了哪些常见的设计模式？能举例说明吗？</p>
<p><strong>我：</strong></p>
<p>SpringBoot 基于 Spring 框架，内部大量应用了设计模式，以下是几种典型模式的应用：</p>
<ul>
<li><p><strong>工厂模式</strong>：Spring 的 Bean 创建过程主要依赖工厂模式。BeanFactory是 Bean 工厂的核心接口，负责创建和管理 Bean；DefaultListableBeanFactory等实现类通过读取配置（如注解、XML），根据 Bean 的定义信息生成 Bean 实例，开发者无需关心 Bean 的创建细节，只需通过工厂获取。</p>
</li>
<li><p><strong>单例模式</strong>：Spring 容器中的 Bean 默认是单例的（scope 为 singleton），通过一级缓存（singletonObjects）保证一个 Bean 在容器中只有一个实例。容器启动时创建 Bean 并缓存，后续多次获取的都是同一个实例，减少了对象创建的开销。</p>
</li>
<li><p><strong>代理模式</strong>：如 AOP 的实现中，JDK 动态代理和 CGLIB 代理都是代理模式的应用。代理对象在目标对象的方法前后嵌入切面逻辑（如事务、日志），既扩展了功能，又不修改目标对象的代码，符合 “开闭原则”。</p>
</li>
<li><p><strong>模板方法模式</strong>：在数据访问层（如 JdbcTemplate、RedisTemplate）中大量使用。模板类定义了操作的整体流程（如数据库连接、执行 SQL、关闭连接），将可变的步骤（如 SQL 语句、结果集处理）抽象为抽象方法或通过回调接口让用户实现，避免了重复代码，同时保证流程的一致性。</p>
</li>
<li><p><strong>观察者模式</strong>：Spring 的事件驱动模型基于观察者模式。ApplicationEvent是事件源，ApplicationListener是观察者，当事件发布（如ContextRefreshedEvent表示容器刷新完成）时，所有监听该事件的 Listener 会被触发执行，常用于业务解耦（如订单创建后发送通知）。</p>
</li>
</ul>
<p>这些设计模式的应用让 SpringBoot 的架构更灵活、可扩展，也是其能快速集成各类组件的重要原因。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/%E4%B8%BA%E4%BA%86%E5%AE%9E%E4%B9%A0%E8%AF%B4%E6%98%AF/" class="category-chain-item">为了实习说是</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/%E4%B8%BA%E4%BA%86%E5%AE%9E%E4%B9%A0%E8%AF%B4%E6%98%AF/" class="print-no-link">#为了实习说是</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java常见八股</div>
      <div>http://tow-086.github.io/2025/08/26/Java常见八股/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Agent</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/15/2025Lilctf(Revese)/" title="2025Lilctf(Reverse)">
                        <span class="hidden-mobile">2025Lilctf(Reverse)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
