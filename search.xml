<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024的1024新生赛</title>
    <url>/2024/10/24/1024%E6%96%B0%E7%94%9F%E8%B5%9B/</url>
    <content><![CDATA[1024新生赛好用的网址在线工具 - Bugku CTF平台
Base64 编码&#x2F;解码 - 锤子在线工具
凯撒也干了题目就给提示了，是凯撒加密（一种替换加密，我们直接求出：
![屏幕截图 2024-10-24 173910](屏幕截图 2024-10-24 173910.png)
至于偏移量为什么是二，因为凯撒加密是一种替换加密，我们知道flag的形式是xxxCTF{}  ARD右移两位就是CTF，所以偏移量就是-2
曲径通幽处题目描述：一个古典部的少年从一条路的尽头上下上下上的走过了一条弯曲的路，并且经过了5个庭院和5个学校。
本题flag头为ISCTF
判断其为古典加密，且给出提示上下上下上 5 5，给出的文本又是：}I_cFTle_FToneCSWnTC5@0{I 
共25位判断其为栅栏加密，我们根据提示分成五组：
}I_cF
Tle_F
ToneC
SWnTC
5@0{I 
flag开头为ISCTF，又根据给出的提示，我们可以浅试一手：
![屏幕截图 2024-10-24 181631](屏幕截图 2024-10-24 181631.png)
得出flag，
long_to_bytes这是原题：
from Crypto.Util.number import *flag=b&#x27;flag&#123;xxxxx&#125;&#x27;n=bytes_to_long(flag)print(n)&#x27;&#x27;&#x27;n=264482712154165850801381669076121773480907739897690780617124341999230794182590691214396064148014801051776269633074284019581&#x27;&#x27;&#x27;

这个题需要python和在python中安装crypto，安装python和crypto的教程在网上都好找，在此不再演示
这个比较简单，安装好这两个东西后直接long_to_bytes()就好了：
from Crypto.Util.number import *# flag=b&#x27;flag&#123;xxxxx&#125;&#x27;n=n=264482712154165850801381669076121773480907739897690780617124341999230794182590691214396064148014801051776269633074284019581n=long_to_bytes(n)print(n)&#x27;&#x27;&#x27;b&#x27;flag&#123;wanyi_nijiushi_na_wanzhongwuyi_de_tiancai_ne?&#125;&#x27;&#x27;&#x27;&#x27;



ez_mathfrom secret import flagfrom Crypto.Util.number import *def s2n(string):	return int(string.encode(&quot;utf-8&quot;).hex(),16)m = s2n(flag)n1 = getPrime(256)n2 = getPrime(256)c1 = m % n1c2 = m % n2with open(&quot;./result.txt&quot;,&quot;w&quot;) as file:	file.write(f&quot;&#123;c1=&#125;\n&#123;c2=&#125;\n&#123;n1=&#125;\n&#123;n2=&#125;&quot;)	file.close()

这个可以直接套脚本或者用sympy的内置方法就好：
from sympy.ntheory.modular import solve_congruencefrom Crypto.Util.number import *c1=37249702839435135643850404026024412683134998575291233690988327543619514037695c2=18416923650953751308058552833370734669994554569844095575888642338823812375656n1=78333809298116952939564356593122079059999883827426443480510842209201768015887n2=72210330055051819360448136226819845758816865049329539316060036869938240551269m, _ = solve_congruence((c1, n1), (c2, n2))flag = long_to_bytes(m)print(&quot;Recovered flag:&quot;, flag)&#x27;&#x27;&#x27;HTUCTF&#123;6e517351-cc04-4917-85da-47384fc14316&#125;&#x27;&#x27;&#x27;



def extended_gcd(a, b):    &quot;&quot;&quot; 返回 (gcd, x, y) 使得 ax + by = gcd &quot;&quot;&quot;    if a == 0:        return (b, 0, 1)    gcd, x1, y1 = extended_gcd(b % a, a)    x = y1 - (b // a) * x1    y = x1    return (gcd, x, y)def mod_inverse(a, m):    &quot;&quot;&quot; 计算 a 在模 m 下的逆元 &quot;&quot;&quot;    gcd, x, _ = extended_gcd(a, m)    if gcd != 1:        raise ValueError(&quot;Inverse does not exist&quot;)    return x % mdef chinese_remainder_theorem(c1, c2, n1, n2):    &quot;&quot;&quot; 根据中国剩余定理计算 m &quot;&quot;&quot;    # 验证 c1 和 c2 的合法性    if not (0 &lt;= c1 &lt; n1) or not (0 &lt;= c2 &lt; n2):        raise ValueError(&quot;c1 must be less than n1 and c2 must be less than n2&quot;)        # 计算 n1 和 n2 的逆元    n1_inv = mod_inverse(n1, n2)    n2_inv = mod_inverse(n2, n1)    # 根据 CRT 的公式计算 m    m = (c1 * n2 * n2_inv + c2 * n1 * n1_inv) % (n1 * n2)    return m# 示例c1 = 2  # 例：m % n1c2 = 3  # 例：m % n2n1 = 5  # 模数 n1n2 = 7  # 模数 n2m = chinese_remainder_theorem(c1, c2, n1, n2)print(&quot;The value of m is:&quot;, m)



普通的RSA这个涉及RSA了，感觉一时半会讲不完，讲了你们也听不懂，先放原题吧：
from secret import flagfrom Crypto.Util.number import *from gmpy2 import *def s2n(string):	return int(string.encode(&quot;utf-8&quot;).hex(),16)n=p*qm = s2n(flag)def gen():	p = getPrime(1024)	q = int(next_prime(p))	n = p*q	phi = (p-1)*(q-1)	e=0x10001	while(gcd(phi,e) != 1):		p = getPrime(1024)		q = next_prime(p)		n = p*q		phi = (p-1)*(q-1)	return (n,e,phi)n,e,phi = gen()c = pow(m,e,n) m**e(mod n)=c m=c**d modnwith open(&quot;./RSA.txt&quot;,&quot;w&quot;) as file:	file.write(f&quot;&#123;n=&#125;\n&#123;c=&#125;&quot;)	file.close()

这种是已知n，c，e的，通过q&#x3D;next_prime(p)我们知道p和q比较接近，所以可以利用这一点来解密：
from Crypto.Util.number import *from gmpy2 import *from sympy import  nextprime, rootimport mathn=18949498985986928711843321080602823701712014042049416390846564093388611291117062696087230880365026760797539322795552533481425232454936702742130962936755703750058517665792856275700722341035864624409094208842377728513453452818841799059356922700403897583999797293831012950825029618460259198795550064691440879505779511194409762430676541543737089954665642736218306476220888830115844610819075723263763070748740428190826833316582893965878723227457610920738816258244554829877952822355818446165333343949923505996270102899784022411761912934504022393721987105209305284347043340327561826434179480900699255745436348685748974901201c=2969824285249100526322302682221040716867970513038732238063889997163423491301934038093514987472802359998652707545381821218024355980402402868317513122066439113058805805494989902360947778584693127259486538542108670777034276473922171938113305898239307091304099755800468445443498516447604650800088630197154105031841166708938180803550612723800232703109540434743220287394920524894879882922225369950384603748805110488531200017670810970677068957353697200297293764561028264920407022749642913030162012868067293039018324185505638205631433386764255108667369874722506838551476625040094069895067492912258930920239951143338333435586e=65537a=root(n,2)q=nextprime(a)p=n//qphi=(p-1)*(q-1)d=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))b&#x27;HTUCTF&#123;bb818877-0509-47a4-9a69-e26f69fc355a&#125;&#x27;



attack这个是一个简单的基于字母表的加密系统。它使用字母到数字的映射，结合一个密钥，通过对应元素相加的方式对字符串进行加密。由于代码的设计，非字母字符不会被加密，因此它们将保持不变。
原题：
from secret import flagimport string# 实现列表对应元素相加（加密部分）def add_list(x,y):    result = []    for i in range(len(x)):        z = x[i] + y[i]        result.append(z)    return result# 实现列表元素对应相减（解密部分）def sub_list(x,y):    result = []    for i in range(len(x)):        z = x[i] - y[i]        result.append(z)    return result# 构造映射 字符----&gt;numdef c2n():    list_c = []    list_n = []    for i in range(26):        list_n.append(i)        list_c.append(chr(i+97))    dic_c2n = dict(map(lambda x,y:[x,y],list_c,list_n))    return dic_c2n# 构造映射 num----&gt;字符def n2c():    list_c = []    list_n = []    for i in range(26):        list_n.append(i)        list_c.append(chr(i+97))    dic_n2c = dict(map(lambda x,y:[x,y],list_n,list_c))    return dic_n2c# 加密def encode(s,key):    # print(&#x27;加密后的字符： &#x27;,end=&#x27;&#x27;)    dic_c2n = c2n()    dic_n2c = n2c()    list_s = []    list_key = []    list_finall = []    for i in s:        i = i.lower()        list_s.append(dic_c2n[i])    for i in key:        i = i.lower()        list_key.append(dic_c2n[i])    for i in list_key:        if len(list_key) &lt;= len(list_s):            list_key.append(i)    list_result = add_list(list_s,list_key)    for i in list_result:        if i &gt; 25:            i -= 26        list_finall.append(dic_n2c[i])    return list_finall[0]def all_encode():	key = &quot;HELLO&quot;	count = 0	keyword = string.ascii_letters 	result = &quot;&quot;	for i in range(len(flag)):		tk = key[count % len(key)]		if flag[i] not in keyword:			result += flag[i]		else:			result += encode(tk,flag[i])			count += 1	return resultencode_data = all_encode()with open(&quot;./attack.txt&quot;,&quot;w&quot;) as file:	file.write(f&quot;secret is :&#123;encode_data&#125;&quot;)	file.close()



了解加密过程：在加密过程中，我们将字母转换为对应的数字，然后将这些数字与密钥的数字相加（并使用模 26 处理）。为了反向解密，我们需要进行相减操作。就写代码进行解密就好了。
直接丢给ai也行，因为这是简单的加密解密（思考
import stringfrom Crypto.Util.number import *encoded=&quot;oxfnhm&#123;44648e87-2632-4236-997l-po38k362837h&#125;&quot;# 字符到数字的映射def c2n():    dic_c2n = &#123;chr(i + 97): i for i in range(26)&#125;  # &#x27;a&#x27; = 97    return dic_c2n# 数字到字符的映射def n2c():    dic_n2c = &#123;i: chr(i + 97) for i in range(26)&#125;  # &#x27;a&#x27; = 97    return dic_n2c# 从两个列表中减去对应的数字def sub_list(list_s, list_key):    return [(s - key) % 26 for s, key in zip(list_s, list_key)]# 解密函数def decode(s, key):    dic_c2n = c2n()    dic_n2c = n2c()    list_s = []    list_key = []    list_final = []    # 将字符串和密钥转换为数字    for i in s:        i = i.lower()        if i in dic_c2n:  # 只处理字母            list_s.append(dic_c2n[i])    for i in key:        i = i.lower()        if i in dic_c2n:  # 只处理字母            list_key.append(dic_c2n[i])    # 解密：用密钥的数字减去字符串的数字    list_result = sub_list(list_s, list_key)    # 将解密结果转换为字符    for i in list_result:        list_final.append(dic_n2c[i])    return &#x27;&#x27;.join(list_final)# 解密全部def all_decode(encoded_string):    key = &quot;HELLO&quot;  # 密钥    count = 0    result = &quot;&quot;    for i in range(len(encoded_string)):        tk = key[count % len(key)]  # 获取密钥字符        if encoded_string[i] not in string.ascii_letters:  # 保持非字母字符不变            result += encoded_string[i]        else:            result += decode(encoded_string[i], tk)  # 解密字母            count += 1  # 只对字母增加计数    return resultdecoded=all_decode(encoded)print(decoded)&#x27;htuctf&#123;44648a87-2632-4236-997a-ea38d362837d&#125;&#x27;htuctf&#123;44648a87-2632-4236-997a-ea38d362837d&#125;

哦，维吉尼亚加密解密，因为直接用ai出了就没管他。这里感谢rph的提问
ReDsok啊，这是随机数预测，详情请看：
[CTF&#x2F;randcrack]python随机数预测模块分析及改进方案_random.getrandbits(32)-CSDN博客
原题：
from secret import flagfrom random import getrandbitsfrom Crypto.Cipher import AESimport base64def pad(data):	data=data.encode(&#x27;utf8&#x27;)	while len(data) % 16 !=0:		data+=b&#x27;\x00&#x27;	return datadef encode(key,m):	mode=AES.MODE_ECB	aes=AES.new(pad(key),mode)	en_m=aes.encrypt(pad(m))	en_m=base64.encodebytes(en_m)	en_m=en_m.decode(&#x27;utf8&#x27;)	return en_mwith open(&quot;./ReDs.txt&quot;,&quot;w&quot;) as file:	for i in range(624):		file.write(str(getrandbits(32)) + &quot;\n&quot;)			key= str(getrandbits(32))	encode_data = encode(key,flag)	file.write(f&quot;\n&#123;encode_data=&#125;&quot;)	file.close()

给出了624个32位随机数，我们可以预测出下一个数，也就是我们能预测出key的值
具体原因：（为什么会被预测）是因为这是随机数算法的一个，算是漏洞？
然后这一题有两种方法，一种是爆破：
from tqdm import trangefrom base64 import b64decodefrom Crypto.Cipher import AESfrom multiprocessing import Pool, current_processimport osenc_data = &#x27;AcQYXx1jdOVU2wArqtW3JAfd5fPgkBMMcbOfz8C2x71aP9CUH0pZp3moQ3PXyETQ&#x27;data = b64decode(enc_data)def pad(data):	data=data.encode(&#x27;utf8&#x27;)	while len(data) % 16 !=0:		data+=b&#x27;\x00&#x27;	return datadef decode(key, text) -&gt; bytes:	aes = AES.new(pad(key),AES.MODE_ECB)	return aes.decrypt(text)def task(start, per_size, pool):	print(f&quot;process id &#123;os.getpid()&#125;&quot;)	for key in range(start, start + per_size):		if decode(str(key), data).startswith(b&quot;HTUCTF&quot;):			print(&quot;key found!!!!!!&quot;,key,decode(str(key), data))			breakdef main():	full_size = 2**32 # 搜索大小为32bit	size = 60 # 创建60个进程	per_size = full_size // size # 分配任务，类似于分段搜索	next_size = 0 # 初始化开始位置	p = Pool(size) # 创建进程池	for _ in range(size):		if next_size + per_size &gt; full_size:			per_size = full_size - next_size		p.apply_async(task, args=(next_size, per_size) ) #执行区间搜索		next_size += per_size	p.close()	p.join()if __name__ == &quot;__main__&quot;:	main()

一种是随机数预测：
# -*- coding: utf-8 -*-from randcrack import RandCrackfrom base64 import b64decodeimport randomfrom random import getrandbitsfrom Crypto.Cipher import AESimport base64a=list(map(int,&#x27;&#x27;&#x27;3848073275241649934394350397825820783640818119651651597630332567687429640028552822968513266693731014914539201125945763329886974716582126723058975936272546682833899901751388788501246200924131503549439673828713529847483040743723429431973325784864479340420924786143305053974231787168395108732296775518323062281273742813448273189781339980261012159565135334806995857326779953211118529535917631924882170424734279335540627344220611863744472386271090818331444232633192716483325060502913197204871427845172354847929071360256629143644833275801257329442958086159855591686989640115651933872765094220249907911127728609430611651127268558119190498120283929722175136101555539251419752936329647766752345984344510018469217577779335280572831191665294172113036277307582262562395945890808335348887128411595642763177991345022153359028265026725652683514593588327756223866053613826237760102086786901211404858936088947064047393720279675399125997748036093734863786396671278916783137936176565589847828393962442219102487370790875417485862812193471801390344307242717043491358952278349714061914435894345487062513767751035118303062027124734501634316554257007018312492976838903518732451975774433864241346994891833482948881962699470426160478410017813491501063835188037077973391549542835854781619412316756021595274725930134651985459143570153596175628588495874353343278308120594113959313464026172262373901572818432323094430976171164709487422180997026344375011593786293469355994246151727075728889431965181846830612642792293289009232143143490133217755973985459613269720908934234339125265623715770899587847884474150004081670066404368012494130817149291597657805404039486133066533161233267726244727190625202007752055123854472980557324385948581898767934935097943147151208323008286318496341314070799626425445688336102606122800938443323089281772467472417488196714553090592395758659221509135359876544162982524407009203681022405637624381741941967791195673550424337156992128333110265145056329001941172253117406359842601723776723711755246801314762693745778362253729808938108493062745684961358454685311678099791691175119391164821447281338835732001223335394763114368970113107508243273713261286196703232922946863495244137325464972514258418644062907343610076228249060104522575273279573375245854948125365717452461806163607555386507624013135455248231654022132188059926304690237031865163161005872010386261595425496351153198068926193252274926586132632717159733199868890866770584281040531638713893301090631798902454188201660633123238853111420297041372893071534416621651553367163175097353325443251138423236191145275782130671186940939643051417666177574791083235304783411066670062707446091358655385183993668811616208271613270503265074079225242109402373882531957022932375181399938740018982879916753902476446386170566014028917643353505689302077236123984999982762040925109054160827014098942832683852233427823359996659841158956032620188711231180327910558638013805927781242834327161134206962313353042651532593708925238075792733155681912851109544306938027135335230610288976852351996621149845427532217944572007982751404298732115727939202806215892263777336519338826046136274752863867524205814642730870186921031464334764951111078816810404759683696224193873435094270944556172516113912624236901222429754402203734631041991911480867824174338629292706846731742161962058120239297384224314723070103654221498916706160683084656246638976436473830697624149981936317343126225832932858742576545868133446752043680787991143627998819655796012269994561809553783419626786216120155812443834153284416180419337853661222011827308886887639071291481922204261130812762295194487311911161081429336684460976042968366770327426752723971246031015603405376795135535285491312294845951797847468287730133191798828205610760130330831583731687545660365745592936093754464420359192752811997298862916416911207636613928617152755436199221745580281054439233205520671926841524481201960873397399570288284321285834830832648136616048430612971590523254737494632332268192575969200143409383630062983811478025637235932873134001791813802006073258501643626917416152819187100116274083223158113933253463985226720988953824071341404212761023438136037719352239738493354434834272705166940312660661134094029394464625241712733902554104525353693888440430263531066101437920595909369806867625520983343058235330333175813516219629289397264717535859884102335764404081860130256516815607516281326908270133624176719901414122784933936410767873156108867342907903897820551906288201671002639224512875389351545157016387207561096767326110093946217239257863114917632218725177840549940152976247062170439026869497390231583261985098440021310437031241244520502167158322202850926474339892279050826141225135327324617741474408664177060317618349575306234618872553713093387966950342931261586595802673895659763152541866741206665082905137942592990536723856024296640777322771071433753420260678568086255658731993488200304263144326473943061136382294244509821911915638183360445919296475655327154888045481496733357409579802677002309432900831050474122103895343399024779020386177986393314522478692397161603720812996094221772984623344194369291224688572913662978685016364552150418817958251830185639121255343818741916929674616453667323470362049148731446701891545252964353656973114364725071312059481340657902533574236031409388743943065710310041984722262566752133816185285022041306293973722439833203674422443488886471384455202588717374100411243121145494711752470957213929107248811540538638340028922318501636582849133137484729805895063490463738186158303834396421241616450563298713554954864505917226003065612794823373982470345009528427524242114456726132337176591291391621255566207716859047811678290553304092516810029779334057601629965764011130014484679481921517993899717700675501581789470116794457234943058247434336033445955993228458409137683469316739584006930204324083503372215860701322180853832059678395007691925022304581307492624172827967233427925331046256777134264787739224056023692057445582075612177592815015000004211001972832260426874613079991352487459642132379087949081046416087515623843192041147180338385720142620433244942803127951080156369&#x27;&#x27;&#x27;.split(&#x27;\n&#x27;)           ))def pad(data):		while len(data) % 16 !=0:		data+=b&#x27;\x00&#x27;	return datadef decode(key, enc_data):        mode = AES.MODE_ECB    aes = AES.new(pad(key), mode)    return aes.decrypt(enc_data)rc=RandCrack()for i in a:        rc.submit(i)print(rc.predict_getrandbits(32))    # print(type(rc.predict_getrandbits(32))) key=&quot;3597202257&quot;print(key)key=key.encode(&#x27;utf8&#x27;)encode_data=&#x27;T0trtp358+Z3nNHopY+g3+zuykR+cXvlbebg8INr97JSlE7ZGEbeVSNEoHLmRj59&#x27;encode_data = b64decode(encode_data)decoded_bytes = decode(key, encode_data)print(f&quot;解密的原始字节：&#123;decoded_bytes&#125;&quot;)  print(type(decoded_bytes))



ReDs卷土重来
from randcrack import RandCrackfrom base64 import b64decodefrom Crypto.Cipher import AESfrom hashlib import md5def pad(data):	data=data.encode(&#x27;utf8&#x27;)	while len(data) % 16 !=0:		data+=b&#x27;\x00&#x27;	return datadef decode(key, text) -&gt; bytes:	aes = AES.new(pad(key),AES.MODE_ECB)	return aes.decrypt(text)encode_data = &#x27;oXuE0fPdOJGoMwkc+mqd0hDP9MPze2zeHC4l+2kc/4gxMZv7Az2mo8ZuqLaECFBt&#x27;data = b64decode(encode_data)def main():	rc = RandCrack()	with open(&quot;G:\QQ\data.txt&quot;,&#x27;r&#x27;) as file:		for _ in range(624):			rc.submit(int(file.readline()))	raw_key = rc.predict_getrandbits(1024)	key = md5(str(raw_key).encode(&#x27;utf-8&#x27;)).hexdigest()	print(decode(str(key), data))if __name__ == &quot;__main__&quot;:	main()

]]></content>
      <categories>
        <category>CTF</category>
        <category>密码</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码</tag>
        <tag>校赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-2025一学年的总结</title>
    <url>/2025/06/27/2024-2025%E4%B8%80%E5%AD%A6%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[2024-2025一学年的总结9月加入网安社，突觉天地之无穷，宇宙之浩渺，我还是太菜了。打了basectf，启蒙比赛，u1s1题比较适合我，学了点密码，会了点python，哦思绪回到现在，密码水平，以我已知的密码水平为100的话，我现在的密码水平大概三四十吧，会一些简单的题罢了。
10月学了Javaweb，继续学了密码
11月打了金盾，继续学了密码
12月学了某马经典xx外卖
1月期末了，说结果吧，最后计组挂科，其他踩线过，得到了2.4的超低绩点
2月、3月寒假，用websocket写了个实时聊天的demo
4月自己写了个类似论坛的网页，详情之前发过。学了点算法，蓝桥杯拿了个省二，对不起guoql神，给您丢脸了。痛失三百块
5月iscc和御网，结果双双败北，让我感觉CTF比赛没那么有意思了，但解题还是很好玩的，只是比赛的话，额，其实还是因为我太菜了
6月某点评写完了。又写了个rabbitMQ的demo，另外，我Apex白金了。
]]></content>
      <categories>
        <category>-日常</category>
      </categories>
      <tags>
        <tag>-日常</tag>
      </tags>
  </entry>
  <entry>
    <title>2025XYCTFCTF</title>
    <url>/2025/04/17/2025XYCTF/</url>
    <content><![CDATA[连接端口from pwn import *io = remote(&#x27;gz.imxbt.cn&#x27;, 20611)print(io.recv().decode())  # 打印欢迎信息io.interactive()          # 进入交互模式（手动输入）



Division原题：
# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@File    :   server.py@Time    :   2025/03/20 12:25:03@Author  :   LamentXU &#x27;&#x27;&#x27;import random print(&#x27;----Welcome to my division calc----&#x27;)print(&#x27;&#x27;&#x27;menu:      [1]  Division calc      [2]  Get flag&#x27;&#x27;&#x27;)while True:    choose = input(&#x27;: &gt;&gt;&gt; &#x27;)    if choose == &#x27;1&#x27;:        try:            denominator = int(input(&#x27;input the denominator: &gt;&gt;&gt; &#x27;))        except:            print(&#x27;INPUT NUMBERS&#x27;)            continue        nominator = random.getrandbits(32)        if denominator == &#x27;0&#x27;:            print(&#x27;NO YOU DONT&#x27;)            continue        else:            print(f&#x27;&#123;nominator&#125;//&#123;denominator&#125; = &#123;nominator//denominator&#125;&#x27;)    elif choose == &#x27;2&#x27;:        try:            ans = input(&#x27;input the answer: &gt;&gt;&gt; &#x27;)            rand1 = random.getrandbits(11000)            rand2 = random.getrandbits(10000)            correct_ans = rand1 // rand2            if correct_ans == int(ans):                print(&#x27;WOW&#x27;)                with open(&#x27;flag&#x27;, &#x27;r&#x27;) as f:                    print(f&#x27;Here is your flag: &#123;f.read()&#125;&#x27;)            else:                print(f&#x27;NOPE, the correct answer is &#123;correct_ans&#125;&#x27;)        except:            print(&#x27;INPUT NUMBERS&#x27;)    else:        print(&#x27;Invalid choice&#x27;)

这是一个伪随机数加密类的题，他是通过除输入的分母1，进行624次，得出内部结构，因此可以预测接下来的数。又由于是11000位和10000位相除，所以精度不必那么高（可以是32的n倍直接求，当然切割也行）注意要精确截取，ai生成的有点小问题，但这位师傅的没问题，稳得一批
文章参考：[CTF&#x2F;randcrack]python随机数预测模块分析及改进方案_random.getrandbits(32)-CSDN博客
wp：
#!/usr/bin/env python3# -*- coding: utf-8 -*-from pwn import *       # 用于网络交互的基础库from randcrack import RandCrack  # MT19937预测器库from tqdm import trange  # 进度条显示def main():    &quot;&quot;&quot;    主函数：实现完整的攻击流程    原理：    1. MT19937伪随机数生成器基于624个32位内部状态    2. 收集624个连续生成的随机数即可重建完整状态    3. 利用重建的状态可以预测后续所有随机数    &quot;&quot;&quot;        # ==================== 初始化阶段 ====================    # 初始化预测器对象    rc = RandCrack()  # 创建MT19937状态预测器        # 建立与服务器的连接（重要：确认端口正确性）    # 注意：这里使用pwntools的remote函数连接指定IP和端口    p = remote(&quot;39.106.69.240&quot;, 24578)  # 题目给定的服务器地址和端口    # ================== 状态收集阶段 ====================    # 需要收集624个连续生成的32位随机数    # 进度条显示增强交互体验（trange是tqdm的进度条封装）    for _ in trange(624, desc=&quot;Collecting states&quot;):        # 发送选项1进入除法计算模式        p.sendlineafter(b&quot;: &gt;&gt;&gt;&quot;, b&quot;1&quot;)  # 当接收到&quot;: &gt;&gt;&gt;&quot;提示时发送选项1                # 发送分母1（关键：确保每次计算的分母为1）        p.sendlineafter(b&quot;denominator: &gt;&gt;&gt;&quot;, b&quot;1&quot;)  # 分母设置为1使结果等于分子                # 接收服务器响应并解析分子值        # 响应格式示例：&quot;4294967295//1 = 4294967295&quot;        line = p.recvline().decode()     # 接收完整响应行        numerator = int(line.split(&#x27;//&#x27;)[0].strip())  # 提取&#x27;//&#x27;前的分子部分                # 将分子提交给预测器重建内部状态        rc.submit(numerator)  # 每次submit会更新预测器的内部状态    # ================ 随机数预测阶段 ====================    # 生成第一个大整数（11000位）    # 原理：    # 1. predict_getrandbits(n)会自动计算需要生成多少次32位随机数    # 2. 11000位需要344次32位生成（344*32=11008位），然后截取前11000位    rand1 = rc.predict_getrandbits(11000)  # 预测11000位随机整数        # 生成第二个大整数（10000位）    # 同理需要313次32位生成（313*32=10016位），截取前10000位    rand2 = rc.predict_getrandbits(10000)  # 预测10000位随机整数        # 计算整除结果（服务器验证的核心）    ans = rand1 // rand2  # 大整数除法，Python天然支持高精度计算    # ================== 答案提交阶段 ====================    # 发送选项2进入答案提交模式    p.sendlineafter(b&quot;: &gt;&gt;&gt;&quot;, b&quot;2&quot;)  # 当出现提示时发送选项2        # 提交计算结果（必须转换为字符串格式）    p.sendlineafter(b&quot;answer: &gt;&gt;&gt;&quot;, str(ans).encode())  # 编码为字节流发送    # ================== 获取Flag阶段 ====================    # 进入交互模式查看服务器返回结果    # 成功时会返回包含flag的信息，失败则显示错误提示    p.interactive()  # 保持连接交互，直到手动退出if __name__ == &quot;__main__&quot;:    # 执行主函数    main()



Complex_signin原题：
from Crypto.Util.number import *from Crypto.Cipher import ChaCha20import hashlibfrom secret import flagclass Complex:    def __init__(self, re, im):        self.re = re        self.im = im    def __mul__(self, c):        re_ = self.re * c.re - self.im * c.im        im_ = self.re * c.im + self.im * c.re        return Complex(re_, im_)    def __eq__(self, c):        return self.re == c.re and self.im == c.im    def __rshift__(self, m):        return Complex(self.re &gt;&gt; m, self.im &gt;&gt; m)    def __lshift__(self, m):        return Complex(self.re &lt;&lt; m, self.im &lt;&lt; m)    def __str__(self):        if self.im == 0:            return str(self.re)        elif self.re == 0:            if abs(self.im) == 1:                return f&quot;&#123;&#x27;-&#x27; if self.im &lt; 0 else &#x27;&#x27;&#125;i&quot;            else:                return f&quot;&#123;self.im&#125;i&quot;        else:            return f&quot;&#123;self.re&#125; &#123;&#x27;+&#x27; if self.im &gt; 0 else &#x27;-&#x27;&#125; &#123;abs(self.im)&#125;i&quot;    def tolist(self):        return [self.re, self.im]def complex_pow(c, exp, n):    result = Complex(1, 0)    while exp &gt; 0:        if exp &amp; 1:            result = result * c            result.re = result.re % n            result.im = result.im % n        c = c * c        c.re = c.re % n        c.im = c.im % n        exp &gt;&gt;= 1    return resultbits = 128p = getPrime(1024)q = getPrime(1024)n = p * qm = Complex(getRandomRange(1, n), getRandomRange(1, n))e = 3c = complex_pow(m, e, n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;mh = &#123;(m &gt;&gt; bits &lt;&lt; bits).tolist()&#125;&quot;)print(f&quot;C = &#123;c.tolist()&#125;&quot;)print(f&quot;enc = &#123;ChaCha20.new(key=hashlib.sha256(str(m.re + m.im).encode()).digest(), nonce=b&#x27;Pr3d1ctmyxjj&#x27;).encrypt(flag)&#125;&quot;)&#x27;&#x27;&#x27;n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]enc = b&#x27;\x9c\xc4n\x8dF\xd9\x9e\xf4\x05\x82!\xde\xfe\x012$\xd0\x8c\xaf\xfb\rEb(\x04)\xa1\xa6\xbaI2J\xd2\xb2\x898\x11\xe6x\xa9\x19\x00pn\xf6rs- \xd2\xd1\xbe\xc7\xf51.\xd4\xd2 \xe7\xc6\xca\xe5\x19\xbe&#x27;&#x27;&#x27;&#x27;



题解：

# sagefrom sage.all import *  # 导入SageMath的数学库from Crypto.Cipher import ChaCha20  # 导入ChaCha20加密库import hashlib  # 导入哈希函数库import itertools  # 导入迭代工具库def small_roots(f, bounds, m=1, d=None):    &quot;&quot;&quot;    使用Coppersmith方法求解多项式的小根    参数：        f: 需要求解的多项式        bounds: 变量的上界（如(2^128, 2^128)）        m: LLL算法的参数（影响格的构造）        d: 多项式的最大次数（默认为多项式次数）    返回：        满足条件的根列表    &quot;&quot;&quot;    if not d:        d = f.degree()  # 若未指定d，取多项式次数    R = f.base_ring()  # 获取多项式系数的环（如Zmod(n)）    N = R.cardinality()  # 环的基数（如n）    # 正规化多项式：将首项系数归一化为1    f /= f.coefficients().pop(0)      f = f.change_ring(ZZ)  # 将多项式转换为整数环上的多项式    G = Sequence([], f.parent())  # 初始化格基向量列表    for i in range(m + 1):        base = N^(m - i) * f^i  # 构造基础多项式（用于格的构造）        for shifts in itertools.product(range(d), repeat=f.nvariables()):            # 枚举所有可能的指数组合（构造格的列）            g = base * prod(map(power, f.variables(), shifts))            G.append(g)    B, monomials = G.coefficient_matrix()  # 提取系数矩阵和单项式    monomials = vector(monomials)  # 转换为向量形式    factors = [monomial(*bounds) for monomial in monomials]  # 计算缩放因子    for i, factor in enumerate(factors):        B.rescale_col(i, factor)  # 缩放矩阵列    B = B.dense_matrix().LLL()  # 应用LLL算法进行格规约    B = B.change_ring(QQ)  # 转换为有理数环    for i, factor in enumerate(factors):        B.rescale_col(i, 1 / factor)  # 反缩放矩阵列    H = Sequence([], f.parent().change_ring(QQ))  # 初始化新多项式列表    for h in filter(None, B * monomials):  # 生成新多项式        H.append(h)        I = H.ideal()  # 构造理想        if I.dimension() == -1:  # 理想维度不为0，移除最后一个多项式            H.pop()        elif I.dimension() == 0:  # 理想维度为0，存在解            roots = []            for root in I.variety(ring=ZZ):  # 求解整数解                root = tuple(R(root[var]) for var in f.variables())                roots.append(root)            return roots  # 返回第一个解集    return []  # 无解时返回空列表# RSA模数n（大素数的乘积）n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753# 已知的m的高位部分（mh_re为实部高位，mh_im为虚部高位）mh = [    3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016,    15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]# 密文C的实部和虚部C = [    5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760,    21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]enc = b&#x27;\x9c\xc4n\x8dF\xd9\x9e\xf4\x05\x82!\xde\xfe\x012$\xd0\x8c\xaf\xfb\rEb(\x04)\xa1\xa6\xbaI2J\xd2\xb2\x898\x11\xe6x\xa9\x19\x00pn\xf6rs- \xd2\xd1\xbe\xc7\xf51.\xd4\xd2 \xe7\xc6\xca\xe5\x19\xbe&#x27;  # 密文# 提取m的实部和虚部高位mh_re, mh_im = mhC_re, C_im = C  # 提取密文的实部和虚部# 构造多项式环（模n）PR.&lt;x,y&gt; = PolynomialRing(Zmod(n))# 构造多项式方程：(mh_re + x)^3 - 3*(mh_re + x)*(mh_im + y)^2 ≡ C_re mod n# 该方程基于复数m = (mh_re + x) + (mh_im + y)i的立方模n等于C_re + C_im i的实部f = (mh_re + x)**3 - 3*(mh_re + x)*(mh_im + y)**2 - C_re# 求解多项式的小根（x和y的绝对值小于2^128）res = small_roots(f, (2^128, 2^128), m=2, d=3)  # 计算真实的m_re和m_imm_re = mh_re + int(res[0][0])m_im = mh_im + int(res[0][1])# 生成密钥：将m_re + m_im的字符串哈希为32字节的密钥key = hashlib.sha256(str(m_re + m_im).encode()).digest()# 解密密文（ChaCha20要求nonce为12字节）cipher = ChaCha20.new(key=key, nonce=b&#x27;Pr3d1ctmyxjj&#x27;)flag = cipher.decrypt(enc).decode()print(&quot;Flag:&quot;, flag)# XYCTF&#123;Welcome_to_XYCTF_Now_let_us_together_play_Crypto_challenge&#125;



reed原题：
import stringimport randomfrom secret import flag  # 从secret模块导入flag# 验证flag格式是否正确（必须以&#x27;XYCTF&#123;&#x27;开头，&#x27;&#125;&#x27;结尾）assert flag.startswith(&#x27;XYCTF&#123;&#x27;) and flag.endswith(&#x27;&#125;&#x27;)# 去除flag的外层包装，获取核心内容flag = flag.rstrip(&#x27;&#125;&#x27;).lstrip(&#x27;XYCTF&#123;&#x27;)# 定义字符表 - 包含所有大小写字母和数字（a-z, A-Z, 0-9）table = string.ascii_letters + string.digits# 确保flag中的所有字符都在字符表中assert all(i in table for i in flag)# 创建随机数生成器实例r = random.Random()class PRNG:    &quot;&quot;&quot;自定义伪随机数生成器，带有特殊的种子更新机制&quot;&quot;&quot;        def __init__(self, seed):        # 定义随机数生成范围        self.a = 1145140      # 最小值        self.b = 19198100     # 最大值        # 初始化随机种子        random.seed(seed)    def next(self):        &quot;&quot;&quot;生成下一个随机数并基于该数更新种子&quot;&quot;&quot;        # 在固定范围内生成随机数        x = random.randint(self.a, self.b)        # 用该数的平方+1作为新种子（关键特性）        random.seed(x ** 2 + 1)        return x        def round(self, k):        &quot;&quot;&quot;生成k个随机数并返回最后一个&quot;&quot;&quot;        x = 0        for _ in range(k):            x = self.next()        return xdef encrypt(msg, a, b):    &quot;&quot;&quot;使用线性同余算法加密消息&quot;&quot;&quot;    # 对消息中的每个字符：    # 1. 找到它在字符表中的索引    # 2. 应用公式 (a * 索引 + b) mod 19198111    c = [(a * table.index(m) + b) % 19198111 for m in msg]    return c# 获取用户输入的种子值seed = int(input(&#x27;请输入种子: &#x27;))# 用用户提供的种子初始化PRNGprng = PRNG(seed)# 生成加密参数a和b：# - 每个参数都是通过PRNG运行随机轮次得到的# - 轮次数范围是0到65535（2^16-1）a = prng.round(r.randrange(2**16))b = prng.round(r.randrange(2**16))# 用生成的参数加密flagenc = encrypt(flag, a, b)# 输出加密结果print(enc)





我们知道她的加密过程：    c &#x3D; [(a * table.index(m) + b) % 19198111 for m in msg]，这是同余式。
然后，我们输入随机种子可以得到密文c，我们要想得到明文m，就需要得到a和b，而明文m的范围为ASCII值0到61，也就是说我们：$$c0​ ≡a∗m0​ +b%p$$
$$c1​ ≡a∗m1​ +b%p$$
$$a≡(c0​ −c1​ )∗(m0​ −m1​ )−1 %p$$
$$只要GCD(m0​ −m1​ ,p)&#x3D;1，逆元即存在$$
其实我们只要m循环取0到61，满足公式条件就能得出a和b，进而得出明文m为什么。
至于为什么GCD&#x3D;1,逆元存在：X*X-1&#x3D;1 modp,当且仅当GCD（X，p)&#x3D;1时，X-1才存在（乘法逆元）
遍历两遍m,判断得出的a，b是不是满足范围：
XYCTF2025-WriteUp | HvAng’s Nests
代码（直接搬了上面这位师傅的：
import stringfrom pwn import *import jsonio = remote(&quot;39.106.48.123&quot;, 34301)table = string.ascii_letters + string.digitsp = 19198111def egcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = egcd(b % a, a)        return (g, x - (b // a) * y, y)def modinv(a, mod):    g, x, y = egcd(a, mod)    if g != 1:        return None    else:        return x % moddef decrypt(enc):    for i in range(len(enc)):        for j in range(i + 1, len(enc)):            c0 = enc[i]            c1 = enc[j]            for m0 in range(len(table)):                for m1 in range(len(table)):                    if m0 == m1:                        continue                    delta_m = m1 - m0                    delta_c = (c1 - c0) % p                    inv = modinv(delta_m, p)                    if inv is None:                        continue                    a = (delta_c * inv) % p                    b = (c0 - a * m0) % p                    # Check if a and b are within PRNG&#x27;s output range                    if not (1145140 &lt;= a &lt;= 19198100):                        continue                    if not (1145140 &lt;= b &lt;= 19198100):                        continue                    valid = True                    decrypted = []                    for c in enc:                        numerator = (c - b) % p                        inv_a = modinv(a, p)                        if inv_a is None:                            valid = False                            break                        m = (numerator * inv_a) % p                        if not (0 &lt;= m &lt; len(table)):                            valid = False                            break                        decrypted.append(table[m])                    if valid:                        return &#x27;&#x27;.join(decrypted)    return &quot;解密失败&quot;io.recvuntil(b&#x27;give me seed: &#x27;)io.sendline(str(114514))enc = json.loads(io.recvline().decode())flag = decrypt(enc)print(&quot;解密后的Flag:&quot;, f&#x27;XYCTF&#123;&#123;&#123;flag&#125;&#125;&#125;&#x27;)# 解密后的Flag: XYCTF&#123;114514fixedpointissodangerous1919810&#125;



然后还有一个题解：
上面那个题解据出题人languag3说是自己脑子抽了加了个仿射加密，实际上算是非预期了，预期题解是输入不同的seed找循环的规律得出，然后枚举a和b来计算flag，此话在Initialization的wp中亦有分析：2025xyctf wp | Collectcrop’s Blog
1.看题目。大概就是用户提供一个种子，使用该种子初始化PRNG生成两个参数a和b，然后使用线性同余加密方式加密flag，(a * table.index(m) + b) % 19198111。
2.nc上之后可以看到，虽然每次得到的密文组不同，但是固定的几个位置上的数一定是相同的，比如1，2，5…。说明这几个位置上的明文是相同的，如果可以先猜测这些位置上的明文，就可以列方程组解a,b，由此再去解剩余的密文。（说实话是遍历试的明文，代码总是有点问题改了很久，答案出来之后只能说哎，这怎么能没看出来，这相同的位置，这提示，哎）
随便一组数据测试：
from itertools import combinationsimport stringdef inverse(a, m):    def extended_gcd(a, b):        if a == 0:            return b, 0, 1        else:            gcd, x, y = extended_gcd(b % a, a)            return gcd, y - (b // a) * x, x    gcd, x, _ = extended_gcd(a, m)    if gcd != 1:        raise ValueError(&quot;a在模m下没有逆&quot;)    else:        return x % mdef solve(cipher, table, m):    &quot;&quot;&quot;解密cipher&quot;&quot;&quot;    # 找到重复值    repeated = [c for c in set(cipher) if cipher.count(c) &gt; 1]    if len(repeated) &lt; 2:        print(&quot;Not enough repeated values to solve&quot;)        return    # 遍历可能的重复值组合    for c0, c1 in combinations(cipher, 2):        pos0 = cipher.index(c0)        pos1 = cipher.index(c1)        # 遍历可能的字符组合        for i0 in range(len(table)):            for i1 in range(len(table)):                if i0 == i1:                    continue                try:                    a = (c1 - c0) * inverse(i1 - i0, m) % m                    b = (c0 - a * i0) % m                except:                    continue                # 检查a和b范围                if not (1145140 &lt;= a &lt;= 19198100):                    continue                if not (1145140 &lt;= b &lt;= 19198100):                    continue                # 解密全部                try:                    inv_a = inverse(a, m)                    flag = []                    valid = True                    for c in cipher:                        numerator = (c - b) % m                        m_idx = (numerator * inv_a) % m                        if not (0 &lt;= m_idx &lt; len(table)):                            valid = False                            break                        flag.append(table[m_idx])                    if valid:                        flag_str = &#x27;&#x27;.join(flag)                        print(f&quot;Possible flag: &#123;flag_str&#125;&quot;)                        return                except:                    continue    print(&quot;Failed to decrypt&quot;)# 测试table = string.ascii_letters + string.digitsm = 19198111# 测试数据cipher = [13690524, 13690524, 8208775, 19180266, 13690524, 8208775, 5407953, 19124315, 10913681, 13634573, 2663082, 19132308, 8160817, 19124315, 16387437, 5423939, 19124315, 13650559, 13650559, 8160817, 2663082, 8144831, 16387437, 16379444, 13634573, 2679068, 8160817, 16395430, 13650559, 13690524, 5471897, 13690524, 5471897, 13698517, 13690524, 2719033]solve(cipher, table, m)





choice原题：
from Crypto.Util.number import bytes_to_longfrom random import Randomfrom secret import flagassert flag.startswith(b&#x27;XYCTF&#123;&#x27;) and flag.endswith(b&#x27;&#125;&#x27;)flag = flag[6:-1]msg = bytes_to_long(flag)rand = Random()test = bytes([i for i in range(255, -1, -1)])open(&#x27;output.py&#x27;, &#x27;w&#x27;).write(f&#x27;enc = &#123;msg ^ rand.getrandbits(msg.bit_length())&#125;\nr = &#123;[rand.choice(test) for _ in range(2496)]&#125;&#x27;)

题中还给了一份random.py的附件，改了第246行，变成了k&#x3D;n.bit_length()-1
这意味着什么？意味着他会输出8位的随机数，也就是0到255，其实还是MT19937，看来得抽空系统的学学这个了，并且到明出几个题玩玩
回到正题：至于为什么变成8位就好解密的多，那是因为题中说了0到255的索引，并且是2496次，那意味着我们
可以得出624位已知数，这样就能破解次伪随机数，进而解密。哦，对了，要饭转一下才能推出已知数，然后破解：
这里还是MT19937，伪随机数算法的缺陷，2496*8&#x3D;19968刚好够一轮state，注意到我们这里需要的是逆推上一个state(相当于反向预测吧)
所以r需要取反处理一下
参考：XYCTF2025-WriteUp | HvAng’s Nests
题解：
# sageimport sys# https://github.com/JuliaPoo/MT19937-Symbolic-Execution-and-Solversys.path.append(&#x27;MT19937-Symbolic-Execution-and-Solver-master/source&#x27;)from MT19937 import MT19937from Crypto.Util.number import *enc = 5042764371819053176884777909105310461303359296255297length = enc.bit_length()print(length)r = []r = [255-i for i in r]rng_clone = MT19937(state_from_data = (r, 8))def getrandbits(n):    num = 0    for i in range(n//32):        num = (rng_clone() &lt;&lt; (32 * i)) | num    num = rng_clone() &gt;&gt; (32 - (n % 32)) &lt;&lt; n//32*32 | num    return numrng_clone.reverse_states(length//32+1)  # 回退到生成前n个随机数之前的状态flag = enc ^^ getrandbits(176-1)    # 172/8=21.5,22*8=176,可能存在误差所以减1试试flag = b&#x27;XYCTF&#123;&#x27;+long_to_bytes(flag)+b&#x27;&#125;&#x27;print(flag.decode())# XYCTF&#123;___0h_51mple_r@nd0m___&#125;





复复复数原题：
class ComComplex:    def __init__(self, value=[0,0,0,0]):        self.value = value    def __str__(self):        s = str(self.value[0])        for k,i in enumerate(self.value[1:]):            if i &gt;= 0:                s += &#x27;+&#x27;            s += str(i) +&#x27;ijk&#x27;[k]        return s    def __add__(self,x):        return ComComplex([i+j for i,j in zip(self.value,x.value)])    def __mul__(self,x):        a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3]        b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2]        c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1]        d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0]        return ComComplex([a,b,c,d])    def __mod__(self,x):        return ComComplex([i % x for i in self.value])    def __pow__(self, x, n=None):        tmp = ComComplex(self.value)        a = ComComplex([1,0,0,0])        while x:            if x &amp; 1:                a *= tmp            tmp *= tmp            if n:                a %= n                tmp %= n            x &gt;&gt;= 1        return afrom Crypto.Util.number import *from secret import flag, hintp = getPrime(256)q = getPrime(256)r = getPrime(256)n = p * q * rP = getPrime(512)assert len(hint) == 20hints = ComComplex([bytes_to_long(hint[i:i+5]) for i in range(0,20,5)])keys = ComComplex([0, p, q, r])print(&#x27;hint =&#x27;,hints)print(&#x27;gift =&#x27;,hints*keys%P)print(&#x27;P =&#x27;,P)e = 65547m = ComComplex([bytes_to_long(flag[i:i+len(flag)//4+1]) for i in range(0,len(flag),len(flag)//4+1)])c = pow(m, e, n)print(&#x27;n =&#x27;, n)print(&#x27;c =&#x27;, c)&#x27;&#x27;&#x27;hint = 375413371936+452903063925i+418564633198j+452841062207kgift = 8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729+20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171i+22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868j+40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863kP = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367c = 212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103+24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825i+45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125j+96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385k&#x27;&#x27;&#x27;



这个题，先看这个
print(&#x27;gift =&#x27;,hints*keys%P)

将数据联系起来。
看它定义的四元数的加减乘除运算规则。我们在只有未知量keys不知道的情况下可以，通过运算求出keys，进而求出pqr，然后就是求四数RSA了，u1s1我不咋会，大概有个印象，好像就是要开根，贴贴别人的文章
[2025 XYCTF - weyung](https://blog.weyung.cc/2025/04/04/2025 XYCTF&#x2F;#Crypto)
XYCTF 2025 部分题目Write Up | Triode Field
题解：
from sage.all import *from Crypto.Util.number import long_to_bytesh = [375413371936, 452903063925, 418564633198, 452841062207]g = [8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729, 20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171, 22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868, 40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863]P = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367H = matrix(Zmod(P),[[h[0], h[1], h[2], h[3]],[-h[1], h[0], -h[3], h[2]],[-h[2], h[3], h[0], -h[1]],[-h[3], -h[2], h[1], h[0]]])G = matrix(Zmod(P),[[g[0], g[1], g[2], g[3]],[-g[1], g[0], -g[3], g[2]],[-g[2], g[3], g[0], -g[1]],[-g[3], -g[2], g[1], g[0]]])K = H^-1 * G_, p, q, r = K[0]assert ZZ(p) * ZZ(q) * ZZ(r) == np, q, r = ZZ(p), ZZ(q), ZZ(r)print(p)print(q)print(r)c = [212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103, 24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825, 45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125, 96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385]C = matrix(Zmod(n),[[c[0], c[1], c[2], c[3]],[-c[1], c[0], -c[3], c[2]],[-c[2], c[3], c[0], -c[1]],[-c[3], -c[2], c[1], c[0]]])e = 65547phi = (p**4 - 1)*(q**4 - 1)*(r**4 - 1)//27d = inverse_mod(e, phi)M = C^dres = M[0]flag = b&quot;&quot;for x in res:    flag += long_to_bytes(ZZ(x))print(flag)b&#x27;flag&#123;Quaternion_15_ComComComComplexXXX!!!?&#125;&#x27;

]]></content>
      <categories>
        <category>CTF</category>
        <category>密码</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title>2024BaseCTF（re）</title>
    <url>/2025/07/15/2024basectf%EF%BC%88re%EF%BC%89/</url>
    <content><![CDATA[2024basectf（re）1.You are good at IDA![](屏幕截图 2025-04-15 131137.png)
用IDA打开文件，找到main先f5一下，然后再发现它让你shift+f12，所以试试，然后得到：
![](屏幕截图 2025-04-15 130555.png)
发现this is the second part，点击它，然后R之后，发现没有能R的东西，但是我们发现：DATA XREF:显示了哪个函数使用了这个字符串，双击可以跳转到那个函数，然后R。
![](屏幕截图 2025-04-15 132125.png)
然后，发现他告诉你最后一个在Interesting，找到它然后R
![](屏幕截图 2025-04-15 131604.png)
得到flag：BaseCTF{Y0u_4Re_900d_47_id4}
2.UPX miniupx脱壳然后在ida里f5（反编译），然后发现这样：   &#x2F;&#x2F;至于为什么要先脱壳，那是因为，我搜到的用upx就是先脱壳，哦，忘了脱壳图片了，现在贴吧：
![](屏幕截图 2025-04-15 134839.png)
![](屏幕截图 2025-04-15 134542.png)
然后发现了一个base64格式的数据，&#x3D;&#x3D;填充了，直接解码：
![](屏幕截图 2025-04-15 134623.png)
得出flag：BaseCTF{Hav3_@_g0od_t1m3!!!}
3.ez_maze(还没会)（现在会了）f5:然后发现自己不会，问完ai，继续看wp：
![](屏幕截图 2025-04-15 210900.png)
然后这是c语言代码，开始读代码，u1s1有点看不懂，所以我问ai了，这是一个15*15的迷宫，然后我们shift+e导出数据，导出了一个文件export_results.txt。是迷宫的数据，hex的ASCII文件。然后解码定行长整理后成这样：
这是工具：文本行定长 - 锤子在线工具
x $ $ $ $ $ $ $ $ $ $ $ $ $ $ &amp; &amp; &amp; &amp; &amp; &amp; $ $ $ $ $ $ $ $ $ &amp; $ &amp; $ $ &amp; $ $ &amp; &amp; &amp; &amp; &amp; $ $ &amp; $ &amp; $ $ $ &amp; &amp; $ $ $ $ &amp; $ $ &amp; $ $ $ &amp; &amp; &amp; $ $ $ $ $ &amp; $ $ &amp; $ $ $ &amp; $ &amp; &amp; $ &amp; $ $ $ $ $ &amp; $ $ $ &amp; $ &amp; $ $ &amp; &amp; &amp; $ $ $ &amp; &amp; &amp; &amp; &amp; $ &amp; &amp; &amp; &amp; $ &amp; $ $ $ $ $ $ $ $ $ &amp; &amp; &amp; &amp; &amp; &amp; $ $ $ $ $ $ $ $ $ &amp; $ $ $ $ $ $ $ $ $ $ $ &amp; &amp; &amp; &amp; $ $ &amp; &amp; &amp; $ $ $ $ $ $ &amp; &amp; &amp; &amp; &amp; &amp; &amp; $ $ $ $ $ $ $ $ $ $ $ $ $ $ &amp; $ $ &amp; $ $ $ $ $ $ $ $ $ $ $ &amp; $ &amp; $ $ $ $ $ $ $ $ $ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; y 

然后找到最短路径：sssssssddddwwwddsssssssdddsssddddd
之后发现一点思路没有，然后问了问Beck_，好像是因为自己没找到，然后再找找发现了：
![](屏幕截图 2025-05-08 202140.png)
找到了他说让我md5一下（别骂我，我刚开始学re），这是工具MD5在线加密&#x2F;解密&#x2F;破解—MD5在线
解密出：131b7d6e60e8a34cb01801ae8de07efe
得出flag:BaseCTF{131b7d6e60e8a34cb01801ae8de07efe}
4.BasePlus先看函数都用了啥：
![](屏幕截图 2025-05-09 020848.png)
布拉布拉说了一堆，大概意思就是让我们根据密文解密解出flag，至于为什么是密文呢？因为我是学密码的大概能看出是密文，然后我直接base了，然后乱码，额，开看wp
发现她的encode函数：
![](屏幕截图 2025-05-09 020836.png)
对base64的结果进行了异或0xE，哦然后就简单了，我们直接先对密文异或回来，然后base64。base64失败，看到了他给的码表，以码表格式base64成功得出flag：
To Base64, XOR, From Base64 - CyberChef
![](屏幕截图 2025-05-09 021632.png)
BaseCTF{BA5e_DEcoD1N6_sEcr3t}
5.ez_xor一个异或解密
秘钥：

v4 = 7499608（十六进制为0x00727F58）
密钥字节：key = [0x58, 0x7F, 0x72]

，秘钥流生成：
key_stream[i] &#x3D; i ^ key[i % 3]
对于位置i，使用密钥字节key[i % 3]与索引i异或
加密过程：
encrypted[i] &#x3D; flag[i] ^ key_stream[27 - i]
用户输入的每个字节与密钥流中对称位置的字节异或
目标字符串：

28字节的固定值（从代码中提取）

要获取flag就去执行逆过程：
flag[i] &#x3D; encrypted[i] ^ key_stream[27 - i]
主函数：

秘钥流：

加密函数：

python脚本：
def main():    # 目标加密字符串（从反汇编代码中提取）    encrypted_data = bytes([        0x01, 0x09, 0x05, 0x25, 0x26, 0x2D, 0x0B, 0x1D,         0x24, 0x7A, 0x31, 0x20, 0x1E, 0x49, 0x3D, 0x67,        0x4D, 0x50, 0x08, 0x25, 0x2E, 0x6E, 0x05, 0x34,        0x22, 0x40, 0x3B, 0x25    ])        # 初始密钥（来自v4 = 7499608）    v4 = 7499608    key_bytes = bytes([v4 &amp; 0xFF, (v4 &gt;&gt; 8) &amp; 0xFF, (v4 &gt;&gt; 16) &amp; 0xFF])        print(&quot;=&quot;*50)    print(&quot;逆向解密过程详解&quot;)    print(&quot;=&quot;*50)    print(f&quot;1. 从 v4 = 7499608 (0x&#123;v4:08X&#125;) 提取密钥字节&quot;)    print(f&quot;   key_bytes = [&#123;&#x27;, &#x27;.join(f&#x27;0x&#123;b:02X&#125;&#x27; for b in key_bytes)&#125;]&quot;)        # 生成密钥流    key_stream = []    print(&quot;\n2. 生成密钥流 (key_stream[i] = i ^ key_bytes[i % 3]):&quot;)    for i in range(len(encrypted_data)):        key_index = i % 3        key_byte = key_bytes[key_index]        ks_byte = i ^ key_byte        key_stream.append(ks_byte)        print(f&quot;   i=&#123;i:2d&#125;, key_index=&#123;key_index&#125;, key_byte=0x&#123;key_byte:02X&#125;, &quot;              f&quot;ks_byte = &#123;i:2d&#125; ^ 0x&#123;key_byte:02X&#125; = 0x&#123;ks_byte:02X&#125;&quot;)        # 逆向计算flag    flag = []    print(&quot;\n3. 计算flag (flag[i] = encrypted[i] ^ key_stream[27-i]):&quot;)    for i in range(len(encrypted_data)):        reverse_index = len(encrypted_data) - 1 - i        key_byte = key_stream[reverse_index]        enc_byte = encrypted_data[i]        flag_byte = enc_byte ^ key_byte        flag.append(flag_byte)        print(f&quot;   i=&#123;i:2d&#125;, rev_i=&#123;reverse_index:2d&#125;, &quot;              f&quot;enc=0x&#123;enc_byte:02X&#125;, key=0x&#123;key_byte:02X&#125;, &quot;              f&quot;flag_char=0x&#123;flag_byte:02X&#125; (&#x27;&#123;chr(flag_byte)&#125;&#x27;)&quot;)        # 转换为字符串    flag_str = &#x27;&#x27;.join(chr(b) for b in flag)        print(&quot;\n&quot; + &quot;=&quot;*50)    print(&quot;最终结果&quot;)    print(&quot;=&quot;*50)    print(f&quot;解密后的Flag: &#123;flag_str&#125;&quot;)        # 验证过程    print(&quot;\n&quot; + &quot;=&quot;*50)    print(&quot;验证过程&quot;)    print(&quot;=&quot;*50)    print(&quot;重新加密flag以验证是否匹配目标字符串:&quot;)        # 重新加密    re_encrypted = []    for i in range(len(flag)):        reverse_index = len(flag) - 1 - i        key_byte = key_stream[reverse_index]        enc_byte = flag[i] ^ key_byte        re_encrypted.append(enc_byte)        match = &quot;✓&quot; if enc_byte == encrypted_data[i] else &quot;✗&quot;        print(f&quot;   i=&#123;i:2d&#125;, flag_char=&#x27;&#123;chr(flag[i])&#125;&#x27;, &quot;              f&quot;key=0x&#123;key_byte:02X&#125;, enc=0x&#123;enc_byte:02X&#125;, &quot;              f&quot;target=0x&#123;encrypted_data[i]:02X&#125; &#123;match&#125;&quot;)        if bytes(re_encrypted) == encrypted_data:        print(&quot;\n验证成功! 重新加密结果与目标字符串完全匹配&quot;)    else:        print(&quot;\n验证失败! 请检查解密过程&quot;)if __name__ == &quot;__main__&quot;:    main()

flag：BaseCTF{X0R_I5_345Y_F0r_y0U}
6.UPX脱壳后发现只有start，然后用010看到内部结构将小写改为大写再脱壳，得到exe分析

脱壳然后：

b64函数：

map中这个：

找到映射表，然后写代码解密：

# 自定义Base64解码实现 - 用于逆向工程中的特殊Base64编码# 从工具中提取的自定义Base64映射表（前64个字符）# 注意：原始字符串中有重复字符（如&#x27;A&#x27;），可能需要手动调整custom_b64_map = &quot;A,.1fgvw#`/2ehux$~\&quot;3dity%_;4cjsz^+&#123;5bkrA&amp;=&#125;6alqB*-[70mpC()]89noX&quot;[:64]# 标准Base64映射表（用于参考和转换）standard_b64_map = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;# 构建反向映射表：将自定义字符映射到标准Base64的索引位置# 例如：若自定义表中&#x27;$&#x27;在位置0，则reverse_map[&#x27;$&#x27;] = 0reverse_map = &#123;c: i for i, c in enumerate(custom_b64_map)&#125;def custom_b64decode(ciphertext):    &quot;&quot;&quot;    使用自定义映射表解码Base64字符串        步骤：    1. 将每个自定义字符转换为对应的6位二进制值    2. 将所有6位二进制片段连接成完整的二进制字符串    3. 将二进制字符串按每8位分割，转换为字节数据    4. 尝试将字节数据解码为ASCII字符串    &quot;&quot;&quot;    # 存储所有6位二进制片段的连接结果    bits = &quot;&quot;        # 遍历密文中的每个字符    for c in ciphertext:        # 检查字符是否在自定义映射表中        if c in reverse_map:            # 将字符转换为对应的6位二进制值（补前导零）            # 例如：索引0 -&gt; &#x27;000000&#x27;, 索引1 -&gt; &#x27;000001&#x27;, 依此类推            bits += f&quot;&#123;reverse_map[c]:06b&#125;&quot;        # 存储解码后的字节数据    bytes_data = bytearray()        # 将二进制字符串按每8位分割，转换为字节    for i in range(0, len(bits), 8):        byte = bits[i:i+8]        # 确保每次处理完整的8位（最后一组可能不足8位，需忽略）        if len(byte) == 8:            bytes_data.append(int(byte, 2))        # 尝试将字节数据解码为ASCII字符串（CTF中常见的flag格式）    # 注意：如果flag包含非ASCII字符，这里可能需要尝试其他编码    return bytes_data.decode(&#x27;ascii&#x27;)# 待解码的目标密文（从逆向工程中获取）ciphertext = &quot;$rg7_dhd~Alidg+zeyhz`vnz_d,7sy0=&quot;# 调用自定义解码函数plaintext = custom_b64decode(ciphertext)# 输出解码结果print(plaintext)# 验证是否符合常见的CTF flag格式# 例如：BaseCTF&#123;...&#125;, CTF&#123;...&#125;, flag&#123;...&#125;等# 注意：需根据具体题目要求调整验证逻辑

flag: BaseCTF{UPX_1s_$o_e@sy})
7.lk对于这种超复杂的线性方程，我们可以用python的z3solver库解决
打断点调试：


from z3 import *# 定义未知数a = [Int(&#x27;a[%d]&#x27; % i) for i in range(21)]# 创建求解器s = Solver()# 添加加权和的条件s.add(948 * a[20]     + 887 * a[19]     + 410 * a[18]     + 978 * a[17]     + 417 * a[16]     + 908 * a[15]     + 965 * a[14]     + 987 * a[13]     + 141 * a[12]     + 257 * a[11]     + 323 * a[10]     + 931 * a[9]     + 773 * a[8]     + 851 * a[7]     + 758 * a[6]     + 891 * a[5]     + 575 * a[4]     + 616 * a[3]     + 860 * a[2]     + 283 * a[1] == 913686)s.add( 938 * a[20]     + 490 * a[19]     + 920 * a[18]     + 50 * a[17]     + 568 * a[16]     + 68 * a[15]     + 35 * a[14]     + 708 * a[13]     + 938 * a[12]     + 718 * a[11]     + 589 * a[10]     + 954 * a[9]     + 974 * a[8]     + 62 * a[7]     + 580 * a[6]     + 80 * a[5]     + 111 * a[4]     + 151 * a[3]     + 421 * a[2]     + 148 * a[1] == 630335)s.add( 908 * a[20]     + 590 * a[19]     + 668 * a[18]     + 222 * a[17]     + 489 * a[16]     + 335 * a[15]     + 778 * a[14]     + 622 * a[13]     + 95 * a[12]     + 920 * a[11]     + 932 * a[10]     + 892 * a[9]     + 409 * a[8]     + 392 * a[7]     + 11 * a[6]     + 113 * a[5]     + 948 * a[4]     + 674 * a[3]     + 506 * a[2]     + 182 * a[1] == 707525)s.add( 479 * a[20]     + 859 * a[19]     + 410 * a[18]     + 399 * a[17]     + 891 * a[16]     + 266 * a[15]     + 773 * a[14]     + 624 * a[13]     + 34 * a[12]     + 479 * a[11]     + 465 * a[10]     + 728 * a[9]     + 447 * a[8]     + 427 * a[7]     + 890 * a[6]     + 570 * a[5]     + 716 * a[4]     + 180 * a[3]     + 571 * a[2]     + 707 * a[1] == 724203)s.add( 556 * a[20]     + 798 * a[19]     + 380 * a[18]     + 716 * a[17]     + 71 * a[16]     + 901 * a[15]     + 949 * a[14]     + 304 * a[13]     + 142 * a[12]     + 679 * a[11]     + 459 * a[10]     + 814 * a[9]     + 282 * a[8]     + 49 * a[7]     + 873 * a[6]     + 169 * a[5]     + 437 * a[4]     + 199 * a[3]     + 771 * a[2]     + 807 * a[1] == 688899)s.add( 465 * a[20]     + 898 * a[19]     + 979 * a[18]     + 198 * a[17]     + 156 * a[16]     + 831 * a[15]     + 856 * a[14]     + 322 * a[13]     + 25 * a[12]     + 35 * a[11]     + 369 * a[10]     + 917 * a[9]     + 522 * a[8]     + 654 * a[7]     + 235 * a[6]     + 385 * a[5]     + 469 * a[4]     + 231 * a[3]     + 496 * a[2]     + 83 * a[1] == 604784)s.add( 305 * a[20]     + 928 * a[19]     + 260 * a[18]     + 793 * a[17]     + 787 * a[16]     + 708 * a[15]     + 758 * a[14]     + 236 * a[13]     + 688 * a[12]     + 747 * a[11]     + 711 * a[10]     + 195 * a[9]     + 50 * a[8]     + 648 * a[7]     + 787 * a[6]     + 376 * a[5]     + 220 * a[4]     + 33 * a[3]     + 194 * a[2]     + 585 * a[1] == 665485)s.add( 767 * a[20]     + 573 * a[19]     + 22 * a[18]     + 909 * a[17]     + 598 * a[16]     + 588 * a[15]     + 136 * a[14]     + 848 * a[12]     + 964 * a[11]     + 311 * a[10]     + 701 * a[9]     + 653 * a[8]     + 541 * a[7]     + 443 * a[6]     + 7 * a[5]     + 976 * a[4]     + 803 * a[3]     + 273 * a[2]     + 859 * a[1] == 727664)s.add( 776 * a[20]     + 59 * a[19]     + 507 * a[18]     + 164 * a[17]     + 397 * a[16]     + 744 * a[15]     + 377 * a[14]     + 768 * a[13]     + 456 * a[12]     + 799 * a[11]     + 9 * a[10]     + 215 * a[9]     + 365 * a[8]     + 181 * a[7]     + 634 * a[6]     + 818 * a[5]     + 81 * a[4]     + 236 * a[3]     + 883 * a[2]     + 95 * a[1] == 572015)s.add( 873 * a[20]     + 234 * a[19]     + 381 * a[18]     + 423 * a[17]     + 960 * a[16]     + 689 * a[15]     + 617 * a[14]     + 240 * a[13]     + 933 * a[12]     + 300 * a[11]     + 998 * a[10]     + 773 * a[9]     + 484 * a[8]     + 905 * a[7]     + 806 * a[6]     + 792 * a[5]     + 606 * a[4]     + 942 * a[3]     + 422 * a[2]     + 789 * a[1] == 875498)s.add( 766 * a[20]     + 7 * a[19]     + 283 * a[18]     + 900 * a[17]     + 211 * a[16]     + 305 * a[15]     + 343 * a[14]     + 696 * a[13]     + 590 * a[12]     + 736 * a[11]     + 817 * a[10]     + 603 * a[9]     + 414 * a[8]     + 828 * a[7]     + 114 * a[6]     + 845 * a[5]     + 175 * a[4]     + 212 * a[3]     + 898 * a[2]     + 988 * a[1] == 714759)s.add( 220 * a[20]     + 30 * a[19]     + 788 * a[18]     + 106 * a[17]     + 574 * a[16]     + 501 * a[15]     + 366 * a[14]     + 952 * a[13]     + 121 * a[12]     + 996 * a[11]     + 735 * a[10]     + 689 * a[9]     + 998 * a[8]     + 689 * a[7]     + 729 * a[6]     + 886 * a[5]     + 860 * a[4]     + 70 * a[3]     + 466 * a[2]     + 961 * a[1] == 778853)s.add( 313 * a[20]     + 748 * a[19]     + 522 * a[18]     + 864 * a[17]     + 156 * a[16]     + 362 * a[15]     + 283 * a[14]     + 49 * a[13]     + 316 * a[12]     + 79 * a[11]     + 136 * a[10]     + 299 * a[9]     + 271 * a[8]     + 604 * a[7]     + 907 * a[6]     + 540 * a[5]     + 141 * a[4]     + 620 * a[3]     + 701 * a[2]     + 866 * a[1] == 584591)s.add( 922 * a[20]     + 399 * a[19]     + 425 * a[18]     + 26 * a[17]     + 159 * a[16]     + 224 * a[15]     + 438 * a[14]     + 770 * a[13]     + 144 * a[12]     + 406 * a[11]     + 110 * a[10]     + 991 * a[9]     + 749 * a[8]     + 701 * a[7]     + 646 * a[6]     + 147 * a[5]     + 979 * a[4]     + 674 * a[3]     + 999 * a[2]     + 913 * a[1] == 717586)s.add( 13 * a[20]     + 537 * a[19]     + 225 * a[18]     + 421 * a[17]     + 153 * a[16]     + 484 * a[15]     + 654 * a[14]     + 743 * a[13]     + 779 * a[12]     + 74 * a[11]     + 325 * a[10]     + 439 * a[9]     + 797 * a[8]     + 41 * a[7]     + 784 * a[6]     + 269 * a[5]     + 454 * a[4]     + 725 * a[2]     + 164 * a[1] == 537823)s.add( 591 * a[20]     + 210 * a[19]     + 874 * a[18]     + 204 * a[17]     + 485 * a[16]     + 42 * a[15]     + 433 * a[14]     + 176 * a[13]     + 436 * a[12]     + 634 * a[11]     + 82 * a[10]     + 978 * a[9]     + 818 * a[8]     + 683 * a[7]     + 404 * a[6]     + 562 * a[5]     + 41 * a[4]     + 789 * a[3]     + 200 * a[2]     + 220 * a[1] == 587367)s.add( 584 * a[20]     + 597 * a[19]     + 928 * a[18]     + 532 * a[17]     + 902 * a[16]     + 858 * a[15]     + 820 * a[14]     + 240 * a[13]     + 124 * a[12]     + 899 * a[11]     + 848 * a[10]     + 822 * a[9]     + 409 * a[8]     + 491 * a[7]     + 587 * a[6]     + 715 * a[5]     + 410 * a[4]     + 268 * a[3]     + 721 * a[2]     + 915 * a[1] == 842245)s.add( 421 * a[20]     + 302 * a[19]     + 327 * a[18]     + 180 * a[17]     + a[16] * 512     + 160 * a[15]     + 623 * a[14]     + 28 * a[13]     + 411 * a[12]     + 53 * a[11]     + 633 * a[10]     + 560 * a[9]     + 623 * a[8]     + 477 * a[7]     + 901 * a[6]     + 287 * a[5]     + 149 * a[4]     + 726 * a[3]     + 934 * a[2]     + 875 * a[1] == 610801)s.add( 838 * a[20]     + 434 * a[19]     + 792 * a[18]     + 649 * a[17]     + 462 * a[16]     + 170 * a[15]     + 980 * a[14]     + 15 * a[13]     + 295 * a[12]     + 495 * a[11]     + 666 * a[10]     + 934 * a[9]     + 17 * a[8]     + 69 * a[7]     + 367 * a[6]     + 780 * a[5]     + 291 * a[4]     + 834 * a[3]     + 587 * a[2]     + 133 * a[1] == 653127)s.add( 41 * a[20]     + 422 * a[19]     + 420 * a[18]     + 224 * a[17]     + 475 * a[16]     + 854 * a[15]     + 233 * a[14]     + 179 * a[13]     + 620 * a[12]     + 69 * a[11]     + 42 * a[10]     + 684 * a[9]     + 300 * a[8]     + 745 * a[7]     + 894 * a[6]     + 554 * a[5]     + 495 * a[4]     + 66 * a[3]     + 316 * a[2]     + 391 * a[1] == 533470 )# 在求解器中添加字节的范围限制：0到255for i in range(1, 21):    s.add(a[i] &gt;= 0, a[i] &lt;= 255)# 检查是否有解if s.check() == sat:    model = s.model()    result = &#x27;&#x27;.join([chr(model[a[i]].as_long()) for i in range(1, 21)])    print(&quot;解是:&quot;, result)else:    print(&quot;没有解&quot;)



flag:  BaseCTF{CDBBDCAAABBDBCCBCCAC}
8.喝杯下午茶主函数可以在这里找：



大概是这样：

v5是key，v6是密文
def decrypt_block(left, right, key):    k0, k1, k2, k3 = key    delta = 1131796    total_delta = 32 * delta    for _ in range(32):        right = (right - ((k3 + (left &gt;&gt; 5)) ^ (left + total_delta) ^ (k2 + (left &lt;&lt; 4)))) &amp; 0xFFFFFFFF        left = (left - ((k1 + (right &gt;&gt; 5)) ^ (right + total_delta) ^ (k0 + (right &lt;&lt; 4)))) &amp; 0xFFFFFFFF        total_delta -= delta    return left, right# Key and ciphertextkey = [0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF11]ciphertext = [    0x94B1F1E7, 0x21D5D352,    0x5247793D, 0x040D1C97,    0xF36E7F74, 0x9C53F70F,    0x6AEACFD8, 0x6F9F06F4,    0xEAFD9E2E, 0x32B655F7]# Decrypt each blockflag = b&quot;&quot;for i in range(0, 10, 2):    left, right = ciphertext[i], ciphertext[i+1]    dec_left, dec_right = decrypt_block(left, right, key)    flag += dec_left.to_bytes(4, &#x27;little&#x27;)    flag += dec_right.to_bytes(4, &#x27;little&#x27;)print(flag.decode())

flag: BaseCTF{h3r3_4_cuP_0f_734_f0R_y0U!!!!!!}
9.Ezpy可以用网址：https://tool.lu/   这个里的来解pyc
先转exe为pyc，再把pyc反编译成py。使用方法放到G:\Agent\Cybersecurity\reverse\un_python_gui了

一个简单的RC4加密解密
key = &#x27;yOU_f1nd_m3&#x27;keykey = [66, 97, 115, 101]  # 对应 &#x27;Base&#x27; 的 ASCII 码enc = b&#x27;\xe6\xaeC~F\xf2\xe3\xbb\xac\x9a-\x02U\x85p\xeb\x19\xd1\xe4\xc93sG\xb0\xeb1\xb5\x05\x05\xc3\xd7\x00\x18+D\xbc\x0cO\x9em\xf1\xbd&#x27;def init_Sbox(seed):    k_b = [ord(seed[i % len(seed)]) for i in range(256)]    s = list(range(256))    j = 0    for i in range(256):        j = (j + s[i] + k_b[i]) % 256        s[i], s[j] = s[j], s[i]    return sdef KeyStream(length, Sbox):    s = Sbox.copy()    i, j = 0, 0    k = [0] * length    for r in range(length):        i = (i + 1) % 256        j = (j + s[i]) % 256        s[i], s[j] = s[j], s[i]        t = (s[i] + s[j]) % 256        k[r] = s[t] ^ keykey[r % len(keykey)]    return kdef decrypt(ciphertext, seed):    Sbox = init_Sbox(seed)    key = KeyStream(len(ciphertext), Sbox)    dec = [ciphertext[i] ^ key[i] for i in range(len(ciphertext))]    return bytes(dec)# 执行解密flag_bytes = decrypt(enc, key)try:    flag = flag_bytes.decode(&#x27;utf-8&#x27;)    print(&quot;Flag:&quot;, flag)except UnicodeDecodeError:    print(&quot;无法以UTF-8解码，原始字节:&quot;, flag_bytes)    print(&quot;尝试其他编码或查看字节内容...&quot;)

flag：BaseCTF{Y0u_kn0W_d3C0Mp1l4710N_PY_4ND_rC4}
10.最简单的编码先看主要逻辑：

base换表和编码索引值+
获得魔改base，编码索引值+了那我们就减回去就行了


table = &quot;CDABGHEFKLIJOPMNSTQRWXUVabYZefcdijghmnklqropuvstyzwx23016745+/89&quot;enc = &quot;TqK1YUSaQryEMHaLMnWhYU+Fe0WPenqhRXahfkV6WE2fa3iRW197Za62eEaD&quot;index = []number = [1,2,3,4]for i in range(len(enc)):    tmp = table.index(enc[i]) - number[i % 4]    if tmp &gt;= 0:        index.append(tmp)    else:        index.append(tmp + 64)print(index)for i in range(0,len(index),4):    a = index[i]    b = index[i + 1]    c = index[i + 2]    d = index[i + 3]    sum = a &lt;&lt; 18 | b &lt;&lt; 12 | c &lt;&lt; 6 | d    for j in range(3):        print(chr((sum &gt;&gt; ((2 - j) * 8)) &amp; 0xff),end=&quot;&quot;)

flag：  BaseCTF{B45E64_eNCoDIn9_I5_rE4LLY_7OO_5implE}
&#x3D;&#x3D;最终这个题我还是没做出来，因为环境问题：&#x3D;&#x3D;



11.neuro爱数学主要逻辑：

逆向这个就可以了，然后我们扔给ai得到：x1到x9，然后再喂一下子就可以：
import numpy as npdef main():    # 定义多项式的根    roots = [44, 58, 17, 6, 5, -4, -9, -37]        # 从根构建多项式    poly_coeffs = np.poly(roots)        # 将系数四舍五入为整数    integer_coeffs = [int(round(coeff)) for coeff in poly_coeffs]        # 验证关键系数    assert integer_coeffs[0] == 1, f&quot;i^8 系数应为 1，实际为 &#123;integer_coeffs[0]&#125;&quot;    assert integer_coeffs[1] == -80, f&quot;i^7 系数应为 -80，实际为 &#123;integer_coeffs[1]&#125;&quot;    assert integer_coeffs[2] == -358, f&quot;i^6 系数应为 -358，实际为 &#123;integer_coeffs[2]&#125;&quot;        # 反转后的系数    reversed_coeffs = integer_coeffs[::-1]        # 打印多项式信息    print(&quot;多项式根:&quot;, roots)    print(&quot;多项式形式: P(i) = (i-44)(i-58)(i-17)(i-6)(i-5)(i+4)(i+9)(i+37)&quot;)        # 打印原始系数    print(&quot;\n多项式系数 (从最高次项到常数项):&quot;)    for i, coeff in enumerate(integer_coeffs):        print(f&quot;i^&#123;8-i&#125; 的系数: &#123;coeff&#125;&quot;)        # 打印反转后的系数    print(&quot;\n反转后的多项式系数 (从常数项到最高次项):&quot;)    for i, coeff in enumerate(reversed_coeffs):        print(f&quot;i^&#123;i&#125; 的系数: &#123;coeff&#125;&quot;)        # 输出原始顺序的九个整数输入    print(&quot;\n原始顺序的九个整数输入:&quot;)    print(&quot; &quot;.join(str(coeff) for coeff in integer_coeffs))        # 输出反转顺序的九个整数输入    print(&quot;\n反转顺序的九个整数输入:&quot;)    print(&quot; &quot;.join(str(coeff) for coeff in reversed_coeffs))        # 提供复制方便的格式    print(&quot;\n复制以下内容直接输入到程序中 (原始顺序):&quot;)    print(f&quot;&#123;integer_coeffs[0]&#125; &#123;integer_coeffs[1]&#125; &#123;integer_coeffs[2]&#125; &#123;integer_coeffs[3]&#125; &#123;integer_coeffs[4]&#125; &#123;integer_coeffs[5]&#125; &#123;integer_coeffs[6]&#125; &#123;integer_coeffs[7]&#125; &#123;integer_coeffs[8]&#125;&quot;)        print(&quot;\n复制以下内容直接输入到程序中 (反转顺序):&quot;)    print(f&quot;&#123;reversed_coeffs[0]&#125; &#123;reversed_coeffs[1]&#125; &#123;reversed_coeffs[2]&#125; &#123;reversed_coeffs[3]&#125; &#123;reversed_coeffs[4]&#125; &#123;reversed_coeffs[5]&#125; &#123;reversed_coeffs[6]&#125; &#123;reversed_coeffs[7]&#125; &#123;reversed_coeffs[8]&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()


期间遇到了怎么绕过反反调试的问题，目前知道的解决办法：
1、改rax为0
2、在https://github.com/notify-bibi/ScyllaHide-IDA7.5/tree/0.2 下载绕过反反调试的插件
flag： BaseCTF{neuro_11AdD8_result_21_filtered_ajar_boxfan}
12.RivestCipher主函数：

加密：

解密：

注意，这个题用的ida9.1，之前的题用的ida7.6
flag: BaseCTF{go1@ng_!S_RuNNin9_RC4}
13.ezAndroid用jadx工具反编译apk得到Java程序：

读懂这一部分发现是调其他的部分，过程大概是这样：


然后放到ida发现，是取地址然后异或运算：相同为零，不同为一
提取一下，然后py代码逆一下：

a=open(&#x27;flag&#x27;,&#x27;rb&#x27;)f=a.read()m=[97, 54, 98, 52, 100, 52, 102, 101, 51, 52, 54, 49]for i in range(len(f)):     print(chr(f[i]^m[i%len(m)]),end=&#x27;&#x27;)



也可以用这种方法：

Java.perform(()=&gt;&#123;  let MainActivity = Java.use(&quot;com.example.hello.MainActivity&quot;);MainActivity[&quot;loadFlagFile&quot;].implementation = function (str) &#123;    console.log(`MainActivity.loadFlagFile is called: str=$&#123;str&#125;`);    let result = this[&quot;loadFlagFile&quot;](str);    console.log(`MainActivity.loadFlagFile result=$&#123;result&#125;`);    var A=Java.array(&#x27;byte&#x27;,result);    var B = this[&quot;Base64encode&quot;](A);    console.log(`MainActivity.loadFlagFile Base64encode result=$&#123;B&#125;`);    return result;&#125;;&#125;)



flag:  BaseCTF{28e1bf5b-5a8e-4f7d-9afd-3991dfb28453}
13.1额外知识点mobile
开启雷电模拟器root权限，启动frida服务（在mobile里）
然后运行上面那个脚本：
hook脚本是运行到包里的
然后用雷神模拟器输入任意内容就能出：

然后ASCII查一下就可以了：

flag:  BaseCTF{28e1bf5b-5a8e-4f7d-9afd-3991dfb28453}
14.出题人已疯用die发现是c++编译的.net：

然后：


找到关键方法，发现是三重异或
然后解密
解题逻辑：
我们已知以下信息：1. 密钥字符串 key_str 是由 sentences 数组中的所有字符串连接而成。2. 目标数组 array3 是一个 uint 数组，实际存储的是字符的 Unicode 编码（因为后面被转换为 char 数组）。3. 用户输入经过变换后与 array3 转换成的字符串进行比较。变换过程：   array[i] = (char)( ( (array[i] * array[i]) ) ^ i ^ (int)array2[i % array2.Length] )逆向过程：  设 T = array3 中第 i 个元素转换成的字符的 Unicode 值（即 target_chars[i] 的 ord）。  变换后的值 T 满足：      T = ( (input_char)² ) ^ i ^ key_char因此，我们需要计算：      (input_char)² = T ^ i ^ key_char然后开平方得到 input_char。注意：由于 input_char 是一个 char 类型，所以它的值在 0 到 65535 之间。开平方后取整，然后取整后的数值的平方应该等于计算出的值（否则可能出错，但根据算法，原始输入应该是可打印字符，所以通常不会超出范围）。步骤：1. 构造密钥字符串（key_str）。2. 将 array3 中的每个 uint 转换为字符，然后获取其 Unicode 码点（即整数）。3. 对于每个位置 i：      xor_triple = T_i ^ i ^ (key_str[i % len(key_str)] 的码点)      然后计算 sqrt(xor_triple)，四舍五入取整，得到原始字符的码点。4. 将码点转换为字符，连接起来得到 flag。注意：由于平方操作，原始字符的码点必须是一个整数，并且其平方必须在 0 到 65535 之间，所以原始字符的码点范围在 0 到 255 之间（因为 256*256=65536，超出 char 范围，所以实际上原始字符应该是 ASCII 或 Latin-1 字符，因为中文字符的码点较大，平方会溢出）。但实际上，array3 中的值都是小于 65536 的，所以原始字符的码点不会超过 255（因为平方后最大为 255^2=65025，小于65536）。因此，我们只需要考虑 0~255 的字符。但是，注意：变换后的值 T 是 char，所以 T 在 0~65535 之间，而 key_char 也是 char（0~65535），所以计算出的平方值（即 xor_triple）可能很大，但实际在逆向时，我们得到 xor_triple 后开平方，然后取整，再检查取整后的数值的平方是否等于 xor_triple（因为平方取整会有精度损失）。如果不相等，则说明该位置无解。但根据算法，正确的输入应该是有解的。编写完整代码：

import math# 定义干扰字符串数组（sentences）sentences = [    &quot;你以为我还会在乎吗？\ud83d\ude2c\ud83d\ude2c\ud83d\ude2c我在昆仑山练了六年的剑\ud83d\ude1f\ud83d\ude1f\ud83d\ude1f我的心早就和昆仑山的雪一样冷了\ud83d\ude10\ud83d\ude10\ud83d\ude10我在大润发杀了十年的鱼\ud83d\ude2b\ud83d\ude2b\ud83d\ude2b我以为我的心早已跟我的刀一样冷了\ud83d\ude29\ud83d\ude29\ud83d\ude29&quot;,    &quot;我早上坐公交滴卡的时候和司机大叔说“两个人”，司机惊讶地看着我“你明明就是一个人，为什么要滴两个人的卡？”我回他，“我心中还有一个叫Kengwang的。”司机回我说，“天使是不用收钱的。”&quot;,    &quot;（尖叫）（扭曲）（阴暗的爬行）（扭动）（阴暗地蠕动）（翻滚）（激烈地爬动）（痉挛）（嘶吼）（蠕动）（阴森的低吼）（爬行）（分裂）（走上岸）（扭曲的行走）（不分对象攻击）&quot;,    &quot;地球没我照样转？硬撑罢了！地球没我照样转？硬撑罢了！地球没我照样转？硬撑罢了！地球没我照样转？硬撑罢了！地球没我照样转？硬撑罢了！地球没我照样转？硬撑罢了！&quot;,    &quot;扭曲上勾拳！阴暗的下勾拳！尖叫左勾拳！右勾拳爬行！扭动扫堂腿！分裂回旋踢！这是蜘蛛阴暗的吃耳屎，这是龙卷风翻滚停车场！乌鸦痉挛！老鼠嘶吼！大象蠕动！愤怒的章鱼！无差别攻击！无差别攻击！无差别攻击！&quot;]# 连接所有干扰字符串形成密钥key_str = &#x27;&#x27;.join(sentences)key_chars = list(key_str)  # 转换为字符数组key_length = len(key_chars)# 目标验证数据（从 array3 复制）target_uint = [    24164, 27173, 32145, 17867, 40533, 21647, 17418, 30032, 27950, 62998,    60750, 64870, 52680, 61797, 49234, 59762, 16704, 19200, 32132, 24038,    21764, 30130, 28113, 23070, 27413, 27917, 28938, 50207, 64834, 60132,    64832, 63334, 55103, 22176, 21991, 20073, 22281, 19476, 28302, 24336,    24720, 19544, 23018, 43976]# 将目标 uint 数组转换为字符数组target_chars = [chr(x) for x in target_uint]# 逆向计算 flagflag_chars = []for i in range(len(target_chars)):    # 获取目标字符的 Unicode 码点    transformed_val = ord(target_chars[i])        # 获取对应位置的密钥字符    key_val = ord(key_chars[i % key_length])        # 逆向计算三重异或    # 原始公式: transformed_val = (input_char²) ^ i ^ key_val    # 因此: input_char² = transformed_val ^ i ^ key_val    xor_result = transformed_val ^ i ^ key_val        # 开平方逆向计算原始字符值    # 由于字符值必须是整数，四舍五入后取整    original_val = round(math.sqrt(xor_result))        # 验证计算结果是否有效    if original_val * original_val != xor_result:        # 如果验证失败，尝试寻找最接近的整数解        candidates = []        for candidate in range(max(0, original_val - 2), min(0xFFFF, original_val + 3)):            if candidate * candidate == xor_result:                candidates.append(candidate)                if candidates:            # 优先选择可打印字符            for cand in candidates:                if 32 &lt;= cand &lt;= 126:  # ASCII 可打印字符范围                    original_val = cand                    break            else:                original_val = candidates[0]  # 没有可打印字符则取第一个解        else:            # 没有精确解时使用近似值（这种情况在正确输入下不应发生）            print(f&quot;警告: 位置 &#123;i&#125; 无精确解，使用近似值 &#123;original_val&#125;&quot;)        # 将数值转换回字符    flag_chars.append(chr(original_val))# 组合最终 flagflag = &#x27;&#x27;.join(flag_chars)print(&quot;解密后的 Flag:&quot;, flag)





flag： BaseCTF{y0u_KnOw_UTF16_6uT_U_r_n0t_Cr@zym@n}
15.UPX PRO有壳，脱壳失败，010看一下，改4F为F4：

看加密逻辑：

 基本确定就是RC4，不过是把加密的轮数从256改成了128了。那么有了密钥，以及加密结果，就可以写解密脚本了。
 这里还需要注意的是在写解密脚本的时候，ida反汇编出来的加密数据是小端序排列，我们在写解密脚本的时候需要用大端序。
def init(s, k2, Len_k2):    k = [0] * 128    for i in range(128):        s[i] = i        # 完全匹配 C++ 代码的写法：k[i] = k[i % Len_k2]        # 在 Python 中，由于 k 初始化为全零，这等同于 k[i] = 0        k[i] = k[i % Len_k2]        j = 0    for i in range(128):        j = (j + s[i] + k[i]) % 128        s[i], s[j] = s[j], s[i]def c4_decrypt(Data, Len_D, k1, Len_k1):    s = [0] * 128    init(s, k1, Len_k1)    i = j = 0        decrypted = bytearray()    for k in range(Len_D):        i = (i + 1) % 128        j = (j + s[i]) % 128        s[i], s[j] = s[j], s[i]        t = (s[i] + s[j]) % 128        # 直接修改 Data 中的字节        Data[k] ^= s[t]        return Dataif __name__ == &quot;__main__&quot;:    # 密钥（必须与C++完全一致）    key = b&quot;B2a0s2e40815&quot;    print(key.decode(&#x27;ascii&#x27;))        key_len = len(key)    # 加密数据（与C++代码完全一致）    encrypted_data = bytearray([        0x16, 0x12, 0x27, 0x6c, 0x46, 0x65, 0x4a, 0x36, 0x39, 0x21,        0x08, 0x68, 0x35, 0x24, 0x47, 0x24, 0x60, 0x7d, 0x1a, 0x5a,        0x0f, 0x3c, 0x32, 0x29, 0x44, 0x15, 0x53, 0x45, 0x3c, 0x7c,        0x64, 0x4d, 0x24, 0x70, 0x0f, 0x13, 0x39, 0x23, 0x15, 0x74    ])        # 解密    decrypted = c4_decrypt(encrypted_data, len(encrypted_data), key, key_len)        # 输出结果（逐字符打印，与C++完全一致）    print(&quot;解密结果：&quot;)    for b in decrypted:        print(chr(b), end=&#x27;&#x27;)    print()        # 十六进制输出    print(&quot;\n十六进制形式：&quot;)    print(&#x27; &#x27;.join(f&#x27;&#123;b:02x&#125;&#x27; for b in decrypted))

flag： BaseCTF{Rc4_1$_@_G0od_3nCrypt!on_MethOd}
16.Dont-debug-me下断点动调一下：

读读函数然后发现会按反调试走，那我们就可以：到了这，0000000000401F7D这一行的jz语句下方的两个箭头，右边这个在闪动，意思是下一步程序会往箭头所指的方向运行，那就是结束程序了，那么我们可以选择修改标志位寄存器，ZF，来进行绕过，
双击ZF的值，就可以修改了，修改为0就好了

flag：  BaseCTF{8ea2710a717f89d83af695d312fe3b625df14a6ba6b3a74e15ed1e2d35cb10}
17.UPX PRO MAX发现加壳且标志位被改为0：

x64dbg打开程序，先F9运行，
再按几次F8，可以看到很明显就是ESP定律

鼠标光标放到RSP寄存器上，右键，
点击在内存窗口中转到，然后右键，选择断点-&gt;硬件，访问-&gt;4字节，接着按几次F9运行，可以看到，


第一个红色方框中的多个pop就说明解压已经结束，正要恢复现场，第二个红色方框中就是OEP了，然后我们只需F8通过jmp跳到正确有效函数的入口，

跳转到这，我们就可以使用插件 scylla 进行脱壳了，
好像可以在这里直接改：

可以看到使用插件，进程已经填好，OEP也填好了，我们只需点击Dump，然后保存好文件，
再点击IAT Autosearch,

看到IAT已找到，再点击Get Imports，

那个打叉的函数不管，另外三个是正常的，最后点击Fix Dump，选择我们刚才Dump下来的文件就可以了。最后分析的时候我们分析的是修复好的文件，UPX PRO MAX_dump_SCY.exe
然后剩下的正常逆，发现是一个异或运算，直接套：
# 从C++代码中提取的加密数组enc = [0x22, 0x11, 0x17, 0x21, 0x16, 0x11, 0x3C, 0x23, 0x65, 0x5C,       0x2E, 0x74, 0x7C, 0x7D, 0x6D, 0x72, 0x6C, 0x0E, 0x36, 0x34,       0x64, 0x42, 0x57, 0x4E, 0x3B, 0x24, 0x36, 0x3A, 0x2C, 0x6D,       0x43, 0x13, 0x7A, 0x68, 0x11, 0x3D, 0x24, 0x10, 0x2E, 0x52,       0x5D, 0x29]# 第一步：执行累积异或操作（从后向前）for i in range(41, 0, -1):    enc[i - 1] ^= enc[i]# 第二步：执行最终异或操作并构建flagflag = &#x27;&#x27;.join([chr(enc[j] ^ j ^ ord(&#x27;&#125;&#x27;)) for j in range(42)])print(f&quot;解出的flag: &#123;flag&#125;&quot;)



flag:   BaseCTF&#123;W3lC0M3_2_ReV3r$e_xOr_1s_$O_e@S|!&#125;

]]></content>
      <categories>
        <category>CTF</category>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>逆向</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>2025litCTF</title>
    <url>/2025/05/30/2025litctf/</url>
    <content><![CDATA[2025litctf  这位师傅的wp好：    2025LitCTF–Crypto–WriteUp_litctf2025-CSDN博客basic原题：
from Crypto.Util.number import *from enc import flag m = bytes_to_long(flag)n = getPrime(1024)e = 65537c = pow(m,e,n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;c = &#123;c&#125;&quot;)&#x27;&#x27;&#x27;n = 150624321883406825203208223877379141248303098639178939246561016555984711088281599451642401036059677788491845392145185508483430243280649179231349888108649766320961095732400297052274003269230704890949682836396267905946735114062399402918261536249386889450952744142006299684134049634061774475077472062182860181893e = 65537c = 22100249806368901850308057097325161014161983862106732664802709096245890583327581696071722502983688651296445646479399181285406901089342035005663657920475988887735917901540796773387868189853248394801754486142362158369380296905537947192318600838652772655597241004568815762683630267295160272813021037399506007505&#x27;&#x27;&#x27;

一个简单的欧拉函数题，直接n-1得到phi剩下的正常解就好了：
wp:
from Crypto.Util.number import *# from enc import flag n = 150624321883406825203208223877379141248303098639178939246561016555984711088281599451642401036059677788491845392145185508483430243280649179231349888108649766320961095732400297052274003269230704890949682836396267905946735114062399402918261536249386889450952744142006299684134049634061774475077472062182860181893e = 65537c = 22100249806368901850308057097325161014161983862106732664802709096245890583327581696071722502983688651296445646479399181285406901089342035005663657920475988887735917901540796773387868189853248394801754486142362158369380296905537947192318600838652772655597241004568815762683630267295160272813021037399506007505e = 65537# c = pow(m,e,n)phi=n-1d=pow(e,-1,phi)print(long_to_bytes(pow(c,d,n)))LitCTF&#123;ee2c30dfe684f13a6e6c07b9ec90cc2c&#125;



ez_math（不会原题：
from sage.all import *from Crypto.Util.number import *from uuid import uuid4flag = b&#x27;LitCTF&#123;&#x27;+ str(uuid4()).encode() + b&#x27;&#125;&#x27;flag = bytes_to_long(flag)len_flag = flag.bit_length()e = 65537p = getPrime(512)P = GF(p)A = [[flag,                 getPrime(len_flag)],     [getPrime(len_flag),   getPrime(len_flag)]]A = matrix(P, A)B = A ** eprint(f&quot;e = &#123;e&#125;&quot;)print(f&quot;p = &#123;p&#125;&quot;)print(f&quot;B = &#123;list(B)&#125;&quot;.replace(&#x27;(&#x27;, &#x27;[&#x27;).replace(&#x27;)&#x27;, &#x27;]&#x27;))# e = 65537# p = 8147594556101158967571180945694180896742294483544853070485096002084187305007965554901340220135102394516080775084644243545680089670612459698730714507241869# B = [[2155477851953408309667286450183162647077775173298899672730310990871751073331268840697064969968224381692698267285466913831393859280698670494293432275120170, 4113196339199671283644050914377933292797783829068402678379946926727565560805246629977929420627263995348168282358929186302526949449679561299204123214741547], [3652128051559825585352835887172797117251184204957364197630337114276860638429451378581133662832585442502338145987792778148110514594776496633267082169998598, 2475627430652911131017666156879485088601207383028954405788583206976605890994185119936790889665919339591067412273564551745588770370229650653217822472440992]]



ai一把梭的
wp：
from sage.all import *from Crypto.Util.number import long_to_bytese = 65537p = 8147594556101158967571180945694180896742294483544853070485096002084187305007965554901340220135102394516080775084644243545680089670612459698730714507241869B = [[2155477851953408309667286450183162647077775173298899672730310990871751073331268840697064969968224381692698267285466913831393859280698670494293432275120170, 4113196339199671283644050914377933292797783829068402678379946926727565560805246629977929420627263995348168282358929186302526949449679561299204123214741547], [3652128051559825585352835887172797117251184204957364197630337114276860638429451378581133662832585442502338145987792778148110514594776496633267082169998598, 2475627430652911131017666156879485088601207383028954405788583206976605890994185119936790889665919339591067412273564551745588770370229650653217822472440992]]Fp = GF(p)B_matrix = matrix(Fp, 2, 2, B)det_B = B_matrix.determinant()tr_B = B_matrix.trace()R.&lt;x&gt; = PolynomialRing(Fp, &#x27;x&#x27;)poly = x^2 - tr_B * x + det_Broots = poly.roots()if len(roots) != 2:    raise ValueError(&quot;B矩阵在GF(p)上没有两个特征值，无法解密。&quot;)mu1, _ = roots[0]mu2, _ = roots[1]d = inverse_mod(e, p-1)  # RSA解密指数lambda1 = mu1 ** d  # 直接幂运算lambda2 = mu2 ** dt = lambda1 + lambda2det_A = lambda1 * lambda2# 修正点：使用 ** (-1) 求逆lambda1_e_minus_1 = mu1 * (lambda1 ** (-1))  # 等价于 lambda1^(e-1)lambda2_e_minus_1 = mu2 * (lambda2 ** (-1))numerator_m = lambda1_e_minus_1 - lambda2_e_minus_1denominator_k = lambda1 - lambda2k_e = (mu1 - mu2) / denominator_km_e = -(det_A * numerator_m) / denominator_kA00 = (B_matrix[0][0] - m_e) / k_eA01 = B_matrix[0][1] / k_eA10 = B_matrix[1][0] / k_eA11 = (B_matrix[1][1] - m_e) / k_eassert A00 + A11 == t, &quot;迹不匹配&quot;assert A00 * A11 - A01 * A10 == det_A, &quot;行列式不匹配&quot;flag = long_to_bytes(int(A00))print(&quot;Flag:&quot;, flag.decode())



看了眼大佬的：
2025LitCTF–Crypto–WriteUp_litctf2025-CSDN博客

math原题：
from Crypto.Util.number import *from enc import flagm = bytes_to_long(flag)e = 65537p,q = getPrime(1024),getPrime(1024)n = p*qnoise = getPrime(40)tmp1 = noise*p+noise*qtmp2 = noise*noisehint = p*q+tmp1+tmp2c = pow(m,e,n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;c = &#123;c&#125;&quot;)print(f&quot;hint = &#123;hint&#125;&quot;)&#x27;&#x27;&#x27;n = 17532490684844499573962335739488728447047570856216948961588440767955512955473651897333925229174151614695264324340730480776786566348862857891246670588649327068340567882240999607182345833441113636475093894425780004013793034622954182148283517822177334733794951622433597634369648913113258689335969565066224724927142875488372745811265526082952677738164529563954987228906850399133238995317510054164641775620492640261304545177255239344267408541100183257566363663184114386155791750269054370153318333985294770328952530538998873255288249682710758780563400912097941615526239960620378046855974566511497666396320752739097426013141e = 65537c = 1443781085228809103260687286964643829663045712724558803386592638665188285978095387180863161962724216167963654290035919557593637853286347618612161170407578261345832596144085802169614820425769327958192208423842665197938979924635782828703591528369967294598450115818251812197323674041438116930949452107918727347915177319686431081596379288639254670818653338903424232605790442382455868513646425376462921686391652158186913416425784854067607352211587156772930311563002832095834548323381414409747899386887578746299577314595641345032692386684834362470575165392266454078129135668153486829723593489194729482511596288603515252196hint = 17532490684844499573962335739488728447047570856216948961588440767955512955473651897333925229174151614695264324340730480776786566348862857891246670588649327068340567882240999607182345833441113636475093894425780004013793034622954182148283517822177334733794951622433597634369648913113258689335969565315879035806034866363781260326863226820493638303543900551786806420978685834963920605455531498816171226961859405498825422799670404315599803610007692517859020686506546933013150302023167306580068646104886750772590407299332549746317286972954245335810093049085813683948329319499796034424103981702702886662008367017860043529164&#x27;&#x27;&#x27;





wp：素数分解delta一下就能得到noise进而求的p+q。详细大概是这样：

from Crypto.Util.number import long_to_bytesimport gmpy2n = 17532490684844499573962335739488728447047570856216948961588440767955512955473651897333925229174151614695264324340730480776786566348862857891246670588649327068340567882240999607182345833441113636475093894425780004013793034622954182148283517822177334733794951622433597634369648913113258689335969565066224724927142875488372745811265526082952677738164529563954987228906850399133238995317510054164641775620492640261304545177255239344267408541100183257566363663184114386155791750269054370153318333985294770328952530538998873255288249682710758780563400912097941615526239960620378046855974566511497666396320752739097426013141hint = 17532490684844499573962335739488728447047570856216948961588440767955512955473651897333925229174151614695264324340730480776786566348862857891246670588649327068340567882240999607182345833441113636475093894425780004013793034622954182148283517822177334733794951622433597634369648913113258689335969565315879035806034866363781260326863226820493638303543900551786806420978685834963920605455531498816171226961859405498825422799670404315599803610007692517859020686506546933013150302023167306580068646104886750772590407299332549746317286972954245335810093049085813683948329319499796034424103981702702886662008367017860043529164delta = hint - nnoise = 942430120937s_pq_plus_num = delta // noise  # 重新计算正确的因子组合# 验证分解正确性if noise * s_pq_plus_num != delta:    print(&quot;错误: 因子乘积不等于delta&quot;)    exit()s_pq = s_pq_plus_num - noise# 计算二次方程判别式D = s_pq**2 - 4*nroot, is_square = gmpy2.iroot(D, 2)if not is_square:    print(&quot;错误: 判别式D不是完全平方数&quot;)    exit()p = (s_pq + root) // 2q = (s_pq - root) // 2if p * q != n:    print(&quot;错误: p*q不等于n&quot;)    exit()# 解密流程e = 65537c = 1443781085228809103260687286964643829663045712724558803386592638665188285978095387180863161962724216167963654290035919557593637853286347618612161170407578261345832596144085802169614820425769327958192208423842665197938979924635782828703591528369967294598450115818251812197323674041438116930949452107918727347915177319686431081596379288639254670818653338903424232605790442382455868513646425376462921686391652158186913416425784854067607352211587156772930311563002832095834548323381414409747899386887578746299577314595641345032692386684834362470575165392266454078129135668153486829723593489194729482511596288603515252196phi = (p-1)*(q-1)d = pow(e, -1, phi)m = pow(c, d, n)print(&quot;解密成功！Flag:&quot;, long_to_bytes(m).decode())LitCTF&#123;db6f52b9265971910b306754b9df8b76&#125;

baby原题：
import gmpy2from Crypto.Util.number import *from enc import flagm = bytes_to_long(flag)g = getPrime(512)t = getPrime(150)data = (t * gmpy2.invert(m, g)) % gprint(f&#x27;g = &#123;g&#125;&#x27;)print(f&#x27;data = &#123;data&#125;&#x27;)&#x27;&#x27;&#x27;g = 7835965640896798834809247993719156202474265737048568647376673642017466116106914666363462292416077666356578469725971587858259708356557157689066968453881547data = 2966297990428234518470018601566644093790837230283136733660201036837070852272380968379055636436886428180671888655884680666354402224746495312632530221228498&#x27;&#x27;&#x27;



wp：


from fractions import Fractionfrom Crypto.Util.number import inverse, long_to_bytesimport gmpy2# 已知数据g = 7835965640896798834809247993719156202474265737048568647376673642017466116106914666363462292416077666356578469725971587858259708356557157689066968453881547data = 2966297990428234518470018601566644093790837230283136733660201036837070852272380968379055636436886428180671888655884680666354402224746495312632530221228498# 手动实现连分数系数生成（基于欧几里得算法）def generate_continued_fraction(a, b):    coeffs = []    while b != 0:        q, r = divmod(a, b)        coeffs.append(q)        a, b = b, r    return coeffs# 生成连分数系数coeffs = generate_continued_fraction(data, g)# 手动实现收敛项生成def get_convergents(coeffs):    convergents = []    h1, h2 = 1, 0    k1, k2 = 0, 1    for c in coeffs:        h = c * h1 + h2        k = c * k1 + k2        convergents.append(Fraction(h, k))        h2, h1 = h1, h        k2, k1 = k1, k    return convergentsconv_list = get_convergents(coeffs)# 枚举收敛项for conv in conv_list:    h, k = conv.numerator, conv.denominator    t_candidate = data * k - g * h    if t_candidate &gt; 0 and t_candidate.bit_length() == 150:        if gmpy2.is_prime(t_candidate):            try:                inv_m = inverse(k, g)                if (t_candidate * inv_m) % g == data:                    print(&quot;Found valid m:&quot;, k)                    flag = long_to_bytes(k)                    print(&quot;Flag:&quot;, flag.decode())                    break            except:                pass            Found valid m: 637558173724466419510759412644075143734813144557473543913639658885806728973294110666447896405373Flag: LitCTF&#123;56008a819331c9f3608a718327b7e6ce&#125;



leak原题：
from Crypto.Util.number import *from enc import flagm = bytes_to_long(flag)p,q,e = getPrime(1024),getPrime(1024),getPrime(101)n = p*qtemp = gmpy2.invert(e,p-1)c = pow(m,e,n)hint = temp&gt;&gt;180print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;c = &#123;c&#125;&quot;)print(f&quot;hint = &#123;hint&#125;&quot;)&#x27;&#x27;&#x27;e = 1915595112993511209389477484497n = 12058282950596489853905564906853910576358068658769384729579819801721022283769030646360180235232443948894906791062870193314816321865741998147649422414431603039299616924238070704766273248012723702232534461910351418959616424998310622248291946154911467931964165973880496792299684212854214808779137819098357856373383337861864983040851365040402759759347175336660743115085194245075677724908400670513472707204162448675189436121439485901172477676082718531655089758822272217352755724670977397896215535981617949681898003148122723643223872440304852939317937912373577272644460885574430666002498233608150431820264832747326321450951c = 5408361909232088411927098437148101161537011991636129516591281515719880372902772811801912955227544956928232819204513431590526561344301881618680646725398384396780493500649993257687034790300731922993696656726802653808160527651979428360536351980573727547243033796256983447267916371027899350378727589926205722216229710593828255704443872984334145124355391164297338618851078271620401852146006797653957299047860900048265940437555113706268887718422744645438627302494160620008862694047022773311552492738928266138774813855752781598514642890074854185464896060598268009621985230517465300289580941739719020511078726263797913582399hint = 10818795142327948869191775315599184514916408553660572070587057895748317442312635789407391509205135808872509326739583930473478654752295542349813847128992385262182771143444612586369461112374487380427668276692719788567075889405245844775441364204657098142930&#x27;&#x27;&#x27;




wp：
from Crypto.Util.number import *import itertoolsdef small_roots(f, bounds, m=1, d=None):    if not d:        d = f.degree()    R = f.base_ring()    N = R.cardinality()    f /= f.coefficients().pop(0)    f = f.change_ring(ZZ)    G = Sequence([], f.parent())    for i in range(m + 1):        base = N ^ (m - i) * f ^ i        for shifts in itertools.product(range(d), repeat=f.nvariables()):            g = base * prod(map(power, f.variables(), shifts))            G.append(g)    B, monomials = G.coefficient_matrix()    monomials = vector(monomials)    factors = [monomial(*bounds) for monomial in monomials]    for i, factor in enumerate(factors):        B.rescale_col(i, factor)    B = B.dense_matrix().LLL()    B = B.change_ring(QQ)    for i, factor in enumerate(factors):        B.rescale_col(i, 1 / factor)    H = Sequence([], f.parent().change_ring(QQ))    for h in filter(None, B * monomials):        H.append(h)        I = H.ideal()        if I.dimension() == -1:            H.pop()        elif I.dimension() == 0:            roots = []            for root in I.variety(ring=ZZ):                root = tuple(R(root[var]) for var in f.variables())                roots.append(root)            return roots    return []e = 1915595112993511209389477484497n = 12058282950596489853905564906853910576358068658769384729579819801721022283769030646360180235232443948894906791062870193314816321865741998147649422414431603039299616924238070704766273248012723702232534461910351418959616424998310622248291946154911467931964165973880496792299684212854214808779137819098357856373383337861864983040851365040402759759347175336660743115085194245075677724908400670513472707204162448675189436121439485901172477676082718531655089758822272217352755724670977397896215535981617949681898003148122723643223872440304852939317937912373577272644460885574430666002498233608150431820264832747326321450951c = 5408361909232088411927098437148101161537011991636129516591281515719880372902772811801912955227544956928232819204513431590526561344301881618680646725398384396780493500649993257687034790300731922993696656726802653808160527651979428360536351980573727547243033796256983447267916371027899350378727589926205722216229710593828255704443872984334145124355391164297338618851078271620401852146006797653957299047860900048265940437555113706268887718422744645438627302494160620008862694047022773311552492738928266138774813855752781598514642890074854185464896060598268009621985230517465300289580941739719020511078726263797913582399hint = 10818795142327948869191775315599184514916408553660572070587057895748317442312635789407391509205135808872509326739583930473478654752295542349813847128992385262182771143444612586369461112374487380427668276692719788567075889405245844775441364204657098142930R.&lt;dp_low, k&gt;=PolynomialRing(Zmod(n))f = e * (hint * 2 ** 180 + dp_low) + k - 1ans, k=small_roots(f, [2 ** 180, 2 ** 100], 1, 3)[0]dp = hint * 2 ** 180 + ansp = (e * dp - 1) // k + 1d = inverse(e, int(p - 1))m = pow(c, d, p)print(long_to_bytes(int(m)))# b&#x27;LitCTF&#123;03ecda15d1a89b06454c6050c1bd489f&#125;&#x27;



new_bag原题：
from Crypto.Util.number import *import randomimport string def get_flag(length):    characters = string.ascii_letters + string.digits + &#x27;_&#x27;    flag = &#x27;LitCTF&#123;&#x27; + &#x27;&#x27;.join(random.choice(characters) for _ in range(length)) + &#x27;&#125;&#x27;    return flag.encode()flag = get_flag(8)print(flag)flag = bin(bytes_to_long(flag))[2:]p = getPrime(128)pubkey = [getPrime(128) for i in range(len(flag))]enc = 0for i in range(len(flag)):    enc += pubkey[i] * int(flag[i])    enc %= pf = open(&quot;output.txt&quot;,&quot;w&quot;)f.write(f&quot;p = &#123;p&#125;\n&quot;)f.write(f&quot;pubkey = &#123;pubkey&#125;\n&quot;)f.write(f&quot;enc = &#123;enc&#125;\n&quot;)f.close()

数据：
p = 173537234562263850990112795836487093439pubkey = [184316235755254907483728080281053515467, 301753295242660201987730522100674059399, 214746865948159247109907445342727086153, 190710765981032078577562674498245824397, 331594659178887289573546882792969306963, 325241251857446530306000904015122540537, 183138087354043440402018216471847480597, 184024660891182404534278014517267677121, 221852419056451630727726571924370029193, 252122782233143392994310666727549089119, 175886223097788623718858806338121455451, 275410728642596840638045777234465661687, 251664694235514793799312335012668142813, 218645272462591891220065928162159215543, 312223630454310643034351163568776055567, 246969281206041998865813427647656760287, 314861458279166374375088099707870061461, 264293021895772608566300156292334238719, 300802209357110221724717494354120213867, 293825386566202476683406032420716750733, 280164880535680245461599240490036536891, 223138633045675121340315815489781884671, 194958151408670059556476901479795911187, 180523100489259027750075460231138785329, 180425435626797251881104654861163883059, 313871202884226454316190668965524324023, 184833541398593696671625353250714719537, 217497008601504809464374671355532403921, 246589067140439936215888566305171004301, 289015788017956436490096615142465503023, 301775305365100149653555500258867275677, 185893637147914858767269807046039030871, 319328260264390422708186053639594729851, 196198701308135383224057395173059054757, 231185775704496628532348037721799493511, 243973313872552840389840048418558528537, 213140279661565397451805047456032832611, 310386296949148370235845491986451639013, 228492979916155878048849684460007011451, 240557187581619139147592264130657066299, 187388364905654342761169670127101032713, 305292765113810142043496345097024570233, 303823809595161213886303993298011013599, 227663140954563126349665813092551336597, 257833881948992845466919654910838972461, 291249161813309696736659661907363469657, 228470133121759300620143703381920625589, 337912208888617180835513160742872043511, 252639095930536359128379880984347614689, 306613178720695137374121633131944714277, 328627523443531702430603855075960220403, 283995291614222889691668376952473718279, 185992200035693404743830210660606140043, 175575945935802771832062328390060568381, 239709736751531517044198331233711541211, 325191992201185112802734343474281930993, 285825734319916654888050222626163129503, 260820892372814862728958615462018022903, 271109638409686342632742230596810197399, 195432366301516284662210689868561107229, 252351678712166898804432075801905414141, 175869608753229067314866329908981554323, 212291732707466211705141589249474157597, 299891357045144243959903067354676661051, 271237385422923460052644584552894282763, 268702576849722796315440463412052409241, 198273535005705777854651218089804228523, 177684355989910045168511400849036259973, 189237944200991357454773904466163557789, 175427967765368330787115337317676160499, 270446056495616077936737430232108222303, 243318639972702711024520926308402316247, 223872107662231922057872197123261908053, 268995355861070998347238198063073079851, 244478236168888494353493404999149985963, 230731375083676409248450208772518041369, 231630208287176700035265642824425872113, 187649298194887119502654724235771449423, 264924369987111619306245625770849264491, 327092811483332202721992798797117253283, 274967838920225995524024619709213673571, 313836314009366857157961838519499192671, 181860768653760352435352944732117309357, 184011200837375425882494435177626368109, 246455975565763627776562816894916143559, 262208917125258935991543552004318662109, 334006940602786701813813048552124976177, 241119397420390120456580389194328607351, 255370083166310325724283692646412327547, 280056982387584554076672702548437488901, 190822826881447578202544631446213911541, 206119293866065537243159766877834200177, 289535246575130471484249052043282790337, 222004375767927951747133364917437739627, 186041951615746748538744491355290007923, 299120276948597373232905692530626175519, 268645812049699572580085139845553457511, 231990902203442306941381714523426756489, 259677531562170067444672097354970172129, 232573792063456357545735601063504090387, 268451806037215206985127877726665463011, 324266632324016349795115268035757999593, 323952615081869295386415078624753400501, 302316593553669781596237136546083536339, 235576231941572491681115931798290883659, 202271277470197960243533508432663735031, 172391954991101354275650988921310984563, 215333185856183701105529790905068832303, 335916893044781805453250006520700519353, 217268288923298532517983372665872329797, 265455575922780577837866687874732212733, 182194442259001995170676842797322170297, 180222796978664332193987060700843734759, 332629077640484670095070754759241249101, 238815683708676274248277883404136375767, 246167709707533867216616011486975023679, 188375282015595301232040104228085154549, 230675799347049231846866057019582889423, 290911573230654740468234181613682439691, 173178956820933028868714760884278201561, 340087079300305236498945763514358009773, 215775253913162994758086261347636015049, 286306008278685809877266756697807931889, 175231652202310718229276393280541484041, 230887015177563361309867021497576716609, 306478031708687513424095160106047572447, 172289054804425429042492673052057816187]enc = 82516114905258351634653446232397085739



]]></content>
      <categories>
        <category>CTF</category>
        <category>密码</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码</tag>
        <tag>校赛</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA系列</title>
    <url>/2025/03/19/RSA%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[RSA系列1.最简单的rsa原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = getPrime(512)q = getPrime(512)n = p*qe = 65537phi = (p-1)*(q-1)m = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223e = 65537c = 40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720&#x27;&#x27;&#x27;

wp：
from Crypto.Util.number import *p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223e = 65537c = 40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720n=p*qphi = (p-1)*(q-1)d=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))b&#x27;NSSCTF&#123;now!you_know_rsa&#125;&#x27;



2.已知n（简单）原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = getPrime(256)q = getPrime(256)n = p*qe = 65537phi = (p-1)*(q-1)m = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881e = 65537c = 6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557&#x27;&#x27;&#x27;

直接factor（n）就好，但yafu太慢，用的在线网站，不晓得离线咋弄，问问
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p=70538125404512947763739093348083497980212021962975762144416432920656660487657q=104660876276442216612517835199819767034152013287345576481899196023866133215633n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881e = 65537c = 6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557phi = (p-1)*(q-1)d=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))b&#x27;NSSCTF&#123;factordb_is_useful&#125;&#x27;

3.yafu使用原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = getPrime(128)q = getPrime(128)n = p*qe = 65537phi = (p-1)*(q-1)m = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;n = 53690629441472827148854210396580805205350972614395425306316047967905824330731e = 65537c = 22130296334673852790451396673112575082637108306697684532954477845025885087040&#x27;&#x27;&#x27;

这个直接用yafu能解，因为数不是很大
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;n = 53690629441472827148854210396580805205350972614395425306316047967905824330731e = 65537c = 22130296334673852790451396673112575082637108306697684532954477845025885087040p = 277349599849597463956171076348973750041q = 193584665240506752994134779660255197091phi = (p-1)*(q-1)d=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))#NSSCTF&#123;yafu!yafu!yafu!&#125;

4.nextprime原题：
from Crypto.Util.number import *import gmpy2flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = getPrime(512)q = gmpy2.next_prime(p)n = p*qe = 65537phi = (p-1)*(q-1)m = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057e = 65537c = 98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730&#x27;&#x27;&#x27;

wp：
p和q相邻，对n求根然后nextprime得出p即可：
from Crypto.Util.number import *import gmpy2import numpyfrom sympy import nextprime, rootflag = b&#x27;NSSCTF&#123;******&#125;&#x27;n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057e = 65537c = 98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730pq=root(n,2)q=nextprime(pq)p=n//qphi = (p-1)*(q-1)d=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))b&#x27;NSSCTF&#123;so_closed&#125;&#x27;

5.可以factor直接出，也可以费马原题：
from Crypto.Util.number import *import gmpy2flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = getPrime(512)q = gmpy2.next_prime(p - getPrime(256))n = p*qe = 65537phi = (p-1)*(q-1)m = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117e = 65537c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932&#x27;&#x27;&#x27;

wp：
方法一，factor直接出：
from Crypto.Util.number import *import gmpy2flag = b&#x27;NSSCTF&#123;******&#125;&#x27;n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117e = 65537c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932p = 12200065120379104459630695224710181907653841921369674962900093531339421658815375891425102591939094029941691738405035324548070063226677838530633694428729829q = 12200065120379104459630695224710181907653841921369674962900093531339421658815305905822146210878434959851438079877557401145694064756239882458467901042367473phi = (p-1)*(q-1)d=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))b&#x27;NSSCTF&#123;fermat_factor&#125;&#x27;

方法二：使用费马分解,因为p和q中间间隔较小1.将n开根号2.分别赋值到a和b

b^2&#x3D;a^2-n 最后得出的结果需要能开根号

4.丢到while循环中去，a&#x3D;a+1将开根号后的结果加一，一个一个试，直到最后得出的结果需要能开根号。5.p&#x3D;a+b q&#x3D;a-b
from Crypto.Util.number import *import gmpy2def fermat_attack(n):    a=gmpy2.isqrt(n) #首先分解n，把分解后的小数点之后抛弃掉    b_squared=a*a-n #b^2=a^2-n    b=gmpy2.isqrt(n)    while b*b != b_squared:        a=a+1 #将分解n后的a,叠加1        b_squared = a*a-n #b^2=(a+1)^2-n，将叠加后的a平方并减一        b=gmpy2.isqrt(b_squared) #开根号，观察得数是否可以开根号，并且将开根号后的b^2赋值给b    p=a+b #若可以，则将n开根号后的a加上b，得出结果就是p,将n开根号后的a减b，得出结果就是q    q=a-b    assert n == p*q    return p,qn = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117p,q=fermat_attack(n)e = 65537phi = (p-1)*(q-1)d=inverse(e,phi)c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932msg=pow(c,d,n)print(long_to_bytes(msg))

6.共因数原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p1 = getPrime(512)q = getPrime(512)p2 = getPrime(512)n1 = p1*qn2 = p2*qe = 65537m = bytes_to_long(flag)c1 = pow(m, e, n1)c2 = pow(m, e, n2)print(f&#x27;n1 = &#123;n1&#125;&#x27;)print(f&#x27;n2 = &#123;n2&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c1 = &#123;c1&#125;&#x27;)print(f&#x27;c2 = &#123;c2&#125;&#x27;)&#x27;&#x27;&#x27;n1 = 143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893n2 = 138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169e = 65537c1 = 54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029c2 = 122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736&#x27;&#x27;&#x27;

wp：求出共因数q即可：
print(binascii.unhexlify(hex(m2)[2:].strip(&quot;L&quot;)))解释：hex(m2) 将 m2 转换为它的十六进制字符串表示（例如，0x123abcd）。[2:] 通过切片去掉十六进制表示中的 0x 前缀（结果是 123abcd）。strip(&quot;L&quot;) 用来去掉字符串中的 L（在 Python 2 中，当大整数被表示时会附加一个 L，但在 Python 3 中不再需要）。binascii.unhexlify() 将十六进制字符串（例如，123abcd）转换为原始的字节串。目的：这行代码是将整数 m2 先转为十六进制字符串，再通过 unhexlify() 转换为字节串。这样做实际上是将整数转换为字节数据。



import binasciifrom Crypto.Util.number import *from numpy import gcd, invertflag = b&#x27;NSSCTF&#123;******&#125;&#x27;n1 = 143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893n2 = 138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169e = 65537c1 = 54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029c2 = 122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736q=gcd(n1,n2)p1=n1//qp2=n2//qphi1 = (p1-1)*(q-1)phi2 = (p2-1)*(q-1)d1=pow(e,-1,phi1)d2=pow(e,-1,phi2)m1=pow(c1,d1,n1)m2=pow(c2,d2,n2)print(long_to_bytes(m1))print(long_to_bytes(m2))print(binascii.unhexlify(hex(m2)[2:].strip(&quot;L&quot;)))print(binascii.unhexlify(hex(m1)[2:].strip(&quot;L&quot;)))b&#x27;NSSCTF&#123;no_share_number&#125;&#x27;



7.简单三数的rsa原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27; + b&#x27;1&#x27;*170p = getPrime(512)q = getPrime(512)r = getPrime(512)n = p*q*re = 65537phi = (p-1)*(q-1)*(r-1)m = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)print(f&#x27;r = &#123;r&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)

wp：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27; + b&#x27;1&#x27;*170p = 10666139331774428325755287635566473140804481321882464031499529816800186578792308674238646794969384836340484775213796013129603472328582005363876462361316357q = 8419311673449738061914489023962717718536471719688567807316495262754711350004888752049108347226115000749280146228195893953964759818878155006622123533942989r = 12875078327453384158245832541544758526474680184252540739652077682353277702054275525591573258723948221345537075374635382175740236093131628077747126356403959e = 65537c = 424552463648937499189041230155623101311087334789253159440707211761796081289342164253743235182597460622581134089949035117444838205449163269030784233435435681797627188717450074808905561404960693227573181548281296514743775615606388692910356320667720308219275107443303501165027740512539959960217657836317351146520079753390346207659007421416917274795119021374032194294225350901136669304225010974617136606299060486198480556729770211945777266366417547752798441211059402n = p*q*rphi = (p-1)*(q-1)*(r-1)d=pow(e,-1,phi)print(long_to_bytes(pow(c,d,n)))b&#x27;NSSCTF&#123;3th_number!&#125;

8.最简单的欧拉函数原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27; + b&#x27;1&#x27;*100p = getPrime(256)q = getPrime(256)n = (p**3) * qe = 65537phi = (p-1)*(q-1)m = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)



wp：简单的欧拉函数：

from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27; + b&#x27;1&#x27;*100p = 80505091208742938705306670241621545375764148093711243653439069254008824979403q = 67599990875658931406915486208971556223245451500927259766683936131876689508521e = 65537c = 7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041n = (p**3) * qe = 65537phi = (p-1)*(q-1)*p*pd=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))b&#x27;NSSCTF&#123;more_exp&#125;

9.多因子小明文攻击原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = getPrime(512)q = getPrime(512)e = 65537while True:    r = 2*getPrime(100)*e+1    if isPrime(r):        breakn = p*q*rm = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)print(f&#x27;r = &#123;r&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)

wp：
直接用正常的多因子例如7.简单三数的rsa会出错，因为e和phi不互质
但我们知道flag并未进行填充，flag相当的小，则m也会很小，甚至比p*q更小，那么我们可以直接mod pq

其实通俗一点的理解就是当mm比较小时，此时就算公钥对应的私钥不存在（逆元不存在），我们可以考虑将公钥转化为其他公钥（用原公钥因子进行重组）再尝试求解私钥进行解密，依然可以得到正确结果。
这里其实也就解释了为什么P7，P8需要加上大量字符串的填充，就是为了防止使用该方法直接解出，在现实世界的RSA算法应用标准中，明文其实都会用特定算法进行填充来防止这种情况出现。


![](屏幕截图 2025-03-19 222849.png)
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = 7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279q = 9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713r = 102909133680612532601801231903654039e = 65537c = 142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197n = p*qphi=(p-1)*(q-1)d=pow(e,-1,phi)m=pow(c,d,n)print(long_to_bytes(m))b&#x27;NSSCTF&#123;no_inverse!but_decrypt&#125;&#x27;



10.x倍的e原题：
from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = getPrime(512)q = getPrime(512)e = 65537*2n = p*qm = bytes_to_long(flag)c = pow(m, e, n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)

wp：
又是e和phi不互素，观察到e为2*65537，猜都能猜一手m最后要开方

方法一：from Crypto.Util.number import *flag = b&#x27;NSSCTF&#123;******&#125;&#x27;p = 9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059q = 9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343e = 131074c = 68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560# 对大整数开n次方def integer_nth_root(value, n):       low, high = 0, value    while low &lt;= high:        mid = (low + high) // 2        mid_pow = pow(mid, n)        if mid_pow == value:            return mid        elif mid_pow &lt; value:            low = mid + 1        else:            high = mid - 1    return highe = 65537*2n = p*qphi=(p-1)*(q-1)d=pow(e//2,-1,phi)m=pow(c,d,n)m=integer_nth_root(m,2)print(long_to_bytes(m))b&#x27;NSSCTF&#123;inverse_and_root&#125;&#x27;

方法二，其实也不算方法，只是表示不同罢了d = inverse(e//2, phi) 求dmsg = pow(c,d,n)  解密密文m=gmpy2.iroot(msg,2)  对明文进行平方处理，获得原始明文print(long_to_bytes(int(m[0]))) 取出明文

]]></content>
      <categories>
        <category>密码</category>
      </categories>
      <tags>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title>2024isCTF</title>
    <url>/2024/11/15/isctf/</url>
    <content><![CDATA[isctf 密码wp位（Bit）是最小的数据单位，字节（Byte）由 8 个位组成，字符则是通过字节表示的
我和小蓝鲨的秘密（rsa图片加密解密涉及rsa的图片加密解密
原题：
from PIL import Imagefrom Crypto.Util.number import bytes_to_long, long_to_bytesimport numpy as npn = 29869349657224745144762606999e = 65537original_image_path = &quot;flag.jpg&quot;img = Image.open(original_image_path)img = img.convert(&quot;RGB&quot;)        #将图像转换为 RGB 格式，确保每个像素包含红、绿、蓝三个通道。#将图像转换为一个 NumPy 数组，其中 h 和 w 分别代表图像的高度和宽度（像素的行数和列数），_ 是表示颜色通道数，这里应该是 3，因为是 RGB 图像。后续代码也写出是3了img_array = np.array(img)h, w, _ = img_array.shape#初始化一个空的 NumPy 数组，用于存储加密后的图像数据。数组的形状是 (h, w, 3)，即和原图像一样的尺寸和颜色通道。dtype=object 表示该数组中的元素将是任意类型的对象，这里存储的是加密后的整数。encrypted_array = np.zeros((h, w, 3), dtype=object)#遍历像素点for i in range(h):    for j in range(w):        #提取当前像素的红、绿、蓝通道的值（每个值范围通常是 0 到 255）        r, g, b = int(img_array[i, j, 0]), int(img_array[i, j, 1]), int(img_array[i, j, 2])		#rsa加密        encrypted_array[i, j, 0] = pow(r, e, n)        encrypted_array[i, j, 1] = pow(g, e, n)        encrypted_array[i, j, 2] = pow(b, e, n)np.save(&quot;encrypted_image.npy&quot;, encrypted_array)print(&quot;图片已加密并保存为 encrypted_image.npy&quot;)



题解：d可以直接分解n然后得到p和q再得到d，代码没写
from Crypto.PublicKey import RSAimport numpy as npfrom PIL import Image# RSA私钥中的 d 和 nd = 114529273505388659836222611033 n = 29869349657224745144762606999e = 65537 # 从文件读取加密后的图像数据#此选项允许加载含有 Python 对象的 .npy 文件，因为加密图像数据的类型可能是 object（例如存储的是整数的加密结果）encrypted_array = np.load(r&quot;E:\edge下载\CTF\isctf\我和小蓝鲨的秘密\我和小蓝鲨的秘密\encrypted_image.npy&quot;, allow_pickle=True)#高、宽和3（上面说了，不再赘述）h, w, _ = encrypted_array.shape#用于后续存放解密后的数据decrypted_list = []# 对每个像素进行解密for i in range(h):    row = []    for j in range(w):        pixel = []        for channel in range(3):  # 红、绿、蓝三个通道            #获取加密数据            encrypted_value = encrypted_array[i, j, channel]            #对加密数据进行解密            decrypted_value = pow(encrypted_value, d, n)  # 使用RSA私钥解密            #讲解秘数据加入到decrypted_list中，用于后续转为图片            pixel.append(decrypted_value)        row.append(pixel)    decrypted_list.append(row)# 将解密后的像素值转换为 numpy 数组decrypted_array = np.array(decrypted_list, dtype=object)# 将解密后的数据转换为图像decrypted_array = np.clip(decrypted_array, 0, 255).astype(np.uint8)  # 确保像素值在有效范围内decrypted_img = Image.fromarray(decrypted_array)# 保存解密后的图片decrypted_img.save(&quot;decrypted_image.jpg&quot;)decrypted_img.show()print(&quot;图片已解密并保存为 decrypted_image.jpg&quot;)

![屏幕截图 2024-11-10 130024](屏幕截图 2024-11-10 130024.png)
ChaCha20-Poly1305ChaCha20-Poly1305加密解密原理ChaCha20 和 Poly1305 是现代密码学中两种常用的加密算法。它们被设计为高效且安全的算法，常用于保障数据的隐私性和完整性。它们可以联合使用，组成一种“认证加密算法” (Authenticated Encryption with Associated Data, AEAD)，既提供加密（保密性）又提供完整性验证（认证性）。ChaCha20-Poly1305的组合方式是在加密数据时确保其不仅是保密的，而且可以检测是否被篡改。1. ChaCha20 加密算法ChaCha20 是一种流密码算法，它的设计基于 ChaCha 算法，ChaCha 是 Salsa20（另一种流密码算法）的一个变种。ChaCha20 每次操作生成 256 位的伪随机输出，常用于加密数据流。ChaCha20的工作原理：ChaCha20 的加密过程可以分为以下几个步骤：输入：它需要一个 256 位的密钥、一个 64 位的随机初始值（nonce）和一个 32 位的计数器。状态初始化：ChaCha20 从密钥和其他信息（如nonce、计数器等）创建一个 4x4 的矩阵（共 16 个 32 位的字），这些数据用于初始化算法的内部状态。流密码生成：通过不断迭代应用非线性操作（包括加法、异或和循环移位等），生成伪随机数流。加密过程：生成的伪随机数流与明文数据按位异或，从而完成加密。ChaCha20 的加密过程包括 20 轮迭代，并且每一轮迭代都使用对称的操作，确保最终输出是高度随机的。2. Poly1305 消息认证码（MAC）Poly1305 是一种基于单一密钥的消息认证码 (MAC)，用来提供数据完整性和认证。它通过对消息进行加密生成唯一的签名，使接收方可以验证消息是否被篡改。Poly1305的工作原理：输入：Poly1305 接受一个 256 位的密钥和一段消息（数据块）。算法：Poly1305 将消息划分成固定大小的块（通常为 16 字节），然后使用密钥对这些块进行加密、处理。认证码生成：每个数据块经过加密后生成一个认证码，最后生成的认证码可以用来验证消息是否在传输过程中被篡改。Poly1305 是一个高效的认证码生成算法，其安全性基于大数分解的困难性。ChaCha20-Poly1305 组合ChaCha20 和 Poly1305 结合在一起，提供了 认证加密（Authenticated Encryption，AE）。在这种组合中，ChaCha20 提供加密功能，确保数据的机密性；而 Poly1305 提供消息认证功能，确保数据没有在传输过程中被篡改。工作流程：加密：使用 ChaCha20 对数据进行加密，生成密文。生成认证码：使用 Poly1305 对密文及相关数据（如头部信息、nonce 等）生成认证码（MAC）。传输：将密文和认证码一起传输到接收方。验证与解密：接收方使用相同的密钥和nonce对密文进行解密。如果认证码验证成功，说明数据没有被篡改，接收方就可以得到明文数据；如果认证码验证失败，数据被认为已经被篡改或丢失完整性。ChaCha20-Poly1305 的安全性保密性：ChaCha20 是一个高质量的流密码，具有强大的加密能力。完整性：Poly1305 作为认证码生成器，可以检测出数据是否在传输过程中被篡改。抗攻击性：ChaCha20-Poly1305 组合抗受多种攻击，包括重放攻击和密钥恢复攻击。由于 ChaCha20 的高效性和 Poly1305 的简单性，该组合算法非常适合在需要快速加密且对安全性有较高要求的场景中使用，如 TLS、VPN 和加密通信协议。名字的由来1. ChaCha20“ChaCha20” 中的 ChaCha 是该算法的名字来源。ChaCha 是 Salsa20（由 Daniel J. Bernstein 提出的流密码算法）的一个变种，ChaCha 在 Salsa20 的基础上做了一些增强，使其更安全且更易于分析。“ChaCha” 这个名字来自于 Salsa20 的“舞蹈”名称（Salsa 是一种舞蹈，而 ChaCha 是 Salsa 的一种变体），这种名称可能暗示着 ChaCha20 的变化和增强。数字 20 表示该算法执行的迭代次数为 20 轮，保证了更强的安全性。2. Poly1305Poly1305 是由 Daniel J. Bernstein 提出的消息认证码（MAC）。这个名字来源于它的数学基础：它基于一个多项式（poly）的计算。数字 1305 代表了 Poly1305 使用的一个具体的多项式，通常是一个在有限域上进行计算的多项式。结合起来，ChaCha20-Poly1305 代表了这两种算法的结合体，其中：ChaCha20 是加密算法的名称，基于 ChaCha 的变种。Poly1305 是消息认证码的名称，基于一个多项式的计算。这个名字简洁地表达了该加密组合的两个核心算法，并标明了其关键的安全特性：加密与认证。总结ChaCha20 提供流密码加密，确保数据的机密性。Poly1305 提供消息认证码（MAC），确保数据的完整性和认证。ChaCha20-Poly1305 组合提供了高效、安全的认证加密功能，广泛用于现代网络安全协议中，如 TLS 1.3。



ChaCha20-Poly1305 解释ChaCha20：一种流密码算法，用于生成伪随机密钥流。其优点包括速度较快和抗破解能力强。Poly1305：一种认证码算法，用于生成数据完整性和认证的哈希值，确保数据在传输过程中没有被篡改。在 PyCryptodome 或类似的加密库中，ChaCha20-Poly1305 模式通常通过 ChaCha20_Poly1305 类来实现。cipher.encrypt_and_digest() 方法会同时加密数据并生成认证码。生成密钥和nonce：key = get_random_bytes(32)：生成一个32字节的随机密钥，这是 ChaCha20-Poly1305 所需要的密钥长度。nonce = get_random_bytes(12)：生成一个12字节的随机数（nonce），这是 ChaCha20-Poly1305 模式要求的长度，通常 nonce 必须是唯一的，不能重复。创建 ChaCha20_Poly1305 对象：使用 ChaCha20_Poly1305.new() 创建一个新的加密对象，传入密钥和 nonce。加密和生成认证码：cipher.encrypt_and_digest(plaintext)：这个方法既加密数据，也计算出一个认证码（tag）。认证码可以用来验证数据在传输过程中是否被篡改。输出密文和认证码：ciphertext：加密后的数据。tag：Poly1305 算法生成的认证码，用来保证数据的完整性和真实性。ChaCha20-Poly1305 提供了 认证加密（AEAD），它不仅确保了数据的 机密性（通过加密）还确保了数据的 完整性（通过认证码）。cipher.encrypt_and_digest() 同时执行加密和认证操作，返回加密后的数据和认证码（tag）。解密时，使用相同的密钥和 nonce，并且需要提供正确的认证码来验证数据的完整性。这种加密方式广泛应用于安全通信协议，如 TLS、VPN 和现代加密货币应用中，因为它在速度和安全性方面表现出色。

原题：
from Crypto.Cipher import ChaCha20_Poly1305import oskey = os.urandom(32)nonce = os.urandom(12)with open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) as f:    plaintext = f.read()cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce)ct, tag = cipher.encrypt_and_digest(plaintext)print(f&quot;Encrypted Flag: &#123;ct.hex()&#125;&quot;)print(f&quot;Tag: &#123;tag.hex()&#125;&quot;)print(f&quot;Nonce: &#123;nonce.hex()&#125;&quot;)with open(&#x27;key.txt&#x27;, &#x27;w&#x27;) as key_file:    key_file.write(key.hex())

这是ChaCha20_Poly1305，它的原理，我还没看，这几天摆烂了，不想学习，看加密过程大概了解到：用key（密钥），nonce（只被使用一次的任意或非重复的数值）可以加密得到cipher，然后用cipher生成认证码ct和tag，用于防止密文被破解（具体过程不清楚）
原题是给了个txt的文本，里面给的东西很多（基本上是都i给你了），但是byd我最开始以为是截取长度再base91解出key（hex），没想到他是base92直接出然后用
这是解密：
from Crypto.Cipher import ChaCha20_Poly1305import binasciifrom Crypto.Util.number import *# 已知的 hex 数据hex_nonce = &quot;d8ebeedec812a6d71240cc50&quot;hex_tag = &quot;70ffcc508bf4519e7616f602123c307b&quot;hex_ciphertext = &quot;20408b9fc498063ad53a4abb53633a6a15df0ddaf173012d620fa33001794dbb8c038920273464e13170e26d08923aeb&quot;base92_key = &quot;3=t#sMX3?9GHSPdi4i^gk!3*(cH8S8XT2y&amp;?Tv4!?AGG=R]ZDy/PVVa+DqiXAH*&#125;DS&amp;Nn*a+@&lt;H,=!L&quot;decoded_key =0x173974535637a5ef30a116b03d00bd2fe751951ca3eaa62daec2b8f5ca5b6135decoded_key=long_to_bytes(decoded_key)# 将 hex 转换为字节nonce = binascii.unhexlify(hex_nonce)tag = binascii.unhexlify(hex_tag)ciphertext = binascii.unhexlify(hex_ciphertext)cipher = ChaCha20_Poly1305.new(key=decoded_key, nonce=nonce)plaintext = cipher.decrypt_and_verify(ciphertext, tag)print(&quot;解密后的数据:&quot;, plaintext.decode(&#x27;utf-8&#x27;))

![](屏幕截图 2024-11-15 213023.png)
蓝鲨的费马这是原题：
from gmpy2 import*from Crypto.Util.number import *from sympy import *flag=b&#x27;ISCTF&#123;********&#125;&#x27;m=bytes_to_long(flag)p=libnum.generate_prime(1024)q=libnum.generate_prime(1024)n=p*qe=0x10001 e=65537c=pow(m,e,n)d=inverse(e,(p-1)*(q-1))leak = (d+(pow(p,q,n)+pow(q,p,n)))%nprint(&quot;c=&quot;, c)print(&quot;n=&quot;, n)print(&quot;leak=&quot;, leak)

这个不是很难，有点难罢了：

然后代码是这样：
from gmpy2 import*from Crypto.Util.number import *from sympy import *c=n=leak=e=l=e*leak%nfor k in range (e):    if((l-1-k)%(e-k)==0):        p_and_q=(l-1-k)//(e-k)        a=p_and_q*p_and_q-4*n                        if(a&lt;=0):            continue        b=iroot(a,2)        if(b[1]):            p=(p_and_q+b[0])//2            q=(p_and_q-b[0])//2            d=pow(e,-1,(p-1)*(q-1))            m=pow(c,d,n)            print(long_to_bytes(m))

![](屏幕截图 2024-11-15 221522.png)
]]></content>
      <categories>
        <category>CTF</category>
        <category>密码</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/06/01/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>2024BaseCTF</title>
    <url>/2024/10/10/BaseCTF2024%E6%96%B0%E7%94%9F%E8%B5%9B%EF%BC%88%E5%A4%8D%E7%8E%B0%EF%BC%88%E6%8A%84%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[BaseCTF2024新生赛（复现（抄来的前面的没做，今个开始做吧&#x2F;&#x2F;2024&#x2F;10&#x2F;9
1.十七倍原题：  &#x2F;&#x2F;题目给的东西不少
#include &lt;stdio.h&gt;int main() &#123;    unsigned char flag[] = &quot;BaseCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;;        /**     * 由 (unsigned) char 决定，每个元素在内存中占 1 字节，即 8 位（8 个 0 或 1）     * 在内存中，“字符”保存的是其在“字母表”中是第几个字符     * 例如：     * B 即  66 在内存中存的是 01000010     * a 即  97 在内存中存的是 01100001     * s 即 115 在内存中存的是 01110011     * e 即 101 在内存中存的是 01100101     */    int i;    for (i = 0; i &lt; 40; i++) &#123;        flag[i] = flag[i] * 17;    &#125;    if (flag[0] != 98) &#123;  /* 下标是从 0 开始的 */        printf(&quot;CPU Error???\n&quot;);        return 1;    &#125;    /**     * 66 * 17 = 1122     * 如果在内存中保存 1122，会是 00000100 01100010     * 但是 unsigned char 决定了只能存 8 位，CPU 硬件会自动取低 8 位，即 01100010     * 01100010 即 98，所以 66 * 17 = 98     *      * 注意到 8 个 0 或 1 有 256 种可能，即 0~255     * 且取低 8 位即取模（取余数）256     * 你可以验证：1122 除以 256 商为 4 余数为 98     */    unsigned char cipher[] = &#123;         98, 113, 163, 181, 115, 148, 166,  43,   9,  95,        165, 146,  79, 115, 146, 233, 112, 180,  48,  79,         65, 181, 113, 146,  46, 249,  78, 183,  79, 133,        180, 113, 146, 148, 163,  79,  78,  48, 231,  77    &#125;;    for (i = 0; i &lt; 40; i++) &#123;        if (flag[i] != cipher[i]) &#123;            printf(&quot;flag[%d] is wrong, expect %d, got %d.\n&quot;, i, cipher[i], flag[i]);            return 1;        &#125;    &#125;    /**     * 如果 flag 是正确的，运算后会得到上面的数据。     * 如果是实数域运算，flag[i] * 17 = cipher[i]，那么 flag[i] = cipher[i] / 17     * 模了 256 后又是怎么样呢？学一下“模运算乘法逆元”吧。     */    return 0;&#125;



我们可以直接采用遍历求解：（因为原题中说的：第二大段注释中举了个例子说明98的由来，所以采用这种方法遍历（暴力求解就好了
for(int i=0;i&lt;40;i++)&#123;        for(int j=32;j&lt;128;j++)&#123;            if(j*17%256==cipher[i])&#123;                cipher[i]=j;                break;            &#125;        &#125;    &#125;



看看他们的wp，额，二进制不看，不会，看看乘法逆元：
乘法逆元我也不太会（悲，明个或今晚上学吧：
先写写：
根据题目我们可以知道：
y=(x*17)%256//y是cipher的数

根据乘法逆元公式：ax≡1 (mod p)，也可表示为ax≡1(mod f)。这个等式用中文描述就是a乘一个数x并模p等于1
反正就是（为什么不能语音（怒：上述y&#x3D;(x*17)%256&#x2F;&#x2F;y是cipher的数可以化为：
y=(x*17)%256//y是cipher的数根据乘法逆元可以求得（这个应该是类似公式之类的，等我一会看看）：x=(y*241)%256    241是怎么算出来的呢？可以通过扩展欧几里得原理求得。在 Python 中直接pow(17, -1, 256)就可以得出结果。(就是：241*17%256=1)//这是代码#include &lt;stdio.h&gt;int main() &#123;    unsigned char flag[] = &#123;         98, 113, 163, 181, 115, 148, 166,  43,   9,  95,        165, 146,  79, 115, 146, 233, 112, 180,  48,  79,         65, 181, 113, 146,  46, 249,  78, 183,  79, 133,        180, 113, 146, 148, 163,  79,  78,  48, 231,  77,   0    &#125;;    int i;    for (i = 0; i &lt; 40; i++) &#123;        flag[i] = flag[i] * 241;    &#125;    printf(&quot;%s\n&quot;, flag);    return 0;&#125;// BaseCTF&#123;yoUr_CrYpt0_1earNinG_5tarTs_n0w&#125;





2.ez_math数学会陪伴我一辈子吗？被迫复习了一点线代：
对角线为一的上三角和下三角行列式相乘是一
原题：
import numpy as npfrom Crypto.Util.number import *a, b, c, d = [getPrime(128) for _ in range(4)]point1 = a * dpoint2 = b * cmatrix2 = [[0, a, b], [0, c, d]]flag = b&quot;flag&#123;test_flag&#125;&quot;flag = bytes_to_long(flag)def randomArray():    upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]    low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]    for i in range(3):        for j in range(i+1, 3):            upper[i][j] = getPrime(128)            low[j][i] = getPrime(128)    result = np.array(upper) @ np.array(low)    return resultA = np.array([[flag, 0, 0]] + matrix2)B = randomArray()MAT = A @ Bprint(point1)print(point2)print(MAT)&#x27;&#x27;&#x27;8576375502929260759405580580475575628247376303152491185135665867218018570747770470862191594893036733540494554536608294230603070251013536189798304544579643[[73595299897883318809385485549070133693240974831930302408429664709375267345973630251242462442287906226820558620868020093702204534513147710406187365838820773200509683489479230005270823245  46106113894293637419638880781044700751458754728940339402825975283562443072980134956975133603010158365617690455079648357103963721564427583836974868790823082218575195867647267322046726830  161159443444728507357705839523372181165265338895748546250868368998015829266587881868060439602487400399254839839711192069105943123376622497847079185] [13874395612510317401724273626815493897470313869776776437748145979913315379889260408106588331541371806148807844847909  17025249852164087827929313934411832021160463738288565876371918871371314930048841650464137478757581505369909723030523  59510107422473463833740668736202898422777415868238817665123293560097821015330] [11314088133820151155755028207579196628679021106024798818326096960197933616112389017957501267749946871903275867785729  13883500421020573457778249958402264688539607625195400103961001780695107955462968883861677871644577542226749179056659  48528427402189936709203219516777784993195743269405968907408051071264464132448]]‘’‘

这个，怎么说呢，就是线代啊，虽说忘完了（思考
&#x3D;&#x3D;ok啊时隔三天在min_math2中又遇到了，发现mid_math2也不会，但在阿褚的鼎力协助下会了一点：&#x3D;&#x3D;

先分析代码（这个好像叫代码审计来着？（思考，好吧，好像不是。
代码审计（Code audit）是指以发现程序错误、安全漏洞和违反程序规范为目标的源代码分析。它是软件开发生命周期中的一个重要环节，旨在通过检查源代码来识别潜在的安全隐患、编码不规范之处以及可能引发的安全漏洞。
分析代码：randomArray():这个方法返回的result为单位矩阵：1（E，至于为什么，证明没看懂，正在看ing
返回的不是1但是，因为这个：我们的目的是求出flag，则用行列式求

&#x3D;&#x3D;呃呃呃呃，这个是行列式，我傻逼了，别骂我&#x3D;&#x3D;
&#x3D;&#x3D;行列式和矩阵的相乘的，额，运算规则是不一样的！！！忘完了，真得学吧，学了之后我不会也要加入408大军了吧&#x3D;&#x3D;
A=flag*(a*d-b*c)那么就容易知道：$$flag = |flag| = \frac&#123;|MAT|&#125;&#123;|A_&#123;abcd&#125;|&#125;$$EXP

$$flag &#x3D; |flag| &#x3D; \frac{|MAT|}{|A_{abcd}|}$$
代码(因为太晚了（其实不晚，但乏了），并且sage.all没装，明个再安装吧，这直接搬了现成的wp的代码：
from sage.all import *from Crypto.Util.number import *point1 = 85763755029292607594055805804755756282473763031524911851356658672180185707477point2 = 70470862191594893036733540494554536608294230603070251013536189798304544579643MAT = [[73595299897883318809385485549070133693240974831930302408429664709375267345973630251242462442287906226820558620868020093702204534513147710406187365838820773200509683489479230005270823245,  46106113894293637419638880781044700751458754728940339402825975283562443072980134956975133603010158365617690455079648357103963721564427583836974868790823082218575195867647267322046726830,  161159443444728507357705839523372181165265338895748546250868368998015829266587881868060439602487400399254839839711192069105943123376622497847079185], [13874395612510317401724273626815493897470313869776776437748145979913315379889260408106588331541371806148807844847909,  17025249852164087827929313934411832021160463738288565876371918871371314930048841650464137478757581505369909723030523,  59510107422473463833740668736202898422777415868238817665123293560097821015330], [11314088133820151155755028207579196628679021106024798818326096960197933616112389017957501267749946871903275867785729,  13883500421020573457778249958402264688539607625195400103961001780695107955462968883861677871644577542226749179056659,  48528427402189936709203219516777784993195743269405968907408051071264464132448]]print(long_to_bytes(det(matrix(MAT)) // (point1 - point2)))# b&quot;BaseCTF&#123;7E9328AF-784C-8AF5-AC10-D6A8FC0977A8&#125;&quot;





3.mid_mathok啊，sage没装好（悲，谁要是装好了请教教我（求。
原题：
import numpy as npfrom Crypto.Util.number import *a, b, c, d = [getPrime(128) for _ in range(4)]point1 = a * dpoint2 = b * cmatrix2 = [[0, a, b], [0, c, d]]flag = b&quot;flag&#123;test_flag&#125;&quot;flag = bytes_to_long(flag)def randomArray():    upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]    low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]    for i in range(3):        for j in range(i+1, 3):            upper[i][j] = getPrime(128)            low[j][i] = getPrime(128)    result = np.array(upper) @ np.array(low)    return resultA = np.array([[flag, 0, 0]] + matrix2)B = randomArray()C = randomArray()MAT = C @ A @ Bprint(point1)print(point2)print(MAT)&#x27;&#x27;&#x27;6554059682233302982688431550380899627373373707981434554060787828761841973423145151244176940366132774311848077675849486332018843894072137609985463616792271[[9259505595451159514948336330303511539525155092949382077995385373332083424570340733825203563332256599256361679775371565817159463557158551820090084800254999338417057682355404780422980119717238594927467956675771042145306399815569005775907169857728757334979422594358  3700462282298785820527479428312072678870010244861115107206951164684911761755437333209293039456840068340334559453608012512177623936248784897843503284633804083281388001236742261832974291349480314135560368365574114042082002559069958228523318326290833422846224288247  20791012146351643571145217310876690226642338279942557085580439219377325884045305279931904540467264182713135410067252835618936836675270813727053937054168296298149405902638242278868020381541490973458957704137657413376043351193] [3802535350808074374431476757195874789213113083310705049856269457737583463559458126494122484246497049005001474007088865512110432486291568737501434666990689483191924384489484665070592656641925905986397402822195880143437724155134584374613878027218950975919679551229  1519642544380087919293814751485424198320747098741960781639133554268321708273309194651985562222274023623071346914239982055028526526058064787882720065775210796950963778381575914964024929110539407721461321785325399699126116201001806816030960662346173275101476487421  8538097185709421082644083672229287227818939415260987123718318427750267353075860559170390896769087600458156859498331152566368881938040799840806164389020986990994328370205184734637870147251004626759120887684269603636183629300] [17987668490992083132878642797176089621188858356259455169173987325310681186627844776077058221612169421636403546746899152917309634315569997105261046388995579843528014810244648968375990949478033964619008761814039733347955609163  7188579142941521685422767412932555782658469950638690886255638896617687421517941457682493542615460990114218059246938237257830976937359020731335958068934235967457123039874441635435388736524907036941379695243043923900290273902  40388963560266769813551191613694768219344365780650048155838802242681775019274045964917142477325170274191702615504062392461666558731638338001971723737440974198823443420018559746335727687]]&#x27;&#x27;&#x27;



这个题和ez_math几乎一样，所以我直接放东西了（ai写的，因为不会用一些方法，直接让ai帮我写了，和ez_math不一样，看看吧：
import numpy as np  from sympy import Matrix  from Crypto.Util.number import long_to_bytes  # 定义两个点  point1 = 65540596822333029826884315503808996273733737079814345540607878287618419734231  point2 = 45151244176940366132774311848077675849486332018843894072137609985463616792271  # 定义矩阵，使用 sympy 的 Matrix  MAT = Matrix([      [          9259505595451159514948336330303511539525155092949382077995385373332083424570340733825203563332256599256361679775371565817159463557158551820090084800254999338417057682355404780422980119717238594927467956675771042145306399815569005775907169857728757334979422594358,          3700462282298785820527479428312072678870010244861115107206951164684911761755437333209293039456840068340334559453608012512177623936248784897843503284633804083281388001236742261832974291349480314135560368365574114042082002559069958228523318326290833422846224288247,          20791012146351643571145217310876690226642338279942557085580439219377325884045305279931904540467264182713135410067252835618936836675270813727053937054168296298149405902638242278868020381541490973458957704137657413376043351193      ],      [          3802535350808074374431476757195874789213113083310705049856269457737583463559458126494122484246497049005001474007088865512110432486291568737501434666990689483191924384489484665070592656641925905986397402822195880143437724155134584374613878027218950975919679551229,          1519642544380087919293814751485424198320747098741960781639133554268321708273309194651985562222274023623071346914239982055028526526058064787882720065775210796950963778381575914964024929110539407721461321785325399699126116201001806816030960662346173275101476487421,          8538097185709421082644083672229287227818939415260987123718318427750267353075860559170390896769087600458156859498331152566368881938040799840806164389020986990994328370205184734637870147251004626759120887684269603636183629300      ],      [          17987668490992083132878642797176089621188858356259455169173987325310681186627844776077058221612169421636403546746899152917309634315569997105261046388995579843528014810244648968375990949478033964619008761814039733347955609163,          7188579142941521685422767412932555782658469950638690886255638896617687421517941457682493542615460990114218059246938237257830976937359020731335958068934235967457123039874441635435388736524907036941379695243043923900290273902,          40388963560266769813551191613694768219344365780650048155838802242681775019274045964917142477325170274191702615504062392461666558731638338001971723737440974198823443420018559746335727687      ]  ])  # 计算行列式  det_value = MAT.det()  # 确保 det_value 是整数  det_value = int(det_value)  # 计算并转化为字节  result = long_to_bytes(det_value // (point1 - point2))  # 输出结果  print(result)b&#x27;BaseCTF&#123;E439646E-1768-18B3-DC4B-483C40C5340C&#125;&#x27;





4.two_squares这是原题：
from Crypto.Util.number import *flag=b&#x27;BaseCTF&#123;&#125;&#x27;m=bytes_to_long(flag)p=getPrime(128)q=getPrime(128)n=p*qe=65537c=pow(m,e,n)x=p^2+q^2print(&quot;e =&quot;,e)print(&quot;c =&quot;,c)print(&quot;x =&quot;,x)&quot;&quot;&quot;e = 65537c = 42330675787206041757903427737108553993012805007294570657461042152628982126538x = 209479773119142584969854470862023704936857416491817498021871883305658177375498&quot;&quot;&quot;



这个，额，就用sage.math提供的**two_squares(x)**方法简单点
（但是我勾八baishi好几个小时了都没弄好，最后向在线妥协了：
![](屏幕截图 2024-10-11 193356-1730478193189-1-1730478203311-3-1730478205411-5.png)
然后就直接这样：
from Crypto.Util.number import *import gmpy2from numpy import sqrtfrom sympy import Integere = 65537c = 42330675787206041757903427737108553993012805007294570657461042152628982126538x = 209479773119142584969854470862023704936857416491817498021871883305658177375498# p,q=two_squares(x)# p,q=int(p),int(q)# n=p*qphin=104509747531476793887796474699931064796411012732701008885442574088855832757992n=104509747531476793887796474699931064797057927926665485324022084015195490274051d=gmpy2.invert(e,phin)a=long_to_bytes(int(pow(c,d,n)))print(a)# b&#x27;BaseCTF&#123;0760becd-cefaab0b094d&#125;&#x27;



5.铜匠 （coppersmith好了，这个题完全涉及我的未知区域了，看了几小时的文章才看懂（主要是因为找以及有的东西没见过和以前的忘了
RSA高位攻击（coppersmith定理：：直接说结论吧：P_unknown_bits&#x2F;P_bits&lt;&#x3D;0.44就可以对p或q补全（前提是知道n，简单地说就是：以一个数的二进制（01）形式转换后：在最多有454（1024*0.44）位未知就可以用sage运用其中一些方法求出你想要的东西。&#x3D;&#x3D;byd又是sage，我还没弄好，结论大概就是这样，应该是对的（思考&#x3D;&#x3D;好了，你以为这就完了？理论上来说这就好了，但是解题时你会遇到各种各样的问题，比如这一题，wctm，他未知位超过了454，那就用爆破吧（暴力求解
我只能说数学看懂了，原理不知道，代码不会（因为byd要用sage
这个不错：&#x3D;&#x3D;RSA_高位攻击学习记录&#x3D;&#x3D;，可以看看
呃呃呃，公式块不会写（悲，C，不想学公式块咋写了，直接手搓吧：应该能看懂吧（思考，看不懂就搜吧，基本和那个链接一样反正。&#x3D;&#x3D;另外，不管是谁，sage你要是会的话请教教我，我装都装不好，只能online&#x3D;&#x3D;


OK啊，本世纪最大的小丑诞生了，没错就是我，这一题官方wp没用爆破，直接求就好了，其实也好，除了没用爆破，其他的都一样，看看官方代码：
他是455直接求解了，可能455也能？不晓得啊，应该是，好像就是能，但实际不行？搜的，不晓得
from Crypto.Util.number import *import gmpy2p_high = 14439249591349619691972392177790365247490839237199085979433418493254022567815148979672690178q_low = 90063199151369157959005663017593053931871580139169245885113098598755909124764417n = 18347545778876678838092757800261556931131930866012101566000425608407193858675622059415995283684230959320874387944052648148677918542763633503231962873204645415818139345588988936580526094727943067102768943117592654029397879665312089518191052154267343886226820785206334238961064175118262578895847281575656290248049404047727756356910896332939145136942219317065063060070725033146788186604738271846183709127655298440696824683099637827282095133642324657860714680107691622056420045091586609974536644773286992447027164350612852922016376888380895187804771279035652496676089183636450028327097084911908336202253562671798012457461enc = 15659576879410368237140555530527974801613150473447768911067611094143466009251385693099110691602954207905029692682380253595062935017486879899242785756448973466690818942065250284891341066578689696180061755610538867770441139827574063212967027249650509215685566103350688284041405586915563454117672061141919712416360596137520514412607512596079964611672166435592936417138352662031529414118312166411150736015788925026636845744110093161894267707446937939130745326244186579516665160036229715964182962542836836457885170975474737620430886449029488829662146456489724775166105816909257516908496172172266375617868819982791477888289e = 65537mod = pow(2,266)inverse_q_low = q_low.inverse_mod(mod) p0 = n * inverse_q_low % mod          PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = p_high * (2**721) + p0 + x * 2**266f = f.monic()out_p = f.small_roots(2**455,0.4)p = p_high * (2**721) + p0 + out_p[0] * 2**266print(p)assert n % p == 0q = n // int(p)phi = (p-1) * (q-1)d = inverse_mod(e,phi)m = pow(enc,d,n)print(bytes.decode(long_to_bytes(m)))#BaseCTF&#123;7074ddc3e006810688241196414e49e2&#125;



6.random_primes这个不那么难，只是我傻逼了，最开始以为是直接写就好，结果看到flag限位45
from Crypto.Util.number import *import randomdef gen_n():    primes=[getPrime(128) for _ in range(256)]    n = 1    for i in range(100):        n *= primes[random.randint(0,127)]    return primes,nflag=b&#x27;BaseCTF&#123;&#125;&#x27;m=bytes_to_long(flag)assert len(flag)==45primes,n = gen_n()e = 0x010001c=pow(m,e,n)print(&quot;n =&quot;,n)print(&quot;e =&quot;,e)print(&quot;c =&quot;,c)print(&quot;primes =&quot;,primes)

看限位45大概知道flag_bits为360，而给的素数是128位，大概三个就行了，然后直接爆破，爆破爽（馋
忘了那是个文本了，反正大概就是这样，这个不难
from Crypto.Util.number import *from gmpy2 import *# n,e,c,primes自己加吧for i in primes:    for j in primes:        for k in primes:            n1=i*j*k            phi=(i-1)*(j-1)*(k-1)            m=long_to_bytes(pow(c,pow(e,-1,phi),n1))            if b&#x27;BaseCTF&#x27; in m:                print(m)



7.basic额，这题我看不懂，所以只放个原题吧：
from Crypto.Util.number import *import socketserverimport osimport randomimport base64import stringflag = os.getenv(&#x27;GZCTF_FLAG&#x27;).encode()class Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b&#x27;&#x27;        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        try:            if newline:                msg += b&#x27;\n&#x27;            self.request.sendall(msg)        except:            pass    def recv(self):        return self._recvall()        def handle(self):        printable_chars = string.ascii_letters + string.digits + string.punctuation        optional=[b&#x27;A&#x27;,b&#x27;B&#x27;,b&#x27;C&#x27;,b&#x27;D&#x27;]        for _ in range(100):            secret= &#x27;&#x27;.join(random.choices(printable_chars, k=16)).encode()            select=random.choice(optional)            self.send(select)            enc=b&#x27;&#x27;            if select==b&#x27;A&#x27;:                enc=base64.b64encode(secret)            elif select==b&#x27;B&#x27;:                enc=secret.hex().encode()            elif select==b&#x27;C&#x27;:                enc=bytes_to_long(secret)                enc=str(enc).encode()            elif select==b&#x27;D&#x27;:                enc=[i for i in secret]                enc=str(enc).encode()            self.send(enc)            client_send=self.recv()            if client_send!=secret:                self.send(&quot;\nYou wrong!!!!!&quot;)                exit()        self.send(flag)        self.send(b&quot;\nConnection has been closed  =.=  &quot;)        self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):    passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passif __name__ == &quot;__main__&quot;:    HOST, PORT = &#x27;0.0.0.0&#x27;, 9999    server = ForkedServer((HOST, PORT), Task)    server.allow_reuse_address = True    server.serve_forever()



8.try_to_factor看不懂一点，这个先跳了
9.mid_math2这个经过了我的细细琢磨（复习线性代数知识以及在阿褚的鼎力协助下，算是明白一点了原题：
import numpy as npfrom Crypto.Util.number import *from sympy import Matrix  a, b, c = [getPrime(128) for _ in range(3)]d, e, f, h, i, j = [getPrime(1024) for _ in range(6)]A = [[a, b, c], [d, e, f], [h, i, j]]flag = b&quot;flag&#123;test_flag&#125;&quot;flag = bytes_to_long(flag)def prod(myList):    result = 1    for i in myList:        result = result * i    return resultdef randomArray():    upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]    low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]    for i in range(3):        for j in range(i+1, 3):            upper[i][j] = getPrime(128)            low[j][i] = getPrime(128)    result = np.array(upper) @ np.array(low)    return resulte = getPrime(18)N = getPrime(1024)C = randomArray()#MAT = C @ A @ BMAT = C @ Ac = pow(flag, e, prod(A[0]))print(MAT)print(f&#x27;c = &#123;c&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)&#x27;&#x27;&#x27;[[9194428734244577957135736828947112370812209206819996917633266069359894211949655026549592464237531352518967649750275097282532736237822915630766535634248987628113137246739472264614337707439494149796414126558156060870508338278038269649101921703583149322486905552569052814106532234864028314925118581658029792157851338427975728108000711353532410024128431635933014226306706319591106081211872  7052600738698435126221697697810087514520765619736355003187836563546493264420232197860875416948961661231812045406188307561458872254314061097960625042149316957446344556490001927621879295417925720004568332344856366002394724202261454916368122811414228043610804718983599804179657247820737462743875143882925818085495573474169110616761320858675303922740882169073395416895304752909979711051264  13094262565727554986668133240216117564284263232131011542877585146452802164148464500319291219458081531317231044962383872061004846788004747813785963603455919882739054992075130196548494850105124430477756818974520035883861936342117869122455996838023977818945511119955390136020375974150407580576040034808588694313922810340598787633148909527275716235390356737099830131958338026891256778602432] [7291452286171544741377496447735677778433522048452394999757158120018504601116506253897733192493798837108269469756414516913436198353934250444263790689101779479157541198872731006007031448329354826004420971505929629537584453480285628607579031078497417101681028600589030661495031531644755072500393418929237208836713910921969937998825721580514845395852889662758886414966066733340052235985735  5592919719754926663830816961667268104316637431189640788304536404157195458040686322901848820171568258023938724485177544141303597034389473064509506247034833050568643394732003598890104462382321956436508366359718039669456303596542945687737870352569084995858128262046585579724537002100295978230177579835256681774512205534970583421138287684468047290246482431883957170924203400422234299829407  10384135162743100269852365857770153822630076412853981379757028821332622753962517667857057209221058533163475030678127399042436975886694593504673386134198042731671320468065688239424934644173240507619471360908786669070898288638067852779718549009532013299792474712979659423962779677856135791013599792822988457540442172903145046394648862567656330868441373023488569784114231877910285319620037] [34946383530632295853235791100380055176686898072752599942691162027311662041417740482507624946631032260410440329949488242706004902881977357811370156793240362927747354453547446315050117795844866771053429455608334265986953931753411938119703800489233043034369650346216548318254326462336573090313788936967898128977445514764945671848611612198443909056919  26805677375585831510259621878357023272222175103906204143689109861471123435549853025410319713500257027420994041712736040084303902812241806295302385126726161281240831030434347236854521776375408982352155894199700974681768432734155312616453345950508256035721377179651166114898547487082749355033867559583905997404388549346221139007108462958001461826337  49768956277664050500387501949373949828589012443212214016088015478826178759698946452495063308332332373728223252613132611904477061717762261927498754849913008747980442098787524359755695519989286304445175440218168145037681791003471134417445542856715034633656861298596197935068562189476201463465706711744838395255326376049859058504891392128431832044455]]c = 11781599055433308033432930805524658061560499523533841161297213162869735414528038973998414585008473948613388691447093e = 160907&#x27;&#x27;&#x27;



这个怎么说呢，你会发现（作为正常的大一下以后（指学过线代的密码刚学儿一点的低手（我，自己骂自己不正常？）：这个东西没法解密啊，他都是未知的（这样说没错吧，思考
然后，看了wp和文章后：哦，这用了LLL算法，额，LLL（）算法貌似有很多用，但在这一题的用处是为了求出A[0]，但是题目只给出了MAT和MAT&#x3D;A@C啊，怎么办？所以不知道，然后是看了wp问了ai才知道LLL（）的（是不是说话重复了，无所谓，大概就是这样，然后就是：ai大法好：
&#x27;&#x27;&#x27;为何使用 LLL 算法在加密和解密标准 RSA 系统中，使用 LLL 算法可以优化以下步骤：安全性: LLL 算法用于破解一些基于 lattice 的密码学方案。通过找到相关的格基，可以尝试恢复加密密钥。密钥恢复: 如果攻击者获得了矩阵 CC 和 AA，LLL 减少可以找出与密钥相关的低维度向量，从而恢复 AA 的信息。这是因为在某些情况下，攻击者可以通过计算格基的方式得到与模数和私钥相关的线性关系。优化解密: 减少的格基可能揭示出某种数学结构，攻击者可以利用这些关系或结构来简化解密过程。总之，LLL 减少的主要目的是为了增加系统的安全性，并为可能的解密或攻击路径提供潜在的线索或结构。通过将复杂的线性代数问题转化为更简单的问题，LLL 算法能够帮助对各种加密系统进行分析和攻击。&#x27;&#x27;&#x27;

这里解密过程应该是主要用了他的第二，三个性质：直接运用LLL（）解出A的值，然后按部就班求出n和phi就行了（注意：A为三行三列矩阵，所以
n=A[0]*A[1]*A[2]

对了还有个问的ai：MAT，A，C的作用，你们看看吧，仅供参考：
&#x27;&#x27;&#x27;在加密算法中使用的矩阵 AA、随机矩阵 CC 以及 LLL 算法的目的可以总结如下：1. 矩阵 A作用：矩阵 AA 通常包含了一些特定的参数，比如素数，例如在加密过程中使用的模数。它可能构成了系统中的基础结构，用于进行加密和解密操作。在某些加密方案中，矩阵 AA 中的值可能用来定义密钥生成的规则，或者作为在密钥恢复过程中进行线性代数运算的基础。用途：通过 AA，可能可以推导出系统的模数和公钥，在加密或解密过程中与密文进行关联。2. 随机矩阵 C作用：矩阵 CC 是加密过程中的随机生成矩阵，通常会涉及到一些特定的线性变换或组合。这种随机性是增加算法安全性的重要部分。矩阵 CC 可能负责存储加密过程中所需的一些中间变量，或通过随机性引入不确定性，从而增加对密码的攻击难度。用途：别此矩阵可能是通过某种形式引入多样性和复杂性，以防止简单的线性分析或其他类型的攻击。3. LLL 算法目的：LLL（Lenstra–Lenstra–Lovász）算法是一种用于格基的算法，通过该算法可以进行基的简化，得到短向量。它通常在解决整数线性问题的时候非常有用。在此场景中的用途：利用 LLL 算法，可以从矩阵 AA 和 CC 中提取出有用的信息，试图查找短的线性组合以恢复潜在的密钥。在某些情况下，如果攻击者能够通过 LLL 算法找到和密钥相关的线性关系，他们或许就能够获得一个这些参数的线性组合（可能与密钥相关），从而实现解密。总结矩阵 A 提供了基础和框架，定义了与模数和密钥关联的结构。矩阵 C 提供了随机性和复杂性，增强了系统的安全性。LLL 算法 则是利用这两个矩阵进行线性分析、寻找短向量，从而可能揭露出密钥信息或其他重要参数。整个过程表面上看是一个线性代数问题，但核心目标是通过将随机和确定性的因素结合起来，以增加破解系统的复杂性和难度。攻击者若能成功应用 LLL 算法分析这两个矩阵，就可能会获得关于密钥的重要线索。&#x27;&#x27;&#x27;

然后就是解题代码了：
from sage.all import *from Crypto.Util.number import *MAT = ...c = ...e = ...def prod2(myList):    result = 1    for i in myList:        result = result * (abs(i) - 1)    return resultdef prod(myList):    result = 1    for i in myList:        result = result * abs(i)    return resultMAT = matrix(MAT)n = prod(MAT.LLL()[0])phin = prod2(MAT.LLL()[0])d = pow(e, -1, phin)flag = long_to_bytes(pow(c, d, n))print(flag)&#x27;&#x27;&#x27;n=17631408097218561823677756442318461073431191708388844474451658702449860378618765667127201508272748995177105608754133phin=17631408097218561823677756442318461073226384183145081523839893374579202673116878021014333222334572070116308167450800# b&#x27;BaseCTF&#123;8E2BD73F-9C10-F813-2CA4-B4B2DED4E961&#125;&#x27;

10.ez_log这一题，其实不难因为AES加密是对称加密，该给的东西都给你了，额，只是有一个补位不咋会，没事，现学了
然后这是原题：
from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b, getPrimefrom Crypto.Cipher import AESfrom random import randintflag = b&quot;flag&#123;test_flag&#125;&quot;pad = lambda x: x+b&#x27;\x00&#x27;*(16-len(x)%16)def encrypt(KEY):    cipher= AES.new(KEY,AES.MODE_ECB)    encrypted =cipher.encrypt(flag)    return encrypteddef decrypt(KEY):    cipher= AES.new(KEY,AES.MODE_ECB)    decrypted =cipher.decrypt(enc)    return decryptedflag = pad(flag)x = randint(10 ** 7, 10 ** 8)y = randint(10 ** 7, 10 ** 8)n = getPrime(28)z = pow(y, x, n)enc = encrypt(pad(l2b(x)))print(f&#x27;enc = &#123;b2l(enc)&#125;&#x27;)print(f&#x27;y = &#123;y&#125;&#x27;)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;z = &#123;z&#125;&#x27;)&#x27;&#x27;&#x27;enc = 33416570913716503492297352041317858420349510954381249751537743898024527101872454706181188441210166165803904185550746y = 82941012n = 228338567z = 51306718&#x27;&#x27;&#x27;

pad是为了将flag填充成16的倍数。decrypt（）是解密函数，直接调用就可以。其中ynz都给你了，我们可以得出x。
l2b(x)：这个函数的作用是将 x（在这里是一个长整型整数，通常是某种计算的结果）转换为一个字节串。在Python中，长整型数字可以表示为字节，通过 long_to_bytes，你可以得到其按字节表示的形式。这个函数来自于 Crypto.Util.number 模块。
因为enc &#x3D; encrypt(pad(l2b(x)))，加密时用了，所以解密时也要用一下。
哦，对了，其中z &#x3D; pow(y, x, n)，pow前面说过了，所以不再阐述。算了吧，还是说吧：z&#x3D;y**x（mod n）
就是通过这得出x的，再对x进行解密，这是代码：
from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b, getPrime  from Crypto.Cipher import AES  from random import randint  enc = 33416570913716503492297352041317858420349510954381249751537743898024527101872454706181188441210166165803904185550746y = 82941012n = 228338567z = 51306718pad = lambda x: x + b&#x27;\x00&#x27; * (16 - len(x) % 16)  def decrypt(KEY):       cipher = AES.new(KEY, AES.MODE_ECB)      decrypted = cipher.decrypt(enc)      return decrypted  #这里直接爆破了，但是不太推荐，因为数据量不大才用的def discrete_log(y, z, n):      for x in range(n):          if pow(y, x, n) == z:              return x      return None   &#x27;&#x27;&#x27;其实可以直接用这个：但这个要用sage（悲上加悲了属于是）enc = l2b(enc)G = GF(n)z = G(z)y = G(y)x = discrete_log(z, y)&#x27;&#x27;&#x27;x = discrete_log(y, z, n)  enc = l2b(enc)print(decrypt(pad(l2b(x))))#b&#x27;BaseCTF&#123;BF3DCONZ-67FE-ENZU-385S-CSNI13B2&#125;\x00\x00\x00\x00\x00\x00\x00&#x27;

11.没有n啊&#x3D;&#x3D;ok啊，这一题感谢guoql仙贝的大力帮助&#x3D;&#x3D;
先看原题：
from Crypto.Util.number import *import gmpy2flag=b&#x27;BaseCTF&#123;&#125;&#x27;m=bytes_to_long(flag)p=getPrime(512)q=getPrime(512)n=p*qe=65537phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)c=pow(m,e,n)x=pow(n,e,c)print(&quot;c =&quot;,c)print(&quot;e =&quot;,e)print(&quot;d =&quot;,d)print(&quot;x =&quot;,x)&#x27;&#x27;&#x27;c = 52453423663797600504896811946820841317615798875871627840172711423749946998217916744135290476795328543876098295227017753117609268701786914053599060330837226980969490439739651088710549890669593587642238827462108900683237797139569260570711611781514337884756698142193277516649805710242748531658979160170193283558e = 65537d = 54297831548863701092644190086258072883163378307246681513317422545902442650340916001357605211715836911877651782099787873046987096258918495734824011752504203578982947618784736181975847356304742402103468329660346526185908618978851982007496096394151821403282347897417590596861323293706611997134962231129075032641x = 40635864473997460751766935373772107585133301579524000836637683731949939348171187931595274511243052505604832873086269554842194695737052043633079044688826020656068356561856848814530947955429343483847291398607359454851926470168457852479044154798114087493843073091985855839008222762224952503563764527380033064437&#x27;&#x27;&#x27;

这个已知的东西不少，我们的目的是通过这些已知数求出n，这是解题思路：
![](C:&#x2F;Users&#x2F;ASUS&#x2F;Pictures&#x2F;Screenshots&#x2F;屏幕截图 2024-10-17 190749.png)
额，作为新手的我当然是看不懂的（但现在懂了，所以讲一下这东西：我们的目的是通过已知的2一些求出来n（感觉就是乘法逆元）然后，我写纸上了：

大概，应该，也许，可能或者能看懂吧（思考，简单地说，这些东西的目的是为了得出他们之间的关系，而我们的目的从求出n变成求出a就可以了。
怎么求出a？那当然是求出phic就好了，phic怎么求？那必须是byd的sage啊（sage还没弄，啊啊啊啊啊，CCCCCCCC，不急，小问题）
phic是：$$要计算ϕ(c)ϕ(c)，Euler Totient 函数的值，你可以按照以下步骤进行：
对于一般的正整数cc找出cc 的质因数分解：设cc 的质因数分解为：cp1k1×p2k2×…×pmkmc&#x3D;p1k1​
​ ×p2k2​
​ ×…×pmkm​
​
其中，p1,p2,…,pmp1​ ,p2​ ,…,pm​  是cc 的不同质因数。
应用 Euler Totient 函数公式：根据质因数分解，Euler Totient 函数ϕ(c)ϕ(c) 的计算公式为：ϕ(c)c(1−1p1)(1−1p2)…(1−1pm)ϕ(c)&#x3D;c(1−p1​
1​ )(1−p2​
1​ )…(1−pm​
1​ )$$简单地说就是质因数-1的乘积（思考）应该是
from Crypto.Util.number import *import gmpy2c = 52453423663797600504896811946820841317615798875871627840172711423749946998217916744135290476795328543876098295227017753117609268701786914053599060330837226980969490439739651088710549890669593587642238827462108900683237797139569260570711611781514337884756698142193277516649805710242748531658979160170193283558e = 65537d = 54297831548863701092644190086258072883163378307246681513317422545902442650340916001357605211715836911877651782099787873046987096258918495734824011752504203578982947618784736181975847356304742402103468329660346526185908618978851982007496096394151821403282347897417590596861323293706611997134962231129075032641x = 40635864473997460751766935373772107585133301579524000836637683731949939348171187931595274511243052505604832873086269554842194695737052043633079044688826020656068356561856848814530947955429343483847291398607359454851926470168457852479044154798114087493843073091985855839008222762224952503563764527380033064437#phic=(2-1)*(3-1)*(73-1)*(3967-1)*(6373-1)*(95592293-1)*(216465863-1)*(4744823012787277141-1)*(48245998253859255581546561942142167304434549996919484957120717763726325509833409296170471619434291990255044694414983821250538266717293535917534918221352198192885071310932646412147737114561229291373456448363184353049796801297876664512630305475226391199481032049429-1)phic=euler_phi(c)#要用sagedc=gmpy2.invert(e,phic)a=pow(x,dc,c)print(long_to_bytes(pow(c,d,a+c)))

12.exgcd（有点不懂，做题太少了，其实前面的也有很多不懂这是共模攻击的题，但是e1，e2不共素（所以没法直接套脚本（怒，但更改一下，其实差不多
这是原题：
from Crypto.Util.number import *flag=b&#x27;BaseCTF&#123;&#125;&#x27;m=bytes_to_long(flag)p=getPrime(1024)q=getPrime(1024)n=p*qe1=3747e2=2991c1=pow(m,e1,n)c2=pow(m,e2,n)print(&quot;n =&quot;,n)print(&quot;e1 =&quot;,e1)print(&quot;e2 =&quot;,e2)print(&quot;c1 =&quot;,c1)print(&quot;c2 =&quot;,c2)&quot;&quot;&quot;n = 27855350163093443890983002241607629119744539643165776358993469078731521668677421483556132628708836721737685936980427467856642738196111748018522018598646125626995613169001111504706363742194664774823604738939411512861441742683157275818500991834651769368178320088982759626122029956515159435424882855075032400667120376075618896752694718491438251810609878021717559466498493103257912108879328270813061231904227056671621363669388496383136964549879459562004569059185078204867346250733489663015417879915436157806942021693920206071715538430633494012923651469196048546309592946901609803631751035364478773126967010589504275776307e1 = 3747e2 = 2991c1 = 24426579024062518665031958216110619832653602343205488454298659533869220501923184793828421371206493659949730138867555889074137026401207985428160803910695088081370233571905915349589146504374710444468715701305061060934519410886010929009297226496448218819742287990364436349188987723637449590579092391100714056589967894609950537021838172987840638735592599678186555961654312442380755963257875487240962193060914793587712733601168204859917001269928487633954556221987632934190217367502677285906521385169669644977192556145782303526375491484736352799180747403161343130663661867413380222714012960607473395828938694285120527085083c2 = 6932145147126610816836065944280934160173362059462927112752295077225965836502881335565881607385328990881865436690904056577675885697508058289570333933837515526915707121125766720407153139160751343352211421901876051228566093038929625042619250168565502734932197817082848506826847112949495527533238122893297049985517280574646627011986403578166952789317461581409161873814203023736604394085875778774834314777046086921852377348590998381648241629124408514875110073073851913857329679268519229436092660959841766848676678740851087184214283196544821779336090434587905158006710112461778939184327386306992082433561460542130441825293&quot;&quot;&quot;

$$c_1&#x3D;m^{e1}\mod n\ c_2&#x3D;m^{e2}\mod n\ 通过扩展欧几里得计算：s_1e_1+s_2e_2&#x3D;s\ c_1^{s_1}c_2^{s_2}&#x3D;m^{s_1e_1+s_2*e_2}&#x3D;m^s最后得到的是m^{gcd(e1,e2)}，最后开个根即可$$
看公式感觉还行，但题解：我直接在代码注释说想法了
补充一下：最终的乘积再次对 n 取模，确保结果 m 范围在有效的明文范围内。
至于为什么采用pow(c,s,n)而不是pow(c,s)的原因：&#x3D;&#x3D;使用模运算是确保计算正确性、避免溢出以及与 RSA 加密定义保持一致的必要步骤。这也是为什么在实现中要特别强调使用模运算的原因。&#x3D;&#x3D;
from Crypto.Util.number import *from gmpy2 import *n = 27855350163093443890983002241607629119744539643165776358993469078731521668677421483556132628708836721737685936980427467856642738196111748018522018598646125626995613169001111504706363742194664774823604738939411512861441742683157275818500991834651769368178320088982759626122029956515159435424882855075032400667120376075618896752694718491438251810609878021717559466498493103257912108879328270813061231904227056671621363669388496383136964549879459562004569059185078204867346250733489663015417879915436157806942021693920206071715538430633494012923651469196048546309592946901609803631751035364478773126967010589504275776307e1 = 3747e2 = 2991c1 = 24426579024062518665031958216110619832653602343205488454298659533869220501923184793828421371206493659949730138867555889074137026401207985428160803910695088081370233571905915349589146504374710444468715701305061060934519410886010929009297226496448218819742287990364436349188987723637449590579092391100714056589967894609950537021838172987840638735592599678186555961654312442380755963257875487240962193060914793587712733601168204859917001269928487633954556221987632934190217367502677285906521385169669644977192556145782303526375491484736352799180747403161343130663661867413380222714012960607473395828938694285120527085083c2 = 6932145147126610816836065944280934160173362059462927112752295077225965836502881335565881607385328990881865436690904056577675885697508058289570333933837515526915707121125766720407153139160751343352211421901876051228566093038929625042619250168565502734932197817082848506826847112949495527533238122893297049985517280574646627011986403578166952789317461581409161873814203023736604394085875778774834314777046086921852377348590998381648241629124408514875110073073851913857329679268519229436092660959841766848676678740851087184214283196544821779336090434587905158006710112461778939184327386306992082433561460542130441825293s,s1,s2=gcdext(e1,e2)m=(pow(c1,s1,n)*pow(c2,s2,n))%n  #不会，但是按照自己理解写写吧：pow（c,s,n）=c**smod n=c**s，因为之前已经mod过n了所以值不会变，最后%n是为了规定m在模n的范围内，最后正常求就好？再看看吧，不会的太多了print(long_to_bytes(iroot(m,s)[0]))		#用[0]是为了保证为整数#b&#x27;BaseCTF&#123;feb7e1ae-a8f7-4fc4-8d6d-945a45cc3f6d&#125;&#x27;

正常情况下共模攻击应该是互素的（思考，s&#x3D;1就好了
12.5额，由中国剩余定理（sage有，这个是解题脚本def extended_gcd(a, b):    &quot;&quot;&quot; 返回 (gcd, x, y) 使得 ax + by = gcd &quot;&quot;&quot;    if a == 0:        return (b, 0, 1)    gcd, x1, y1 = extended_gcd(b % a, a)    x = y1 - (b // a) * x1    y = x1    return (gcd, x, y)def mod_inverse(a, m):    &quot;&quot;&quot; 计算 a 在模 m 下的逆元 &quot;&quot;&quot;    gcd, x, _ = extended_gcd(a, m)    if gcd != 1:        raise ValueError(&quot;Inverse does not exist&quot;)    return x % mdef chinese_remainder_theorem(c1, c2, n1, n2):    &quot;&quot;&quot; 根据中国剩余定理计算 m &quot;&quot;&quot;    # 验证 c1 和 c2 的合法性    if not (0 &lt;= c1 &lt; n1) or not (0 &lt;= c2 &lt; n2):        raise ValueError(&quot;c1 must be less than n1 and c2 must be less than n2&quot;)        # 计算 n1 和 n2 的逆元    n1_inv = mod_inverse(n1, n2)    n2_inv = mod_inverse(n2, n1)    # 根据 CRT 的公式计算 m    m = (c1 * n2 * n2_inv + c2 * n1 * n1_inv) % (n1 * n2)    return m# 示例c1 = 2  # 例：m % n1c2 = 3  # 例：m % n2n1 = 5  # 模数 n1n2 = 7  # 模数 n2m = chinese_remainder_theorem(c1, c2, n1, n2)print(&quot;The value of m is:&quot;, m)







13.winner？这个就是维纳攻击。
维纳攻击大概就是根据连分数找到你想要得到的值。
维纳攻击的原理维纳攻击主要依赖于连分数的性质和定理。连分数是一个数的连续分式展开，通过计算一个数（如e/N）的连分数，可以找到与这个数近似的两个数的比值（如k/d）。在RSA算法中，当满足一定条件时（如私钥d很小或公钥指数e过大），可以通过对e/N的连分数展开来找到对应的k/d，进而分解出N的两个质因数p和q，最终恢复出私钥d。维纳攻击的应用条件维纳攻击并不是对所有的RSA加密都有效，它主要适用于以下情况：私钥d的约数数量较小，或者d本身很小。公钥指数e过大或过小，特别是当e与N（即p和q的乘积）的比值接近某个整数的倒数时。在这些条件下，维纳攻击能够利用连分数的性质快速推断出私钥d的值。维纳攻击的意义维纳攻击的存在揭示了RSA算法在特定条件下的脆弱性。它提醒我们在设计和使用RSA加密系统时，需要合理选择公钥和私钥的参数，以避免被维纳攻击等数学方法破解。同时，维纳攻击也为密码学领域的研究提供了重要的思路和启示，推动了密码学的发展和进步。综上所述，密码学中的维纳攻击是为了解决RSA公钥加密算法在特定条件下的安全问题，通过数学方法恢复出私钥d，从而实现对密文的解密。

但是很遗憾，这题并不是主要适用条件之一
这一题主要是根据他给的PQ关系和leak来判断是否适用维纳攻击，以及对PQ的求解
这是原题：
&#x3D;&#x3D;哦，对了，没错这一题又要用sage，没错，我还是没弄好sage（悲上加悲&#x3D;&#x3D;
from Crypto.Util.number import *import decimalflag=b&quot;BaseCTF&#123;&#125;&quot;m = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)n=p*qe=65537c=pow(m,e,n)print(&quot;e =&quot;,e)print(&quot;c =&quot;,c)decimal.getcontext().prec = 648P=decimal.Decimal(p)Q=decimal.Decimal(q)leak=decimal.Decimal((3*P*Q-1)/(3*Q*Q))print(&quot;leak =&quot;,leak)&quot;&quot;&quot;e = 65537c = 11032748573623426359632659657114807044712138586316710250985606809252700461490504487308849626514319062562557448839550994242999334882617031487618174168038491566640081840111747765753878087564318833273878755416584962921669911444225959335274753391800995531023212276838665202257007640354237043291129197348884914956663597240094662207929658519596987351984403258345205873566463643624175318315064440456858013874962784792564480286904620663695194689839431808082976248378509181327101557380978849545906691903896662095520288964101796965095129861467059775556110616007889846240936219381379219605528051627402300580239311202137582442057leak = 0.829374344780877053838760251345359097311540811993463349625630085472892814959843248358036249898871908548743719153319438638517170060651237635838827482534816419091949205584951292517303330452910012749674475329235689229498752425379611083979518257734473992186831474208400813283887045691145481237726578827559198828469462343342343287720369159899636816373592067698883361360269728719786071024354151682314608072902347335691012713629816579496252896260869382806838857194293618332286500427694077400072428506897829689703872985954772105672992293334668485358785863779749153981721900135318166811250762946069962348114491411585418993494561587403918162681937152503739843&quot;&quot;&quot;

这是官方题解思路：$$leak&#x3D;\frac{3PQ-1}{3QQ}\ leak&#x3D;\frac{P}{Q}-\frac{1}{3Q^2}\ \left|leak-\frac{P}{Q}\right|&#x3D;\frac{1}{3Q^2}&lt;\frac{1}{2*Q^2}\ 之后计算leak的连分数，即可得到p和q$$但官方代码我看不懂，不过还是贴出来吧：
e = 65537c = 11032748573623426359632659657114807044712138586316710250985606809252700461490504487308849626514319062562557448839550994242999334882617031487618174168038491566640081840111747765753878087564318833273878755416584962921669911444225959335274753391800995531023212276838665202257007640354237043291129197348884914956663597240094662207929658519596987351984403258345205873566463643624175318315064440456858013874962784792564480286904620663695194689839431808082976248378509181327101557380978849545906691903896662095520288964101796965095129861467059775556110616007889846240936219381379219605528051627402300580239311202137582442057leak = 0.829374344780877053838760251345359097311540811993463349625630085472892814959843248358036249898871908548743719153319438638517170060651237635838827482534816419091949205584951292517303330452910012749674475329235689229498752425379611083979518257734473992186831474208400813283887045691145481237726578827559198828469462343342343287720369159899636816373592067698883361360269728719786071024354151682314608072902347335691012713629816579496252896260869382806838857194293618332286500427694077400072428506897829689703872985954772105672992293334668485358785863779749153981721900135318166811250762946069962348114491411585418993494561587403918162681937152503739843from Crypto.Util.number import *cf = continued_fraction(leak)convers = cf.convergents()for pkd in convers:    # possible k, d    pp, pq = pkd.as_integer_ratio()    pp=int(pp)    if pp.bit_length()==1024 and isPrime(pp):        flag=long_to_bytes(int(pow(c,inverse(e,pp-1),pp)))        if b&#x27;Base&#x27; in flag:            print(flag)            break#b&#x27;BaseCTF&#123;9431ee53-5d5c-4b0b-956f-1eafff6c9e87&#125;&#x27;

来看看石氏是时试师傅的题解，这个我能看懂：哦，对了，能看懂不等于我会
这个是先将leak用连分数表示
cf.numerator(i)是取对应次数的连分数的分子
cf.denominator(i)是取对应次数的连分数的分母
而符合质数的分子分母就是对应的p和q，然后常规解题即可
cf = continued_fraction(leak)for i in range(1000):    k = cf.numerator(i)    x = cf.denominator(i)    if isPrime(x) and is_prime(k):        print(k,x)        p,q = k,x        break long_to_bytes(int(pow(c,inverse_mod(e,(p-1)*(q-1)),p*q)))b&#x27;BaseCTF&#123;9431ee53-5d5c-4b0b-956f-1eafff6c9e87&#125;&#x27;     



14、没有n啊pro原题：（直接搬了，懒了）
from Crypto.Util.number import *import gmpy2flag=b&#x27;BaseCTF&#123;&#125;&#x27;m=bytes_to_long(flag)p=getPrime(128)q=getPrime(128)n=p*qe=65537phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)assert d&lt;phic=pow(m,e,n)print(&quot;c =&quot;,c)print(&quot;e =&quot;,e)print(&quot;d =&quot;,d)&quot;&quot;&quot;c = 78919950899709764543039048006935881842075789773495004639436106636461009323420e = 65537d = 13002488326322253055272696035053386340217207134816593767440035447757509399233&quot;&quot;&quot;

根据题目判断phi为256位，已知c,d,e的话，我们可以根据d&#x3D;pow(e,-1,phi)      &#x2F;&#x2F;d&#x3D;gmpy2.invert(e,phi)列出可能的phi的值然后进行爆破
应该和第十一题没有n啊差不多，不对貌似，啊啊啊啊，被折磨了，晚上问仙贝吧
看得懂官方咋解的了，先放这吧：（写的有注释，能看懂应该）
# -*- coding: utf-8 -*-import itertoolsfrom Crypto.Util.number import *import gmpy2from more_itertools import factorfrom sympy import isprimec = 78919950899709764543039048006935881842075789773495004639436106636461009323420e = 65537d = 13002488326322253055272696035053386340217207134816593767440035447757509399233p_bits=128q_bits=128def get_phi(e, d):    k_phi = e*d -1    result = []    for k in range(e,2,-1):        if k_phi % k == 0:            tmp = k_phi // k            if int(tmp).bit_length()==p_bits+q_bits:                result.append(tmp)    return resultdef main():    phi_list = get_phi(e,d)      count = len(phi_list)    print(f&quot;有&#123;count&#125;个可能的&quot;)    count = 0    for phi in phi_list:        count += 1        print(f&#x27;&#123;count&#125;尝试爆破 &#123;phi&#125;&#x27;)        # factors 通常是一个列表，其中每个元素都是一个元组，元组的第一个值是质因子，第二个值是该质因子的幂。        factors = factor(phi)          result = []        # 这是将factors元组改为全部是由质因子组成的列表        for i in factors:            num, times = int(i[0]), i[1]            result += [num] * times        # 进行简单的检查        if len(factors)&gt;1:            s = set()            # 形成唯一的质因子组合            for r in range(1, len(result) + 1):                combination = list(itertools.combinations(result, r))                for i in combination:                    s.add(i)            ans=[]            # 遍历所有质因子组合进行相乘得到可能的p-1            for i in s:                tmp=1                for j in i:                    tmp=tmp*j                ans.append(tmp)            # 对可能的p-1进行验证            for num in ans:                if int(num+1).bit_length()==p_bits and isprime(num+1):                    p = num+1                    q = phi // num + 1                    if isprime(q):                        n = p * q                        flag=long_to_bytes(int(pow(c,d,n)))                        if b&#x27;BaseCTF&#x27; in flag:                            print(flag)                            returnif __name__ == &#x27;__main__&#x27;:    main()



15、哎呀数据丢失了这题涉及了证书分析，虽然是最简单的证书分析，但我还是不会，但在gouql以及Naby师傅的讲解下会了一点，所以写写
看懂这个文章，这一题大概就会了：手撕PEM密钥（RSA） | Tover’s Blog   （里面的hex是十六进制并非是二进制）
说几句证书相关的关键点，一般来说手撕确实的证书分析就是把数据base64解密一下再转十六进制分析。接下来就是找02开头的数据，然后看02后面的数据是不是跟着长度（一般根据n的bits来判断）如果不对，那就从新开始，删去第一个字符在进行base64解密，依次反复知道正确。

原题：
from Crypto.Util.number import *from gmpy2 import *from Crypto.PublicKey import RSAflag=b&quot;&quot;m=bytes_to_long(flag)rsa=RSA.generate(1024)c=pow(m,rsa.e,rsa.n)with open(&quot;out&quot;,&#x27;wb&#x27;) as f:    f.write(long_to_bytes(c))private_key=rsa.exportKey(&quot;PEM&quot;)with open(&quot;pri.pem&quot;,&#x27;wb&#x27;) as f:    f.write(private_key)



其中关键点在于：
1、对base64数据进行hex转化，这个工具有。其中如果转化失败可以删除末位或首位（我不晓得咋判别，只能建议自己先试末位）2、30就是Sequence的tag，82就是说接下来后两个bytes是这个Sequence的长度，即0x025d个bytes，也就是剩下全部都是。接着的020100就是整数0，其中02是整数的tag，01是这个整数占1byte，00是value同样的方法也可以解02818100a0...和后面其他整数（其实生成的私钥PEM只有整数-）3、接下来就是正常的rsa解密，但是我没看懂为什么要用out（悲，教教我）此证书解密获得数据顺序：3082025d  	# Begin Sequence: len=0x025d0201  		# Version: (len=0x01)00028181		# n: (len=0x81)00a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef0203		# e: (len=0x03)010001028180		# d: (len=0x80)0f8270c496903bf3e3ec4912450f15edc81cb1fcf4b154615aee11fbd428e64d402b5a8d66d5f770358f3e6df935b324e8d5349c83d7c992a5982249a31734acb1db19c4c8d829267514bc1ef7bbfbe242d4350f67a002a56d33e56d1a94adc71c68f020dc39ab7d0064c111b164e26ba0698dc94a03cdfd516ffd966e8779490241		# p: (len=0x41)00ca97e49c058237f96e99118ce383f91912cba1163de9236181ff754ef3ef1a260fac8d2d9aee866d51a8b6836983b05

题解：
from Crypto.Util.number import *from gmpy2 import *from Crypto.PublicKey import RSAn=0x00BD278484122AEF9A69EC647290219DED06EDD2B7611721B326850B2F5060DAEED7694356667C479CA9CCB6969F4FBE6DC7FA6759ACA21D8A96A881A8E4A0217732757E649D503191511FA96DA42ED1DA2FA3BC8C9C65FBD9C0DD6F430359AC45E455D32C5B0EA29D21E647FF80E50ABCBB80F76ADB67007A04E85DBAEB4C8F1De=0x010001d=0x2265E355593071AE3501062B4746B5BF7AF918CEBC5B46879BC3AA0B0AA4F26B68C4FDB7E29F4B2E943A6421F40ABE689C6B4F0C21B6C184886D5056F46CA26908540EC07B82AD47E667971A01FAC6162E93A7FC61AED5660F826AEBA34D78ACCD18FC59E7921701F10FF51D52883706B864287CFDB34E309C93829D29D867C9with open(&quot;G:\out&quot;,&#x27;rb&#x27;) as f:    c=f.read()    m=bytes_to_long(c)    print(long_to_bytes(pow(m,d,n)))&#x27;&#x27;&#x27;3082 025C0201 0002 81 81 00BD278484122AEF9A69EC647290219DED06EDD2B7611721B326850B2F5060DAEED7694356667C479CA9CCB6969F4FBE6DC7FA6759ACA21D8A96A881A8E4A0217732757E649D503191511FA96DA42ED1DA2FA3BC8C9C65FBD9C0DD6F430359AC45E455D32C5B0EA29D21E647FF80E50ABCBB80F76ADB67007A04E85DBAEB4C8F1D02 03 01000102 81 80 2265E355593071AE3501062B4746B5BF7AF918CEBC5B46879BC3AA0B0AA4F26B68C4FDB7E29F4B2E943A6421F40ABE689C6B4F0C21B6C184886D5056F46CA26908540EC07B82AD47E667971A01FAC6162E93A7FC61AED5660F826AEBA34D78ACCD18FC59E7921701F10FF51D52883706B864287CFDB34E309C93829D29D867C902 4100C602 81 80 2265e355593071ae3501062b4746b5bf7af918cebc5b46879bc3aa0b0aa4f26b68c4fdb7e29f4b2e943a6421f40abe689c6b4f0c21b6c184886d5056f46ca26908540ec07b82ad47e667971a01fac6162e93a7fc61aed5660f826aeba34d78accd18fc59e7921701f10ff51d52883706b864287cfdb34e309c93829d29d867c9&#x27;&#x27;&#x27;

]]></content>
      <categories>
        <category>CTF</category>
        <category>密码</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitMQ下载配置与demo测试</title>
    <url>/2025/06/17/rabbitMQ%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%B8%8Edemo%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[rabbitMQ下载配置与demo测试下载与配置文件先下载Erlang  https://www.erlang.org/downloads  ，找到符合自己windows的版本下载就好。
为什么要先下载这个东西，因为rabbitmq没法直接在windows上直接运行，因为我是windows，所以找到的方法就是这个，其他系统可以自行寻找方法。
下载之后安装，记住安装路径然后配置到环境变量，各位到rabbitmq了估计已经配过Java，MySQL和redis之类的了，方法差不多，但是注意：下载好的Erlang OTP中间是有空格的要改为ErlangOTP再添加到环境变量。（环境变量是不识别空格和中文的）
然后下载rabbitmq，https://www.rabbitmq.com/download.html  ，选择 “Windows Installer” (.exe) 版本下载。然后安装，配置环境变量，注意：rabbitmq的不是bin而是sbin
然后就能启动服务了：
# 安装rabbitmq的服务rabbitmq-service install# 启动rabbitmq的服务rabbitmq-service start

RabbitMQ 自带 Web 管理页面，需要安装插件:
rabbitmq-plugins enable rabbitmq_management

访问地址：

http://localhost:15672
默认账号密码为：guest &#x2F; guest

如果打不开可以尝试刷新几次，如果还是打不开清理一下换从重新启动服务即可
demo测试额，其实我不会rabbitmq，只知道她大概是个什么东西，所以扒了一个demo：
该项目实现了一个基于Spring Boot和RabbitMQ的消息队列基本功能，主要包括：

RabbitMQ配置 RabbitMQConfig ：

创建持久化队列 demo.queue
定义直连交换机 demo.exchange
绑定队列与交换机使用路由键 demo.key


消息生产者 MessageProducer ：


public void send(String message) &#123;    rabbitTemplate.convertAndSend(        RabbitMQConfig.EXCHANGE_NAME,        RabbitMQConfig.ROUTING_KEY,        message    );&#125;

 消息消费者 MessageConsumer ：
@RabbitListener(queues = RabbitMQConfig.QUEUE_NAME)public void receive(String message) &#123;    System.out.println(&quot; [x] Received: &quot; + message);&#125;

启动时自动发送测试消息 RabbitMqDemoTestApplication ：
@Overridepublic void run(String... args) &#123;    messageProducer.send(&quot;Hello from Spring Boot and RabbitMQ!&quot;);&#125;

当前实现功能：

基本的消息生产消费流程
Spring Boot与RabbitMQ集成
直连交换机模式的消息路由
控制台打印发送&#x2F;接收记录

]]></content>
      <categories>
        <category>-java -技术栈 -rabbitMQ</category>
      </categories>
      <tags>
        <tag>-java -技术栈 -rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在博客上传图片</title>
    <url>/2025/08/03/test01/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>test02</title>
    <url>/2025/08/03/test02/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>2024金盾信安杯</title>
    <url>/2024/11/21/%E9%87%91%E7%9B%BE%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[金盾密码1.Madoka Runes直接对着表单找就能找到密码：
![](屏幕截图 2024-11-30 104213.png)
输入密码直接出：
![](屏幕截图 2024-11-30 104306.png)
2.ezrsa列好同余式用中国剩余解同余式直接出message然后开九次方再转字节就好
from sympy.ntheory.modular import solve_congruenceimport numpyfrom Crypto.Util.number import long_to_bytesn_list= [66713068295640123413518043679913370923560077389016834699625591280879282047385580519245403302207114741281472997841541531287076973224279941649021535158376552494753299204575589142430284284245902413434936761821799053759034189893017134579658955719886273361722719112743586542747088480330917580156612938839250815003, 93220359729942518400923319353609855683086052837300675001244736571202233288801372553449408397689671981434057617518899402068905085286369656470335384345232065925153852793862944459424133537991621353691699611625715366974136180583843591508153614052037629606307298558367556655731098521869053032772401730403014449411, 52202773445480937424957100107218762961120283036868010272682251953657674323304499771956016361962421205773156515507563827756643249104742340232742821376488784769891503342865868526919624818397054897905012127075859262952310097157907061344025347963650086443568680953905161157142612464840961117362620801749842408879, 82553091456291336768427636001211333148350777177895589619884526855175557207820633168970479619932906390584318202289854140553376548714411052752572009881543144730480476077880021537960949338405404958761168462246680451456125133754632997631949332320326017613289694983606666716680033606392964861804003584352680590087, 126128435524890593300334615443194513842505260782298991058088278168395895439505633982038040121402360495508323195308297803504735565186008100115370181050483351447644843345197960248620729714988601407534725902209206970706208957109895421381133644050169949239120391954419828419646235622192096983089233429399798724487, 147720770377839100046936497325485136233566856174851147500154290566277684557076944335857851098373121814105829685203159352831436378953250080092174133899668012220790232079503109510689810335337728388773927584457619779716463492595401880008310538176873629037401466975901825628623051950211929925214837578332196553599, 124745293442434036385822462573709029035838193243455140374004343372128515081182349880050066834995439331895246886612935567956942945644079345244280145073777541185777585728280312507028128615465026099188525829472122192943136139654002445255523350717509722226068753864376920017221041478273347340655965581264836805623, 64656553220163718805421487264999277997892395292051840710229549012813342103500529051439814363514417257605481961558538034337044004386537267801729555014122714842391331402276971310101298482954289819202770742743469979203276082437481909854637859797102334245371638799858873873188431752871644960079701293335747461831, 154462961163638672730309927702785192434305799838715175474990142746477464921396636812042793324143787346439455100764604617253217478519575381751036655163922606997960615852053060424250051534473828208356751768540768480213916080575159287230278791786807130716553816283037177870759790969384364642653232602468977815247]c_list=[51005516677417731886422613156402193350848583130533301906631992184482032048070107769818228079761720652832901023407822071655421580929907698799917933792960386846321370913559830272810379334182054783031538600198349058002169866824222330811827319616021940546950576540874306599558331332151055146737648080935494708588, 2041821123943473753926018035036127142293912801344695164334852819344638501433889053269955640381265246796708182948891351463478165192547358805280444112021688736247730161578747136357928895397269414940719487328949498438102882593196857341527917555021413367950508316840335830689597383465186358872674808025884021885, 46039089253322895811415983657459035212735944272443483136853555344667290454119007801590490041259097151897732463907281406082335077604849132078446981231884370863820232336507275455767858612185246444188147542289218495584026583448273138219905723711108672612950627623799697592779175874022447423932452148543363787640, 2141453012108157552120303062697739340853570994155675106097651019594420129141220901608419609082415135997293880005773756263389204887711558521855045106895075772213924319456997007171536138494274692890230609458290192980986669338031109788977632895632700245278069147479684426240615061064967367694067860411487423629, 76749087885794868408562971424611464076430009398548197992247726105066117869497135062312665153772469258809032481701272674637826659858835954148415069808346193613807990801293969464455284990574537791095652240744633974209776335844454832745233667455060558077310143770445403006416969005307667369727581132297960295340, 129889778177138425060084420953465203875702152174072537346221842914157406769944362646320734563342499686995626438417203633387851527307925692308799272755919745234368065011417961931673684360135410907645818314090652813758836919104618375252457260402923145245889643621469138808848260838951643210609251572858120327495, 108052613612357352725536091796067255652024419037660964052217185481829734452037779785712215364053116702484384622526267250489021108209478623969497489177944680864365447787229766222546592710250224997176901299205943666999952675444279695627743788911406784072960143874125846847184624670127441248507191247442198460789, 25928340017378545972137564258602345053659415847643859318668245604506696128407382577187489651429812610536514435867501876671515838666597930094267436053423009057513573482499095162969953109513790712156495250568946074742211364960292725805474100283556046328318406696121063618778241916883747109525050277568846023327, 5719067069866090256610955425807298842117899833885283417646439095103501424652337751644977233509637214830422145008935269688470956058326551761160898415661754588089616594231873985715403389476818739027591464587460581924534479591703919621116231727841975375866296368110957023963777324175359081722392018178256892283]# 创建同余方程列表,便于后续求messagecongruences = []for i in range (9):    congruences.append((c_list[i], n_list[i]) )# 使用中国剩余定理解同余方程组,得出messagemessage, _ = solve_congruence(*congruences)# 定义计算整数 n 次方根的函数,因为直接开九次方开不出来，用这个方法可以对大整数开n次方def integer_nth_root(value, n):    &quot;&quot;&quot;返回 value 的整数 n 次方根&quot;&quot;&quot;    low, high = 0, value    while low &lt;= high:        mid = (low + high) // 2        mid_pow = pow(mid, n)        if mid_pow == value:            return mid        elif mid_pow &lt; value:            low = mid + 1        else:            high = mid - 1    return highm = integer_nth_root(int(message), 9)print(&quot;flag:&quot;, long_to_bytes(m))

3.(misc)esabRcBg1cNg9oFgpkdkNodoVoxkhsxsJoxk9kFkBoFglkFghktkxoxc9cFkls5kNodoBoNotg5klcxclgVgZ8BkdklkhkpgBo9o9cFkRopkxgpkdkpkdklcpgFgRoZoVodk5gpktgRg1sFkdk1k9spgdcxk1sBcpktkBc1sdkdoJodsBslotc1sBsxkJgxsBoloBk5ctghk9opgRoFgJoBg5cdo9cFg5c9oVoxsFsBgJgxoxk5oBcpklg5o1kVgdkFgBs9gRoloJ8ZoNoRgpslkVopk
发现正常情况下无法解码，反转：kpoVklspgRoNoZ8JoloRg9sBgFkdgVk1o5glkpcBo5kxoxgJgBsFsxoVo9c5gFc9odc5gBoJgFoRgpo9khgtc5kBoloBsxgJkxsBs1ctolsBsdoJodkds1cBktkpcBs1kxcdgps9k1kdkFs1gRgtkpg5kdoVoZoRgFgpclkdkpkdkpgxkpoRkFc9o9oBgpkhklkdkB8ZgVglcxclk5gtoNoBodoNk5slkFc9cxoxktkhgFklgFoBkFk9kxoJsxshkxoVodoNkdkpgFo9gNc1gBcR
![](屏幕截图 2024-11-30 121011.png)
然后basebasebase解码直接出：
![](屏幕截图 2024-11-30 121130.png)
详细的base过程：
![](屏幕截图 2024-11-30 121226.png)
]]></content>
      <categories>
        <category>CTF</category>
        <category>密码</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一次测试</title>
    <url>/2025/06/02/%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[
shishi
https://i-blog.csdnimg.cn/blog_migrate/b35fbbc13e7eb8df543f6ab255f0319b.jpeg


]]></content>
  </entry>
</search>
