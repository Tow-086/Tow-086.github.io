<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025Lilctf(Reverse)</title>
    <url>/2025/08/15/2025Lilctf(Revese)/</url>
    <content><![CDATA[2025Lilctf(Reverse)1.ARM ASM发现是apk，放到jadx看一下，发现：

然后ida打开看到：

找到这三个关键函数以及：

推测是变表和移位的base64，扔给ai分析一下，生成脚本：
import base64# 自定义Base64表custom_b64_table = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ3456780129+/&quot;standard_b64_table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;# 目标密文target_b64 = &quot;KRD2c1XRSJL9e0fqCIbiyJrHW1bu0ZnTYJvYw1DM2RzPK1XIQJnN2ZfRMY4So09S&quot;# 转换到标准Base64def to_standard_b64(s):    return s.translate(str.maketrans(custom_b64_table, standard_b64_table))# 解码Base64std_b64_str = to_standard_b64(target_b64)decoded = base64.b64decode(std_b64_str)data = list(decoded)  # 解码后的48字节数据# 移位逆操作（每3字节一组）def reverse_shift(data):    result = []    for i in range(0, len(data), 3):        # 第1字节：循环右移3位（加密时循环左移3位）        b0 = data[i]        b0 = ((b0 &gt;&gt; 3) | (b0 &lt;&lt; 5)) &amp; 0xFF                # 第2字节：循环左移1位（加密时循环右移1位）        b1 = data[i+1]        b1 = ((b1 &lt;&lt; 1) | (b1 &gt;&gt; 7)) &amp; 0xFF                # 第3字节不变        b2 = data[i+2]        result.extend([b0, b1, b2])    return result# 置换表tt0 = [0x0D, 0x0E, 0x0F, 0x0C, 0x0B, 0x0A, 0x09, 0x08,       0x06, 0x07, 0x05, 0x04, 0x02, 0x03, 0x01, 0x00]# 构造逆置换表inv_t = [0] * 16for i in range(16):    inv_t[t0[i]] = i# 三轮变换逆操作（正确密钥）def reverse_blocks(blocks):    # 块0：使用密钥 t0    block0 = [blocks[0][i] ^ t0[i] for i in range(16)]    block0 = [block0[inv_t[i]] for i in range(16)]        # 块1：使用密钥 t0    block1 = [blocks[1][i] ^ t0[i] for i in range(16)]    block1 = [block1[inv_t[i]] for i in range(16)]        # 块2：使用密钥 t0⊕1（关键修正！）    key2 = [b ^ 0x01 for b in t0]    block2 = [blocks[2][i] ^ key2[i] for i in range(16)]    block2 = [block2[inv_t[i]] for i in range(16)]        return block0 + block1 + block2# 步骤1: 移位逆操作data = reverse_shift(data)# 分块（16字节/块）blocks = [    data[0:16],   # 块0: 0-15字节    data[16:32],  # 块1: 16-31字节    data[32:48]   # 块2: 32-47字节]# 步骤2: 三轮逆操作（使用正确密钥）original_data = reverse_blocks(blocks)# 转换为字符串flag = &#x27;&#x27;.join(chr(b) for b in original_data)print(&quot;完整的Flag:&quot;, flag)print(&quot;Flag长度:&quot;, len(flag))

完整的Flag: LILCTF{ez_arm_asm_meow_meow_meowm_oe_wemwom_oe}wFlag长度: 48
提交不上，猜了一下，最后试了试这个
LILCTF{ez_arm_asm_meow_meow_meow_meow_meow_meow}
提交成功
]]></content>
      <categories>
        <category>CTF</category>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>2025Lilctf(Crypto)</title>
    <url>/2025/08/15/2025Lilctf(Crypto)/</url>
    <content><![CDATA[2025Lilctf(Crypto)1.ez_math原题：
from sage.all import *from Crypto.Util.number import *flag = b&#x27;LILCTF&#123;test_flag&#125;&#x27;[7:-1]lambda1 = bytes_to_long(flag[:len(flag)//2])lambda2 = bytes_to_long(flag[len(flag)//2:])p = getPrime(512)def mul(vector, c):    return [vector[0]*c, vector[1]*c]v1 = [getPrime(128), getPrime(128)]v2 = [getPrime(128), getPrime(128)]A = matrix(GF(p), [v1, v2])B = matrix(GF(p), [mul(v1,lambda1), mul(v2,lambda2)])C = A.inverse() * Bprint(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;C = &#123;str(C).replace(&quot; &quot;, &quot;,&quot;).replace(&quot;\n&quot;, &quot;,&quot;).replace(&quot;[,&quot;, &quot;[&quot;)&#125;&#x27;)# p = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161# C = [7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645,7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801],[7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808,2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872]

根据矩阵求flag，跟moe那个有点像

from sage.all import *from Crypto.Util.number import long_to_bytes# 已知的p和C矩阵元素p = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161c11 = 7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645c12 = 7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801c21 = 7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808c22 = 2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872# 在GF(p)域上进行计算F = GF(p)c11 = F(c11)c12 = F(c12)c21 = F(c21)c22 = F(c22)# 计算特征方程的系数sum_c = c11 + c22product_c = c11 * c22 - c12 * c21# 计算判别式和平方根D = sum_c^2 - 4 * product_csqrt_D = D.sqrt()# 计算2的逆元inv2 = F(2)^-1# 求解特征值（λ₁和λ₂）lambda1 = int((sum_c + sqrt_D) * inv2)lambda2 = int((sum_c - sqrt_D) * inv2)# 转换为字节part1 = long_to_bytes(lambda1)part2 = long_to_bytes(lambda2)# 生成可能的flag（两种组合，因为λ₁和λ₂可能顺序互换）flag1 = b&#x27;LILCTF&#123;&#x27; + part1 + part2 + b&#x27;&#125;&#x27;flag2 = b&#x27;LILCTF&#123;&#x27; + part2 + part1 + b&#x27;&#125;&#x27;print(&quot;可能的flag1:&quot;, flag1)print(&quot;可能的flag2:&quot;, flag2)

可能的flag1: b’LILCTF{It_w4s_the_be5t_of_times_1t_wa5_the_w0rst_of_t1me5}’可能的flag2: b’LILCTF{1t_wa5_the_w0rst_of_t1me5It_w4s_the_be5t_of_times_}’
2.linear原题：
import osimport randomimport signalsignal.alarm(10)flag = os.getenv(&quot;LILCTF_FLAG&quot;, &quot;LILCTF&#123;default&#125;&quot;)nrows = 16ncols = 32A = [[random.randint(1, 1919810) for _ in range(ncols)] for _ in range(nrows)]x = [random.randint(1, 114514) for _ in range(ncols)]b = [sum(A[i][j] * x[j] for j in range(ncols)) for i in range(nrows)]print(A)print(b)xx = list(map(int, input(&quot;Enter your solution: &quot;).strip().split()))if xx != x:    print(&quot;Oh, your linear algebra needs to be practiced.&quot;)else:    print(&quot;Bravo! Here is your flag:&quot;)    print(flag)

比较简单的一个线性代数题，但是一般求出来的结果好像不准确，那么我们可以使用格基来求解，问题是要求是10s限制比较麻烦，因为我不会在sagemath连端口，所以就用vscode连接端口，使用sagemath出x，这样的话再复制到交互端口就好了
sagemath：
# 读取文本数据with open(&quot;E:/edge下载/CTF/2025LilCTF/Crypto/problem_data.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as file:    data = file.read()# 假设数据的格式是类似于JSON或Python列表的结构# 你可以手动解析文件内容，假设数据格式是这样的：# A = [[...], [...], ...] 和 b = [...], 你可以使用eval()或json.loads()来解析import ast# 假设 data 中有 A 和 b 的定义A = ast.literal_eval(data.split(&quot;A = &quot;)[1].split(&quot;b = &quot;)[0].strip())  # 提取并解析Ab = ast.literal_eval(data.split(&quot;b = &quot;)[1].strip())  # 提取并解析b# 之后使用这些数据进行计算n = 32  # 变量数m = 16  # 方程数W = 2**40  # 权重# 构造格基矩阵M = matrix(ZZ, n+1, n+m)for i in range(n):    M[i, i] = 1    for j in range(m):        M[i, n+j] = A[j][i] * W  # 注意：A是16行32列，所以A[j][i]是第j行第i列for j in range(m):    M[n, n+j] = b[j] * W# LLL约简（使用更快参数）M_lll = M.LLL(delta=0.99, eta=0.51)# 寻找解solution = Nonefor i in range(n+1):    # 检查后m个分量是否全为0    if all(M_lll[i, n+j] == 0 for j in range(m)):        x_sol = [abs(int(M_lll[i, j])) for j in range(n)]        # 将解限制在[1,114514]范围内        x_sol = [max(1, min(x, 114514)) for x in x_sol]        solution = x_sol        break# 如果LLL未找到解，使用伪逆作为备选if solution is None:    print(&quot;LLL未找到解，使用伪逆法...&quot;)    A_np = matrix(RDF, A)    b_np = vector(RDF, b)    x_float = A_np.pseudoinverse() * b_np    solution = [int(round(num)) for num in x_float]    solution = [max(1, min(x, 114514)) for x in solution]# 打印解（复制这个到client.py）print(&quot;\n&quot; + &quot;=&quot;*80)print(&quot;解x (复制这个到client.py):&quot;)print(&quot; &quot;.join(map(str, solution)))print(&quot;=&quot;*80)# 验证解（可选）b_calculated = [sum(A[i][j] * solution[j] for j in range(n)) for i in range(m)]if b_calculated == b:    print(&quot;验证成功: Ax = b&quot;)else:    print(&quot;验证失败: Ax ≠ b&quot;)    print(f&quot;原始b: &#123;b&#125;&quot;)    print(f&quot;计算b: &#123;b_calculated&#125;&quot;)

vscode
from pwn import *import timeimport osdef main():    # 连接到服务器    io = remote(&quot;challenge.xinshi.fun&quot;, 46755)        # 接收数据直到出现输入提示    data = b&quot;&quot;    start_time = time.time()    while b&quot;Enter your solution:&quot; not in data:        chunk = io.recv(1024)        if not chunk:            break        data += chunk                # 超时检查        if time.time() - start_time &gt; 15:            print(&quot;Timeout waiting for data!&quot;)            io.close()            return        # 提取并保存矩阵A和向量b    A_start = data.find(b&quot;[[&quot;)    A_end = data.find(b&quot;]]&quot;) + 2    b_start = data.find(b&quot;[&quot;, A_end)    b_end = data.find(b&quot;]&quot;, b_start) + 1        A_str = data[A_start:A_end].decode()    b_str = data[b_start:b_end].decode()        # 保存到文件    with open(&quot;problem_data.txt&quot;, &quot;w&quot;) as f:        f.write(f&quot;A = &#123;A_str&#125;\n&quot;)        f.write(f&quot;b = &#123;b_str&#125;\n&quot;)        print(&quot;问题数据已保存到 problem_data.txt&quot;)    print(&quot;请立即运行SageMath脚本计算解...&quot;)        # 等待用户粘贴解    print(&quot;\n计算完成后，将解x粘贴在这里（空格分隔的32个整数）&quot;)    print(&quot;注意：您有10秒时间完成计算！&quot;)    xx = input(&quot;&gt;&gt;&gt; &quot;).strip()        # 提交解    io.sendline(xx.encode())        # 获取结果    try:        result = io.recvall(timeout=5).decode()        print(&quot;\nServer response:&quot;)        print(result)    except:        print(&quot;\nTimeout waiting for server response&quot;)        io.close()if __name__ == &quot;__main__&quot;:    main()


flag：     LILCTF{60b2bfea-b0f7-4aed-9c94-b2301afd828f}
3.mid_math原题：
from sage.all import *from Crypto.Util.number import *from tqdm import tqdmfrom random import randintfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padflag = b&#x27;LILCTF&#123;test_flag&#125;&#x27;p = getPrime(64)P = GF(p)key = randint(2**62, p)def mul(vector, c):    return [vector[0]*c, vector[1]*c, vector[2]*c, vector[3]*c, vector[4]*c]v1 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v2 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v3 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v4 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v5 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]a, b, c, d, e = getPrime(64), getPrime(64), getPrime(64), getPrime(64),  0A = matrix(P, [v1, v2, v3, v4, v5])B = matrix(P, [mul(v1,a), mul(v2,b), mul(v3, c), mul(v4, d), mul(v5, e)])C = A.inverse() * BD = C**keykey = pad(long_to_bytes(key), 16)aes = AES.new(key,AES.MODE_ECB)msg = aes.encrypt(pad(flag, 64))print(f&quot;p = &#123;p&#125;&quot;)print(f&#x27;C = &#123;[i for i in C]&#125;&#x27;.replace(&#x27;(&#x27;, &#x27;[&#x27;).replace(&#x27;)&#x27;, &#x27;]&#x27;))print(f&#x27;D = &#123;[i for i in D]&#125;&#x27;.replace(&#x27;(&#x27;, &#x27;[&#x27;).replace(&#x27;)&#x27;, &#x27;]&#x27;))print(f&quot;msg = &#123;msg&#125;&quot;)#p = 14668080038311483271#C = [[11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212], [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914], [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670], [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413], [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707]]#D = [[1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044], [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372], [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427], [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551], [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395]]#msg = b&quot;\xcc]B:\xe8\xbc\x91\xe2\x93\xaa\x88\x17\xc4\xe5\x97\x87@\x0fd\xb5p\x81\x1e\x98,Z\xe1n`\xaf\xe0%:\xb7\x8aD\x03\xd2Wu5\xcd\xc4#m&#x27;\xa7\xa4\x80\x0b\xf7\xda8\x1b\x82k#\xc1gP\xbd/\xb5j&quot;



由于 D = C ** key，我们可以利用矩阵的特征值（eigenvalues）来恢复 key：

计算 C 和 D 的特征值：
C 的特征值 eigC 包含 0 和 4 个非零值。
D 的特征值 eigD 包含 0 和 eigC 的非零值的 key 次幂。


过滤掉 0，得到非零特征值：
L1 = [x for x in eigC if x != 0]
L2 = [x for x in eigD if x != 0]


通过离散对数恢复 key：
对 L1 和 L2 中的每一对 (x, y)，解 y = x ** key mod p。
由于 key 的范围是 [2^62, p]，解出的 k 必须满足这个范围。


验证 key：
检查是否 &#123;x ** key for x in L1&#125; == set(L2)。


解密 msg：
将 key 转为字节，填充到16字节，用AES-ECB解密 msg



ai拷打两下就梭出来了
from sage.all import *from Crypto.Util.number import *from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpad  # Import pad and unpad# Given datap = 14668080038311483271C_list = [    [11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212],    [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914],    [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670],    [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413],    [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707]]D_list = [    [1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044],    [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372],    [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427],    [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551],    [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395]]msg = b&quot;\xcc]B:\xe8\xbc\x91\xe2\x93\xaa\x88\x17\xc4\xe5\x97\x87@\x0fd\xb5p\x81\x1e\x98,Z\xe1n`\xaf\xe0%:\xb7\x8aD\x03\xd2Wu5\xcd\xc4#m&#x27;\xa7\xa4\x80\x0b\xf7\xda8\x1b\x82k#\xc1gP\xbd/\xb5j&quot;# Set up finite field and matricesF = GF(p)C = matrix(F, C_list)D = matrix(F, D_list)# Compute eigenvalueseigC = C.eigenvalues()eigD = D.eigenvalues()# Remove zero eigenvalues (one for each matrix)L1 = [x for x in eigC if x != F(0)]L2 = [x for x in eigD if x != F(0)]if len(L1) != 4 or len(L2) != 4:    print(&quot;Error: Expected 4 non-zero eigenvalues for both matrices.&quot;)    exit(1)# Find key by matching eigenvalues via discrete logarithmkey_candidate = Nonefor i in range(4):    x0 = L1[i]    for j in range(4):        y0 = L2[j]        try:            k0 = discrete_log(y0, x0)  # Solve y0 = x0^k0 mod p            candidates = []            # Check if k0 is in the valid range            if 2**62 &lt;= k0 &lt;= p:                candidates.append(k0)            # If k0 is too small, try k0 + order of x0            if k0 &lt; 2**62:                ord_val = x0.multiplicative_order()                k1 = k0 + ord_val                if 2**62 &lt;= k1 &lt;= p:                    candidates.append(k1)            # Verify candidate keys            for k_cand in candidates:                S = set(x**k_cand for x in L1)                if S == set(L2):                    key_candidate = k_cand                    print(f&quot;Found key: &#123;key_candidate&#125;&quot;)                    break            if key_candidate is not None:                break        except Exception as e:            continue    if key_candidate is not None:        breakif key_candidate is None:    print(&quot;Failed to find key.&quot;)    exit(1)# Decrypt the message using the recovered keykey_bytes = long_to_bytes(key_candidate)# Pad the key to 16 bytes for AESkey_padded = pad(key_bytes, 16)  # Now pad is importedaes = AES.new(key_padded, AES.MODE_ECB)flag_padded = aes.decrypt(msg)flag = unpad(flag_padded, 64)  # Original padding was 64 bytesprint(f&quot;Flag: &#123;flag.decode()&#125;&quot;)

 key: 5273966641785501202
flag：LILCTF{Are_y0u_5till_4wake_que5t1on_m4ker!}
4.Space Travel原题：
from Crypto.Cipher import AESfrom hashlib import md5from params import vecsfrom os import urandomkey = int(&quot;&quot;.join([vecs[int.from_bytes(urandom(2)) &amp; 0xfff] for _ in range(50)]), 2)print(&quot;🎁 :&quot;, [[nonce := int(urandom(50*2).hex(), 16), (bin(nonce &amp; key).count(&quot;1&quot;)) % 2] for _ in range(600)])print(&quot;🚩 :&quot;, AES.new(key=md5(str(key).encode()).digest(), nonce=b&quot;Tiffany&quot;, mode=AES.MODE_CTR).encrypt(open(&quot;flag.txt&quot;, &quot;rb&quot;).read()))

1.题面逻辑（来自 task.py）

先从 params.py 里的 vecs（4096 个 16 位二进制串）中，用 12 位随机索引各取 50 次，拼成 50×16 &#x3D; 800 位的二进制串，作为大整数 key。
接着生成 600 组样本：每组里有一个 800 位随机数 nonce，以及一个比特 parity，它等于 bin(nonce &amp; key) 中 1 的个数的奇偶（即 (nonce · key) mod 2 的内积）。
最后用 md5(str(key)) 作为 AES-CTR 的 key，nonce 固定为 &quot;Tiffany&quot;，加密出密文 🚩。

2.观测与困难

600 组样本提供了 600 条线性方程（GF(2) 上的内积），但未知量 key 有 800 个比特，直接解有 200 维自由度，不唯一。
关键是 key 的结构：它是 50 个 16 位小块的串联，每块都来自 vecs。而 vecs 的 4096 项，其差分集合（取任意一个基准 v0，看 vecs ⊕ v0 的行空间）维度是 12。这意味着 vecs 其实是一个 12 维线性子空间的仿射陪集（coset），大小正好 2^12&#x3D;4096。
于是每个 16 位小块都可表示为 v0 ⊕ (B * α)，其中 B 是 12×16 的基矩阵，α 是 12 比特坐标。
50 个小块 → 一共 50×12 &#x3D; 600 个未知比特。
与 600 条线性方程正好匹配！从而把原本 800 维未知，降成 600 维，得到可解的线性系统。



3.建模方式（对齐 bit 顺序很重要！）

把 vecs 的 16 位字符串视作 LSB-first（与 (nonce &amp; key) 的位对齐一致），否则会解出错误的 key。
设第 t 个小块的未知 12 比特为 α_t。对每条样本方程，有
parity_i = ⊕_t &lt;nonce_chunk_i_t, v0 ⊕ (B * α_t)&gt; ``         = ⊕_t &lt;nonce_chunk_i_t, v0&gt; ⊕ ⊕_t &lt;nonce_chunk_i_t, B * α_t&gt;
把常量项 ⊕_t &lt;nonce_chunk_i_t, v0&gt; 移到右边，剩余是关于所有 α_t 的 600×600 线性方程组，直接在 GF(2) 解之即可。
方程组秩通常是 599（有 1 维自由度），但这 不影响：任意解出的 (α_t) 都映射到 v0 ⊕ B*α_t，这个集合刚好就是 vecs 的那个仿射陪集，不会跑出集合之外。对那 1 维自由度，测试两种可能都很快，直接看哪一个能把密文正确解出可读明文（一般是标准 CTF flag）。

4.解出 key 并还原明文

用解出来的 50 个 16 位小块拼成 800 位 key（注意保持 LSB-first 与构造一致）。
取 md5(str(key))（Python 的 str(key) 即十进制串）当 AES-CTR key，nonce 用 b&quot;Tiffany&quot;，解密 🚩。
能得到清晰的 ASCII flag。

import re, ast, numpy as np, hashlibfrom Crypto.Cipher import AES# ---- 工具：GF(2) 线性代数 ----def gf2_rref(M, rhs=None):    M = M.copy().astype(np.uint8)    if rhs is not None:        rhs = rhs.copy().astype(np.uint8)        M = np.concatenate([M, rhs.reshape(-1,1)], axis=1)    m, n_aug = M.shape    n = n_aug if rhs is None else n_aug - 1    row = 0    pivots = []    for col in range(n):        pivot = None        for r in range(row, m):            if M[r,col]:                pivot = r; break        if pivot is None:            continue        if pivot != row:            M[[row,pivot]] = M[[pivot,row]]        for r in range(m):            if r != row and M[r,col]:                M[r,:] ^= M[row,:]        pivots.append(col)        row += 1        if row == m: break    return M, pivotsdef int_to_bits_lsb(n, width):    return np.array([(n&gt;&gt;i) &amp; 1 for i in range(width)], dtype=np.uint8)def bits_to_int(bits_lsb):    v = 0    for i,b in enumerate(bits_lsb):        if b: v |= (1&lt;&lt;i)    return v# ---- 读取 vecs（params.py）并转为 LSB-first ----with open(&#x27;params.py&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:    text = f.read()vecs_list = re.findall(r&quot;&#x27;([01]&#123;16&#125;)&#x27;&quot;, text)vecs = np.array([[int(b) for b in s[::-1]] for s in vecs_list], dtype=np.uint8)  # reverse to LSB-first# 取一个基向量 v0，并构造差分集合的行空间基 B（12×16）v0 = vecs[0]diffs = (vecs ^ v0) % 2def gf2_basis_rows(M):    A = M.copy().astype(np.uint8)    m,n = A.shape    row=0    pivcols=[]    for col in range(n):        pivot=None        for r in range(row,m):            if A[r,col]:                pivot=r; break        if pivot is None: continue        if pivot!=row: A[[row,pivot]] = A[[pivot,row]]        for r in range(m):            if r!=row and A[r,col]:                A[r,:] ^= A[row,:]        pivcols.append(col); row+=1        if row==m: break    # 抽取基行    basis_rows=[]    used=set()    for lead in pivcols:        for r in range(m):            if r in used: continue            if A[r,lead]==1 and all(A[r,c]==0 for c in range(lead)):                basis_rows.append(A[r].copy()); used.add(r); break    return np.array(basis_rows, dtype=np.uint8)B = gf2_basis_rows(diffs)   # 12 x 16# ---- 解析样本和密文（output.txt）----with open(&#x27;output.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:    data = f.read()gift_text = re.search(r&quot;🎁\s*:\s*(\[\[.*?\]\])&quot;, data, flags=re.S).group(1)cipher_text_literal = re.search(r&quot;🚩\s*:\s*(b?[&#x27;\&quot;][^&#x27;\&quot;]+[&#x27;\&quot;])|🚩\s*:\s*([0-9a-fA-Fx,\s\[\]]+)&quot;, data).group(1) \                      or re.search(r&quot;🚩\s*:\s*(b?[&#x27;\&quot;][^&#x27;\&quot;]+[&#x27;\&quot;])|🚩\s*:\s*([0-9a-fA-Fx,\s\[\]]+)&quot;, data).group(2)gift = ast.literal_eval(gift_text)cipher_literal = ast.literal_eval(cipher_text_literal)if isinstance(cipher_literal, bytes):    ct = cipher_literalelif isinstance(cipher_literal, list):    ct = bytes(cipher_literal)elif isinstance(cipher_literal, str):    ct = bytes.fromhex(cipher_literal)else:    raise RuntimeError(&quot;Unknown ciphertext!&quot;)# ---- 建立 600×600 线性方程组，未知为 50 个块的 12 比特坐标 ----m = len(gift)T = 50k = B.shape[0]  # 12WIDTH = 16*TA2 = np.zeros((m, T*k), dtype=np.uint8)b2 = np.zeros(m, dtype=np.uint8)for i,(nonce, par) in enumerate(gift):    bits = int_to_bits_lsb(nonce, WIDTH)    const = 0    for t in range(T):        chunk = bits[16*t:16*(t+1)]        const ^= (np.dot(chunk, v0) % 2)        # 对 α_t（12 维），其系数即 &lt;chunk, B_row&gt;，等价于 (B @ chunk)        A2[i, t*k:(t+1)*k] = (B @ chunk) % 2    b2[i] = (par ^ const) % 2# ---- 解方程（可能秩 599，尝试两个候选）----rref_A2, pivs = gf2_rref(A2, b2)nvar = A2.shape[1]x_alpha = np.zeros(nvar, dtype=np.uint8)row=0for col in range(nvar):    if row &lt; len(pivs) and pivs[row]==col:        x_alpha[col] = rref_A2[row,-1]; row+=1rrefA_only, pivs_only = gf2_rref(A2, None)null = np.zeros(nvar, dtype=np.uint8)if len(pivs_only) &lt; nvar:    fcol = [c for c in range(nvar) if c not in pivs_only][0]    null[fcol]=1    row=0    for col in range(nvar):        if row &lt; len(pivs_only) and pivs_only[row]==col:            s=0            for kcol in range(col+1, nvar):                if rrefA_only[row,kcol] and null[kcol]:                    s ^= 1            null[col]=s%2            row+=1def build_key_bits(alpha_concat):    blocks=[]    for t in range(T):        alpha_t = alpha_concat[t*k:(t+1)*k]        vec_t = (v0 ^ (alpha_t @ B) % 2) % 2  # LSB-first 16 bits        blocks.append(vec_t)    return np.concatenate(blocks)cands = [x_alpha, (x_alpha ^ null) % 2]for cand in cands:    key_bits = build_key_bits(cand)    key_int = bits_to_int(key_bits)    aes_key = hashlib.md5(str(key_int).encode()).digest()    cipher = AES.new(key=aes_key, nonce=b&quot;Tiffany&quot;, mode=AES.MODE_CTR)    pt = cipher.decrypt(ct)    try:        s = pt.decode(&#x27;utf-8&#x27;)        if &quot;&#123;&quot; in s and &quot;&#125;&quot; in s:            print(&quot;FLAG:&quot;, s)            break    except:        pass

flag： LILCTF{Un1qUe_s0luti0n_1N_sUbSp4C3!}
5.baaaaaag原题：
from Crypto.Util.number import *import randomfrom Crypto.Cipher import AESimport hashlibfrom Crypto.Util.Padding import padfrom secret import flagp = random.getrandbits(72)assert len(bin(p)[2:]) == 72a = [getPrime(90) for _ in range(72)]b = 0t = pfor i in a:    temp = t % 2    b += temp * i    t = t &gt;&gt; 1key = hashlib.sha256(str(p).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)flag = pad(flag,16)ciphertext = cipher.encrypt(flag)print(f&#x27;a = &#123;a&#125;&#x27;)print(f&#x27;b = &#123;b&#125;&#x27;)print(f&quot;ciphertext = &#123;ciphertext&#125;&quot;)&#x27;&#x27;&#x27;a = [965032030645819473226880279, 699680391768891665598556373, 1022177754214744901247677527, 680767714574395595448529297, 1051144590442830830160656147, 1168660688736302219798380151, 796387349856554292443995049, 740579849809188939723024937, 940772121362440582976978071, 787438752754751885229607747, 1057710371763143522769262019, 792170184324681833710987771, 912844392679297386754386581, 906787506373115208506221831, 1073356067972226734803331711, 1230248891920689478236428803, 713426848479513005774497331, 979527247256538239116435051, 979496765566798546828265437, 836939515442243300252499479, 1185281999050646451167583269, 673490198827213717568519179, 776378201435505605316348517, 809920773352200236442451667, 1032450692535471534282750757, 1116346000400545215913754039, 1147788846283552769049123803, 994439464049503065517009393, 825645323767262265006257537, 1076742721724413264636318241, 731782018659142904179016783, 656162889354758353371699131, 1045520414263498704019552571, 1213714972395170583781976983, 949950729999198576080781001, 1150032993579134750099465519, 975992662970919388672800773, 1129148699796142943831843099, 898871798141537568624106939, 997718314505250470787513281, 631543452089232890507925619, 831335899173370929279633943, 1186748765521175593031174791, 884252194903912680865071301, 1016020417916761281986717467, 896205582917201847609656147, 959440423632738884107086307, 993368100536690520995612807, 702602277993849887546504851, 1102807438605649402749034481, 629539427333081638691538089, 887663258680338594196147387, 1001965883259152684661493409, 1043811683483962480162133633, 938713759383186904819771339, 1023699641268310599371568653, 784025822858960757703945309, 986182634512707587971047731, 1064739425741411525721437119, 1209428051066908071290286953, 667510673843333963641751177, 642828919542760339851273551, 1086628537309368288204342599, 1084848944960506663668298859, 667827295200373631038775959, 752634137348312783761723507, 707994297795744761368888949, 747998982630688589828284363, 710184791175333909291593189, 651183930154725716807946709, 724836607223400074343868079, 1118993538091590299721647899]b = 34962396275078207988771864327ciphertext = b&#x27;Lo~G\xf46&gt;\xd609\x8e\x8e\xf5\xf83\xb5\xf0\x8f\x9f6&amp;\xea\x02\xfa\xb1_L\x85\x93\x93\xf7,`|\xc6\xbe\x05&amp;\x85\x8bC\xcd\xe6?TV4q&#x27;&#x27;&#x27;&#x27;

一个背包密码，解出p就能梭出来了。但是问题是怎么解出p：
据我已知的背包密码：b是背包容量，a是将要装进背包的物品。p可以由十进制转化为二进制，其中满足a[i],pi。pi只能为0或1,0代表对应的a[i]没有被装进背包，1代表对应的a[i]被装进背包。b会被a装满。
大概是这个意思，但是列数学表达式得出p的二进制需要线性代数知识。lll算法和bkz规约
这是deepseek给出的详细：
如何解出 p？为了解决这个问题，我们使用格基归约算法（如 LLL 或 BKZ）。格基归约可以将子集和问题转化为寻找格中的短向量问题。具体步骤如下：

格基构造：构造一个 (n+1) x (n+1) 的矩阵（n 是 a 的长度），其中：

前 n 行：对角线元素为 2，最后一列为 a[i]。
最后一行：前 n 个元素为 1，最后一个元素为 b。

这种构造确保了解向量 (2*m_0 - 1, 2*m_1 - 1, ..., 2*m_&#123;n-1&#125; - 1, 0) 在格中，其中 m_i 是 p 的二进制位。转换 v_i = 2*m_i - 1 将二进制位映射到 ±1，使得解向量更短且更易识别。

格基归约：使用 BKZ 或 LLL 算法对格基进行归约。BKZ 通常更强（能找到更短的向量），但计算成本更高。如果 BKZ 失败，可以回退到 LLL。

搜索解向量：在归约后的基中搜索满足条件的向量：

前 n 个坐标为 ±1。
最后一个坐标为 0（或接近 0，容错处理）。

如果找到，则从解向量恢复二进制位：m_i = (v_i + 1) / 2。

恢复 p：将二进制位组合成整数 p（注意：最低位对应 m_0）。


from sage.all import Matrix, ZZ# --------- 已知参数 ----------a = [965032030645819473226880279, 699680391768891665598556373, 1022177754214744901247677527, 680767714574395595448529297,     1051144590442830830160656147, 1168660688736302219798380151, 796387349856554292443995049, 740579849809188939723024937,     940772121362440582976978071, 787438752754751885229607747, 1057710371763143522769262019, 792170184324681833710987771,     912844392679297386754386581, 906787506373115208506221831, 1073356067972226734803331711, 1230248891920689478236428803,     713426848479513005774497331, 979527247256538239116435051, 979496765566798546828265437, 836939515442243300252499479,     1185281999050646451167583269, 673490198827213717568519179, 776378201435505605316348517, 809920773352200236442451667,     1032450692535471534282750757, 1116346000400545215913754039, 1147788846283552769049123803, 994439464049503065517009393,     825645323767262265006257537, 1076742721724413264636318241, 731782018659142904179016783, 656162889354758353371699131,     1045520414263498704019552571, 1213714972395170583781976983, 949950729999198576080781001, 1150032993579134750099465519,     975992662970919388672800773, 1129148699796142943831843099, 898871798141537568624106939, 997718314505250470787513281,     631543452089232890507925619, 831335899173370929279633943, 1186748765521175593031174791, 884252194903912680865071301,     1016020417916761281986717467, 896205582917201847609656147, 959440423632738884107086307, 993368100536690520995612807,     702602277993849887546504851, 1102807438605649402749034481, 629539427333081638691538089, 887663258680338594196147387,     1001965883259152684661493409, 1043811683483962480162133633, 938713759383186904819771339, 1023699641268310599371568653,     784025822858960757703945309, 986182634512707587971047731, 1064739425741411525721437119, 1209428051066908071290286953,     667510673843333963641751177, 642828919542760339851273551, 1086628537309368288204342599, 1084848944960506663668298859,     667827295200373631038775959, 752634137348312783761723507, 707994297795744761368888949, 747998982630688589828284363,     710184791175333909291593189, 651183930154725716807946709, 724836607223400074343868079, 1118993538091590299721647899]b = 34962396275078207988771864327ciphertext = b&#x27;Lo~G\xf46&gt;\xd609\x8e\x8e\xf5\xf83\xb5\xf0\x8f\x9f6&amp;\xea\x02\xfa\xb1_L\x85\x93\x93\xf7,`|\xc6\xbe\x05&amp;\x85\x8bC\xcd\xe6?TV4q&#x27;n = len(a)   # 72# --------- 构造格基 ----------Ge = Matrix(ZZ, n+1, n+1)for i in range(n):    Ge[i, i] = 2    Ge[i, -1] = a[i]for i in range(n):    Ge[-1, i] = 1Ge[-1, -1] = b# --------- BKZ / LLL 归约 ----------print(&quot;Running BKZ...&quot;)try:    B = Ge.BKZ(block_size=28)except Exception as e:    print(&quot;BKZ 失败，退回 LLL：&quot;, e)    B = Ge.LLL()print(&quot;Reduction done. Searching for solution vector...&quot;)found = Falsecandidate = None# 搜索解向量for row_idx in range(B.nrows()):    v = [int(B[row_idx, j]) for j in range(n+1)]    last = v[-1]    front = v[:-1]    if last == 0 and all(x in (-1, 1) for x in front):        candidate = front        found = True        print(f&quot;Found exact candidate in basis row &#123;row_idx&#125;&quot;)        breakif not found:    for row_idx in range(B.nrows()):        v = [int(B[row_idx, j]) for j in range(n+1)]        front = v[:-1]        last = v[-1]        if abs(last) &lt;= 1 and all(abs(x) in (0,1,2) for x in front):            possibly = []            ok = True            for x in front:                if x &gt;= 1:                    possibly.append(1)                elif x &lt;= -1:                    possibly.append(-1)                else:                    ok = False                    break            if ok:                candidate = possibly                found = True                print(f&quot;Found tolerant candidate in basis row &#123;row_idx&#125; (last=&#123;last&#125;)&quot;)                breakif not found:    print(&quot;没有在基中直接找到满足 (±1,...,0) 形式的向量。&quot;)    print(&quot;你可以：\n - 提高 BKZ 的 block_size（更强但更慢），\n - 或尝试搜索基向量的短线性组合 / 使用 fpylll 的 shortest_vector.&quot;)    exit(1)# 恢复 pm_bits = [(x + 1) // 2 for x in candidate]p_recovered = 0for i, bit in enumerate(m_bits):    p_recovered |= (bit &lt;&lt; i)print(&quot;Recovered p (decimal):&quot;, p_recovered)print(&quot;Recovered p (bin length):&quot;, len(bin(p_recovered)) - 2)

Running BKZ…Reduction done. Searching for solution vector…Found exact candidate in basis row 0Recovered p (decimal): 4208626653103825685156Recovered p (bin length): 72
from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadimport hashlibciphertext=b&#x27;Lo~G\xf46&gt;\xd609\x8e\x8e\xf5\xf83\xb5\xf0\x8f\x9f6&amp;\xea\x02\xfa\xb1_L\x85\x93\x93\xf7,`|\xc6\xbe\x05&amp;\x85\x8bC\xcd\xe6?TV4q&#x27;p_recovered=4208626653103825685156key = hashlib.sha256(str(p_recovered).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)try:    plaintext = unpad(cipher.decrypt(ciphertext), 16)except ValueError:    plaintext = cipher.decrypt(ciphertext)    print(&quot;Warning: unpad failed; raw decrypted bytes shown.&quot;)print(&quot;Decrypted plaintext (bytes):&quot;, plaintext)try:    print(&quot;Decrypted plaintext (utf-8):&quot;, plaintext.decode())except Exception:    pass

Decrypted plaintext (bytes): b’LILCTF{M4ybe_7he_brut3_f0rce_1s_be5t}’Decrypted plaintext (utf-8): LILCTF{M4ybe_7he_brut3_f0rce_1s_be5t}
]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>2025moectf(Crypto)</title>
    <url>/2025/08/09/2025moectf(Crypto)/</url>
    <content><![CDATA[2025moectf(Crypto)1.moectf(Crypto)#!/usr/bin/env python3from Crypto.PublicKey import ElGamalfrom Crypto.Random import get_random_bytes, randomfrom Crypto.Util.number import *from random import *from secret import flagdef generate_elgamal_keypair(bits=512):p = getPrime(bits)for _ in range(1000):g = getRandomRange(2, 5)if pow(g, (p - 1) // 2, p) != 1:breakx = randrange(2, p - 1)注:此处的secret模块可以理解为存储了明文flag的python文件，属于未知信息，而非公开的可用模块。你需要尝试从密文去恢复原始的flag，而不是去下载secret模块。secrets则是一个用于生成管理密码的安全随机数的python标准库。bytes_to_long函数用于将flag编码为整数。Hint：什么是 Elgamal还是附个链接吧Elgamaly = pow(g, x, p)return p, g, y, xkey=generate_elgamal_keypair(bits=512)p, g, y ,x= keyprint(&quot;=== 公钥 (p, g, y) ===&quot;)print(&quot;p =&quot;, p)print(&quot;g =&quot;, g)print(&quot;y =&quot;, y)print()k = randrange(1, p - 2)m = bytes_to_long(flag)c1 = pow(g, k, p)c2 = (m * pow(y, k, p)) % pprint(&quot;=== 密文 (c1, c2) ===&quot;)print(&quot;c1 =&quot;, c1)print(&quot;c2 =&quot;, c2)#不小心把x输出了()print(&quot;x =&quot;, x)&quot;&quot;&quot;=== 公钥 (p, g, y) ===p =11540963715962144951763578255357417528966715904849014985547597657698304891044841099894993117258279094910424033273299863589407477091830213468539451196239863g = 2y =8313424783366011287014623582773521595333285291380540689467073212212931648415580065207081449784135835711205324186662482526357834042013400765421925274271853=== 密文 (c1, c2) ===c1 =6652053553055645358275362259554856525976931841318251152940464543175108560132949610916012490837970851191204144757409335011811874896056430105292534244732863c2 =2314913568081526428247981719100952331444938852399031826635475971947484663418362533363591441216570597417789120470703548843342170567039399830377459228297983x =8010957078086554284020959664124784479610913596560035011951143269559761229114027738791440961864150225798049120582540951874956255115884539333966429021004214&quot;&quot;&quot;注:此处的secret模块可以理解为存储了明文flag的python文件，属于未知信息，而非公开的可用模块。你需要尝试从密文去恢复原始的flag，而不是去下载secret模块。secrets则是一个用于生成管理密码的安全随机数的python标准库。bytes_to_long函数用于将flag编码为整数。

ai可以一把梭，明个再来写解题过程：

from Crypto.Util.number import long_to_bytes# 给定的公钥和私钥p = 11540963715962144951763578255357417528966715904849014985547597657698304891044841099894993117258279094910424033273299863589407477091830213468539451196239863g = 2y = 8313424783366011287014623582773521595333285291380540689467073212212931648415580065207081449784135835711205324186662482526357834042013400765421925274271853c1 = 6652053553055645358275362259554856525976931841318251152940464543175108560132949610916012490837970851191204144757409335011811874896056430105292534244732863c2 = 2314913568081526428247981719100952331444938852399031826635475971947484663418362533363591441216570597417789120470703548843342170567039399830377459228297983x = 8010957078086554284020959664124784479610913596560035011951143269559761229114027738791440961864150225798049120582540951874956255115884539333966429021004214# 计算共享密钥 s = c1^x mod ps = pow(c1, x, p)# 计算 s 的模逆元s_inv = pow(s, -1, p)# 解密消息 m = c2 * s_inv mod pm = (c2 * s_inv) % p# 将整数转换为字节串flag = long_to_bytes(m)print(&quot;解密后的 flag:&quot;, flag.decode())

flag:   moectf{th1s_1s_y0ur_f1rst_ElG@m@l}
2.ez_DES原题：
from Crypto.Cipher import DESimport secretsimport stringflag = &#x27;moectf&#123;???&#125;&#x27;characters = string.ascii_letters + string.digits + string.punctuationkey = &#x27;ezdes&#x27;+&#x27;&#x27;.join(secrets.choice(characters) for _ in range(3))assert key[:5] == &#x27;ezdes&#x27;key = key.encode(&#x27;utf-8&#x27;)l = 8def encrypt(text, key):    cipher = DES.new(key, DES.MODE_ECB)    padded_text = text + (l - len(text) % l) * chr(len(text))    data = cipher.encrypt(padded_text.encode(&#x27;utf-8&#x27;))    return datac = encrypt(flag, key)print(&#x27;c =&#x27;, c)# c = b&#x27;\xe6\x8b0\xc8m\t?\x1d\xf6\x99sA&gt;\xce \rN\x83z\xa0\xdc&#123;\xbc\xb8X\xb2\xe2q\xa4&quot;\xfc\x07&#x27;

爆破秘钥就好，ai能一把梭：
from Crypto.Cipher import DESimport stringfrom itertools import product# 给定的密文c = b&#x27;\xe6\x8b0\xc8m\t?\x1d\xf6\x99sA&gt;\xce \rN\x83z\xa0\xdc&#123;\xbc\xb8X\xb2\xe2q\xa4&quot;\xfc\x07&#x27;# 可能的字符集characters = string.ascii_letters + string.digits + string.punctuationdef decrypt(ciphertext, key):    &quot;&quot;&quot;尝试使用给定的密钥解密，使用题目特定的填充方案&quot;&quot;&quot;    try:        cipher = DES.new(key, DES.MODE_ECB)        data = cipher.decrypt(ciphertext)                # 获取原始消息长度（填充字符的值）        msg_len = data[-1]                # 计算填充长度        pad_len = 8 - (msg_len % 8)        if pad_len == 0:  # 如果长度是8的倍数            pad_len = 8                # 验证填充是否正确        if all(byte == msg_len for byte in data[-pad_len:]):            # 移除填充并返回原始消息            return data[:-pad_len]    except:        pass    return Nonedef main():    &quot;&quot;&quot;主函数，爆破密钥并解密&quot;&quot;&quot;    # 生成所有可能的3字符组合    total = len(characters) ** 3    count = 0        print(f&quot;开始爆破 &#123;total&#125; 种可能的密钥组合...&quot;)        # 使用笛卡尔积生成所有可能的3字符后缀    for suffix in product(characters, repeat=3):        count += 1        if count % 100000 == 0:            print(f&quot;进度: &#123;count&#125;/&#123;total&#125; (&#123;count/total*100:.1f&#125;%)&quot;)                # 构建完整密钥        key_str = &#x27;ezdes&#x27; + &#x27;&#x27;.join(suffix)        key = key_str.encode(&#x27;utf-8&#x27;)                # 尝试解密        result = decrypt(c, key)                # 如果解密成功并且结果包含 moectf 标志        if result and b&#x27;moectf&#123;&#x27; in result:            print(f&quot;\n找到有效密钥: &#123;key_str&#125;&quot;)            print(f&quot;解密结果: &#123;result.decode()&#125;&quot;)            return        print(&quot;爆破完成，未找到有效密钥。尝试检查填充逻辑或密钥空间。&quot;)if __name__ == &quot;__main__&quot;:    main()

找到有效密钥: ezdes8br解密结果: moectf{_Ju5t envmEra+e.!}
3.baby_next原题：
from Crypto.Util.number import *from gmpy2 import next_primefrom functools import reducefrom secret import flagassert len(flag) == 38assert flag[:7] == b&#x27;moectf&#123;&#x27;assert flag[-1:] == b&#x27;&#125;&#x27;def main():    p = getPrime(512)    q = int(reduce(lambda res, _: next_prime(res), range(114514), p))    n = p * q    e = 65537    m = bytes_to_long(flag)    c = pow(m, e, n)    print(f&#x27;&#123;n = &#125;&#x27;)    print(f&#x27;&#123;c = &#125;&#x27;)if __name__ == &#x27;__main__&#x27;:    main()&quot;&quot;&quot;n = 96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397c = 17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967&quot;&quot;&quot;

next_prime的应用，也是爆破一下，因为数据量不大，给点描述就能一把梭了
from gmpy2 import isqrt, next_prime, mpzfrom Crypto.Util.number import long_to_bytesn = mpz(96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397)c = mpz(17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967)e = 65537def factor_n(n):    &quot;&quot;&quot;高效分解接近的素数因子&quot;&quot;&quot;    a = isqrt(n)  # 精确整数平方根        # 从平方根开始向前搜索素数作为候选p    p = next_prime(a - 10**7)  # 从稍低于平方根的位置开始        # 尝试p和p后面的114514个素数作为q    for _ in range(10000000):  # 安全范围内搜索        q = n // p                # 检查是否找到有效因子        if p * q == n:            return p, q                # 移动到下一个候选p        p = next_prime(p)        return None, Nonep, q = factor_n(n)if p and q:    phi = (p-1)*(q-1)    d = pow(e, -1, phi)    m = pow(c, d, n)    flag = long_to_bytes(int(m))    print(&quot;Flag:&quot;, flag.decode())else:    print(&quot;未找到因子&quot;)



flag：  moectf{vv0W_p_m1nu5_q_i5_r34l1y_sm4lI}
4.ez_square原题：
from Crypto.Util.number import *from secret import flagassert len(flag) == 35assert flag[:7] == b&#x27;moectf&#123;&#x27;assert flag[-1:] == b&#x27;&#125;&#x27;def main():    p = getPrime(512)    q = getPrime(512)    n = p * q    e = 65537    m = bytes_to_long(flag)    c = pow(m, e, n)    hint = pow(p + q, 2, n)    print(f&#x27;&#123;n = &#125;&#x27;)    print(f&#x27;&#123;c = &#125;&#x27;)    print(f&#x27;&#123;hint = &#125;&#x27;)if __name__ == &#x27;__main__&#x27;:    main()&quot;&quot;&quot;n = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149c = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190hint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304&quot;&quot;&quot;

rsa加密公式的考察，不难，也能一把梭
import mathfrom Crypto.Util.number import long_to_bytes# 已知参数n = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149c = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190hint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304e = 65537# 关键推导：(p+q)² = (p-q)² + 4pq，而hint = (p+q)² mod n = (p-q)² mod n# 计算s = (p+q)² = 4n + hint（因为hint = (p-q)²且小于n）s = 4 * n + hint# 求s的平方根得到p+qs_sqrt = math.isqrt(s)assert s_sqrt * s_sqrt == s, &quot;s不是完全平方数，推导错误&quot;# 求hint的平方根得到p-qd_sqrt = math.isqrt(hint)assert d_sqrt * d_sqrt == hint, &quot;hint不是完全平方数，推导错误&quot;# 计算p和qp = (s_sqrt + d_sqrt) // 2q = (s_sqrt - d_sqrt) // 2# 验证p*q是否等于nassert p * q == n, &quot;分解n失败&quot;# 计算欧拉函数φ(n)phi = (p - 1) * (q - 1)# 计算私钥d（e的逆元）d = pow(e, -1, phi)# 解密得到明文mm = pow(c, d, n)# 转换为flagflag = long_to_bytes(m)print(&quot;解密得到的flag:&quot;, flag.decode())



flag：   moectf{Ma7hm4t1c5_is_@_k1nd_0f_a2t}
5.ezlegendre原题：
from Crypto.Util.number import getPrime, bytes_to_longfrom secret import flagp = 258669765135238783146000574794031096183a = 144901483389896508632771215712413815934def encrypt_flag(flag):    ciphertext = []    plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag])    for b in plaintext:        e = getPrime(16)        d = randint(1,10)        n = pow(a+int(b)*d, e, p)        ciphertext.append(n)    return ciphertextprint(encrypt_flag(flag))

数据都给你了，直接读数据得出未知数就好了
from Crypto.Util.number import isPrimefrom tqdm import tqdm# 已知参数p = 258669765135238783146000574794031096183a = 144901483389896508632771215712413815934# 假设我们有部分密文ciphertext = [102230607782303286066661803375943337852, 196795077203291879584123548614536291210, 41820965969318717978206410470942308653, 207485265608553973031638961376379316991, 126241934830164184030184483965965358511, 20250852993510047910828861636740192486, 103669039044817273633962139070912140023, 97337342479349334554052986501856387313, 159127719377115088432849153087501377529, 45764236700940832554086668329121194445, 35275004033464216369574866255836768148, 52905563179465420745275423120979831405, 17032180473319795641143474346227445013, 29477780450507011415073117531375947096, 55487351149573346854028771906741727601, 121576510894250531063152466107000055279, 69959515052241122548546701060784004682, 173839335744520746760315021378911211216, 28266103662329817802592951699263023295, 194965730205655016437216590690038884309, 208284966254343254016582889051763066574, 137680272193449000169293006333866420934, 250634504150859449051246497912830488025, 124228075953362483108097926850143387433, 232956176229023369857830577971626577196, 149441784891021006224395235471825205661, 118758326165875568431376314508740278934, 222296215466271835013184903421917936512, 49132466023594939909761224481560782731, 406286678537520849308828749751513339, 215122152883292859254246948661946520324, 81283590250399459209567683991648438199, 150395133067480380674905743031927410663, 5710878479977467762548400320726575491, 83627753774286426170934105100463456109, 164968224377869331545649899270867630850, 241057183685774160581265732812497247167, 109136287048010096863680430193408099828, 116313129605409961931811582899075031153, 202739016625709380026000805340243458300, 25408225921774957745573142542576755590, 151336258796933656160956289529558246702, 2947189044370494063643525166023973095, 228678413963736672394976193093568181979, 40627063032321835707220414670018641024, 55446789315226949622969082042881319148, 32219108726651509070669836923591948459, 134454924722414419191920784435633637634, 97952023967728640730045857104376826039, 20659076942504417479953787092276592682, 93281761173713729777326842152860901050, 133634773495582264000160065317239987936, 79976720152435218818731114555425458470, 234654694673289327542859971371886984118, 51332273108989067644245919615090753756, 134120280423303717489979349737802826605, 182001158305920226320085758522717203725, 98408798757865562737462169470346158516, 78200435603900368619334272308272773797, 232796357836930341547987600782979821555, 589106968861493082018132081244848952, 24186003230092331554886767628744415123, 236070626491251466741246103662922841423, 238699080882667864827094121849090696547, 141659873734297659078160283051728812410, 228977113517120063860252637394240795552, 236613527842969921794004708284265628300, 145522034982744654991661857596541755396, 249608374387044047328725156440984678776, 325110572051913836681821746093704556, 171492052199838424502681030556098576483, 156498865212994371079795360268866413702, 196747701509389071931992996873572785043, 70811811603137896158765356680364490781, 83672551582385607422240464086955462541, 117961603623637997457153763936550310698, 224448821395214505399297116719025174412, 4598815373009554321735225938200807251, 194892269604260726530091473301914449005, 127484628022155760909820605666827662175, 208706240846212140439291547368645656474, 14102286481104997303651684152195298336, 6129503335471304345451795609683770657, 103799668048593149396277157385628834185, 185813375481410513002496683918106238351, 233491689316882978147517340230794025796, 46274083097168831187719988888816378961, 119487551553664772614629936285345836934, 84340029922118279362389419277915602509, 88253743193124528032223101368846247085, 227895357640018330099501504941388167432, 92189947144174433744195727086236905626, 83114957902192791332190922428847199876, 173535754090441937731619031520699325122, 192309407933789484835602071782330798398, 255421921600128994923738650157598053776, 155535082468314012733563336837641958625, 49064798421022327310707074253263463055, 161216416471071644769301963857685054031, 252480348817188872515008985698620059851, 75854882798183185741756645038434215611, 256065006192683011190132982128640682537, 87507510173514424105732562474643251223, 163309795132131534875147566536485288212, 253583084320404985699510129361746869059, 253300112521651972637580307326576568313, 239027717080729650738678032571840680727, 117444657686971615526398894470673026034, 215470942802874046857958621181684551426, 58767098748728136687851735836323448020, 249357164697409977883764098879705065535, 174705348385893117518084017669958647345, 211108767177375215605155301209259781232, 57829566748907062397366819001461941421, 88265742700024922112974862134385921564, 80952107622167923709226013231566882261, 236078582132483864916117213281193714198, 193448482646563141692726575550417225891, 245972799166806058223048506073553726233, 10132977708896091601871557249244373666, 201785418152654519825849206312616081028, 15169816744048531212384271865884567710, 122545328290385950043826822277924297182, 202918646192255177261567701479991753600, 32696887488223731055835744711207261936, 88319352182963224921157305627381030375, 92381505322264045777004475690398861771, 189745654013352563126968415157143821842, 152254915005998949299817641843658795579, 198032433618991362619448347415342295581, 84073892809321676935569114878067118319, 82243805869584256211699602267760745768, 61994229948266781537191603999495995852, 253668765227759797787675352833142466255, 38865376724677211964966907748953557125, 134615436811268347303232550777225944929, 176932422465426107783498083830285780588, 207573742393618910694054452362826628208, 200033130835394442710748301293534928706, 127536063935293533700918451145963158658, 219125698281820710910675956971948816959, 179795893258398750139395156587561075767, 69649628109726874051635160004398498964, 241433717681314766463039563422535023524, 202664264135718511331695232476272832350, 205151096657425932591242432052912914182, 210305712465948130683966275157181140301, 196555690055906934925300527324955477733, 66817932643964538216259564711698986077, 95270796440975607179107356182889534333, 123226880424532374188134357659879826495, 53506495440223773538415807620524749240, 19253217887083870834249774316467647628, 165699356396365023442008488156823647206, 107809175498119862854792975070673056027, 250453989887421415931162217952559757164, 171492052199838424502681030556098576483, 133778166882550119563444625306816232463, 149009301604122447269581792013291889175, 9982418254629616281350713836647603294, 203486292122499140756846060502464655972, 157686696123400087437836943220926921848, 88338919773540412238116717043122711811, 113265824169274322024623493892867211478, 5549372099744960679418616304893848801, 12431828907518852062050349123660880165, 183957934738536914983862053251433028750, 42027289270308356303682029801998790750, 117406080036483925915502666019795783905, 154312255292300186042636734144948304054, 143706917273862261295046346995206133170, 50088136095338601440516112338120787526, 250634504150859449051246497912830488025, 8073010289877796888705519374892639903, 40049582814576788803483039836229025416, 227012342545923833983403067401561291645, 201776603581414625783054400184026088994, 55474945478884522762318445841998187357, 221515530211550293408010846844218019597, 172650752042211610909190315288155597255, 67046194931321172530462444254204111483, 207435868835185636819659137800256834557, 188063222224545200294767050268070647452, 58099349021260301211275261896736590564, 23598877596106927870697531042828774738, 58546308516383335224739442370238545000, 58125311541947998710088435169901475101, 238219925698115060748249043752036454438, 203910234934340893915761800653823457631, 190854889967769152565565000250829375099, 37573623890629846209257307181880876288, 226220240200270623843038279593586687278, 144246075981535671790438155977352345487, 14665770553338784222331493932533448756, 37992062606775322664977502677838074649, 47370175759976523832233910009306151684, 97047813247943880266351445874642842468, 237607444658797800072728280983357541134, 174853113478993738890584814806707459112, 17104608155861584438824639050715857607, 83639027011494777283064583268678718843, 237826165608708003941944469905843354705, 231707683915242052796886276983724691027, 146089830852925550139294146760718642221, 25604562707667550478623425477029052785, 108577663147976992047614498924706939204, 69040319834829375335287614995435269276, 169933229202934375632745753379104389929, 72693008284867494808267387710985847974, 158548279589965576940349068403862889270, 49458101234256610254825879149914255140, 24389558269688411084589654047215902968, 210567980379246548727819953025607019254, 110423375132252997825868399832298953831, 109589895677661968369424757992411668628, 66177577069199763925999718357846633613, 83602293803708828242273186265396676466, 172226271050176278536911356541786290551, 85799805809703976643034084477579915867, 179399990302447560847151603157937241688, 81687654752229170984692833277072534294, 160766441640281044008645821822296569868, 100306680611749750243920501921769642984, 42195187332833922597871030332905266026, 238918420772178508359295233180536910768, 221685929158944699801776621298532178665, 209349638787804999657456057184702655805, 183953393268431043006359511952782903516, 137364333131365794683132159746962959967, 15637689373906596015395350692459218048, 145956368418289159411911667337899986262, 197987711355277581048877821432652325207, 125421308989313724733467092345532539875, 90525081516582408488547894471421476595, 107405840115256692042814887586009104950, 71587500700172519801649824611045199280, 10155721246869986043302768283257682883, 100522792569358427133597834727509523742, 244473925018526409824670892423775482110, 50746138425761666610345252577572889037, 142188269919422432629363225167297071042, 8235113926890598897465093754260801947, 174540885017405784646782293055852044631, 171949847901434672429841435895697323702, 34391199559497599434575002007581170988, 7337868660819385932166025474594964373, 89608475952042154068811282935241824949, 162561097613906905390170334328135062933, 252566077272083954707900007055640560669, 4284637988579219107997224848114896904, 220026371387782427901244689037957398829, 86019060485320999498155965142619258089, 19304861731281576405798605142335886482, 123188238667151068575810494833929221938, 125089740978532716086813732154638565196, 252061524500088702951562270741214799294, 89528875472312768404823823905699760649, 63307407053590054220492282094909190524, 24389558269688411084589654047215902968, 43835777110183833958990705735152973942, 196543204310466258426232803779025620993, 225032412767857179129234169288824097261, 50292890880286260984317361296226049436, 64928956886509273090981701066528078331, 25408225921774957745573142542576755590, 235921667882292842303120860570747218086, 217132603855089441017750752624514343437, 11106129204256119599329380588789107048, 147501327490657927610543345089238991876, 158091159632919983870444592039392730373, 254215886971254771885657857148535673338, 129869106474614345624950211566868568809, 10425702332274469498479699675668087022, 136595953187315682777976356839442311764, 1607792140397737044118662059498732982, 23710000155612873207506044342091514799, 118571340370877720354330132780832828911, 194624784476702188629452374731837038856, 51332273108989067644245919615090753756, 240921043405288511960365826273938845156, 158670188709175825212687487436006138030, 133641825913283256858340618209700716053, 43054466484232130048301271684438593412, 20361972967806283315536154125012604660, 135700832615866572032111395529532615300, 160609169788639387827865051539103507016, 100576279475451993660766480883708996211, 215424685541583305069271024253690375127, 60018956375784961551937423504137141702, 107997941230633604720421526632224279451, 219482010609171816035007605036664317041, 22173526221024380740269311947729076493, 249746554302052221287371350978970766087, 93207359085331319264650563354951254906, 221421697282310997113867048083058096452, 61834092635779365101011109381392037516, 162215218701897689647766394615098617152, 141856131587452385513407955541400099703, 177910903795887762773545874929605680469, 228832704523723308335513552177377803295, 229427981969125094398744034150988525118, 217938760689082034514008764751385239765, 3238055163645731541423094980789895030, 42308449860804765793467328093112118974, 254764518926620089428032312378507653680, 215733901156118606036318409454786603209, 59640829345183339336712595595022506261, 33515071724475649656070325837411550208, 51175659069843551646353202764296812462, 211462959696081863041546889096760952490, 230559603938699838189391087728971115767, 85878911733601049548471257838175175563, 214134904074265214033878852207103328297, 160702405980652445507529591230654474171, 223755040649990285320102091954198427148, 166476753890268002826149533120107157745, 26283916639129998224675164834425763384, 232971495542024495583092055361321729894, 79741799146769724681649849525636816379, 228506526471280046809909301748098760369, 167502422063741368765891061653686283332, 26984184590668253713951516794937308166, 105952393031190074432183821281493254, 113823192955281698937767041115166174652, 93264047694114869263275726820602569731, 55481974783112950660682138071588408040, 108961894273530837550182447112767144669, 47975793549419083945738147934068241928, 204024371586357035343484206754422857590, 251859351272989525849999231358507018068, 75939709807860493804628805619699991501, 129031774446142139804436921156668129187, 110764318451937254261883856778359218969, 246404864722813298477426808193494673610, 153818236564405157581869620439634140065, 246125932167584353084676586883038397451]# 预计算16位素数primes_16bit = [i for i in range(2, 2**16) if isPrime(i)]def decrypt_bit(n):    for b in [0, 1]:  # 尝试0和1        for d in range(1, 11):  # 尝试d从1到10            for e in primes_16bit:  # 尝试所有16位素数                if pow(a + b*d, e, p) == n:                    return str(b)    return &#x27;?&#x27;  # 未找到# 解密所有位plain_bits = []for n in tqdm(ciphertext):    plain_bits.append(decrypt_bit(n))# 将二进制字符串转换回字节plaintext = &#x27;&#x27;.join(plain_bits)flag = bytes(int(plaintext[i:i+8], 2) for i in range(0, len(plaintext), 8))print(flag)

flag：b‘moectf{Y0u_h@v3_ju5t_s01v3d_7h1s_pr0b13m!}’
总结：为数不多能ak的密码（如果后续不上题的话），刚学两三个月的密码手适合做，可以增强一下信心以及练一下基本功
最后，测试一下图片：

哦，后续会继续上题
]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试2</title>
    <url>/2025/09/26/Java%E9%9D%A2%E8%AF%952/</url>
    <content><![CDATA[Java面试2hr面：问个人信息，没问技术问题
后端面：自我介绍1，aop是什么，通常怎么使用
2，ioc，这次比上次强，上次直接说不会，这次说了控制反转，依赖注入，然后说了不会
3，bean的生命周期，只说了容器化初始化销毁，然后说不会
4，sychorynatheen（忘了咋拼了），那个什么锁，问了是不是可重入锁，使用场景。这个也是不会
5，问了项目中在哪使用数据库，怎么使用数据库的
6，怎么关联不同表，怎么保证关联表的数据一致性，表的索引有哪些，你在项目中主要用到了哪些索引，你在项目中写的最复杂的sql语句
7，问了redis在项目中使用
8，问了rsa
，，，项目和场景还问其他的了，但我忘了
前端：前端问了git和Linux，因为我说不会写前端代码，只看得懂写路由和排查bug1，你怎么使用git的
2，git你项目写好了一部分怎么关联两个仓库，我说：先关联一个然后解开权限再关联另一个，他问我具体操作我说我没实践过
3，你项目写好一部分，不想上传git也不提交到本地，你怎么暂存项目，我大概意思：保存一下然后就好了，下次继续写。但，额，面试官好像有点懵逼，然后追问，我说拿idea举例，cs保存一下下次继续写就好了
4，Linux你怎么使用
5，怎么编辑文件
其他的忘了面试官都挺友善，不赖
]]></content>
      <categories>
        <category>Java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试1</title>
    <url>/2025/09/26/Java%E9%9D%A2%E8%AF%951/</url>
    <content><![CDATA[Java面试1北京昇腾自我介绍
1.aop介绍和在项目中哪里使用了
我：什么aop，我只知道面向切面编程什么什么的，项目中我也不晓得用没用，只知道这个概念，好像没有具体使用。
答案：

AOP概念： “AOP是面向切面编程。它的核心思想是将那些遍布在业务逻辑中各处的、通用的功能（比如日志记录、权限检查、事务管理）抽取出来，做成独立的‘切面’，然后通过预编译方式或运行时动态代理的方式，在不修改原有业务代码的情况下，横向地织入到业务逻辑中。这样做的好处是业务模块更加纯净，只关注核心逻辑，代码复用性极高。”

项目应用： （这是关键，一定要结合项目！）

（论坛项目） “在我的校园论坛项目里，我使用AOP实现了全局的操作日志记录。我自定义了一个@Log注解，只要在Controller的方法上加上这个注解，AOP就会自动拦截这个方法，在方法执行后，将用户ID、操作内容、IP地址、执行时间等记录到数据库里。这样就不用在不相关的业务代码里到处写log.info()了。”
（通用场景） “还有就是，Spring的**声明式事务管理@Transactional**本身就是基于AOP实现的。在我的项目里，所有涉及数据库多步操作的方法，我都加上了这个注解来保证事务。”
（CTF项目） “在Gateway网关里，虽然用的是过滤器，但思想和AOP是相通的，实现了统一的鉴权和日志。”



2.怀疑我是不是计算机专业，问了课程
计网，计组，数据库，数据结构
3.队和栈区别，栈能不能实现链表，链表实现栈怎么实现
我：只回答了先入先出和先入后出，忘完了。
答案：

区别： “队列是FIFO，先进先出，就像食堂排队。栈是LIFO，后进先出，就像叠盘子，你只能拿最上面那个。”

栈能不能实现链表： “这个问题可能有点歧义。我理解您可能是想问能否用链表来实现栈？答案是肯定的，而且非常合适，因为链表在头节点的插入和删除操作都是O(1)时间复杂度的，完美契合栈的操作。”

链表实现栈怎么实现（口述思路）：

定义一个链表节点类Node，包含data和next指针。
定义一个栈类LinkedListStack，它只需要一个成员变量：指向栈顶的节点top。
入栈push()：新建一个节点，将该节点的next指向当前的top节点，然后将top指针指向这个新节点。
出栈pop()：如果top不为空，先保存top节点的值，然后将top指针指向top.next，最后返回保存的值。
查看栈顶peek()：直接返回top.data即可。



4.redis在项目中的应用，redis如何实现排名，为什么不用list,为什么不用mysql，并发量明明不高为什么不用mysql
我：存验证码，得分排名和点赞排名都用了，排名用的是有序集合，因为有序集合的score很容易实现由高到低的排名，list还要自己排序一下。mysql性能低，我的项目并发量不高但是为了让后期不再重新写这一块代码就用了redis，并且用mysql的话也要实现自己排序。
答案：

为什么不用List： “List是线性结构，缺乏排序能力。如果要实现排名，每次有分数更新都需要对整个List进行SORT操作，时间复杂度是O(N log N)，性能非常差。而Sorted Set（ZSet）底层是跳表（SkipList） 和哈希表，插入和更新分数的时间复杂度都是O(log N)，并且元素天然就是有序的。”
为什么不用MySQL： “虽然项目初期并发量不高，但排名是一个高频读写的场景。每次提交得分都要UPDATE分数然后SELECT ... ORDER BY score DESC，这个ORDER BY在数据量大时是性能瓶颈（涉及排序和文件排序）。MySQL的QPS远低于Redis。使用Redis作为缓存，将这部分压力从数据库剥离，是更科学的架构设计，也便于未来横向扩展。MySQL更适合作为‘最终’的数据持久化存储。”

5.redis和mysql的一致性，他那有点乱，没追问，应该感觉我g了，想早点结束
我：延迟双删，先删数据库再删缓存

“我们采用的是缓存失效模式 combined with 延迟双删策略 来尽可能保证最终一致性。”
“写请求的流程是：”
先淘汰（删除）Redis中的缓存数据。
再更新MySQL数据库。
（延迟双删）异步等待一小段时间（比如几百毫秒，通过MQ或异步线程），再次淘汰Redis缓存。 这个步骤是为了清除在‘更新MySQL’和‘再次读请求’这个时间间隙内，可能被读请求重新加载到Redis里的旧数据。


“读请求的流程是：”
先读Redis，命中则返回。
未命中则读MySQL，然后将数据写入Redis。



6.怎么查分数前三名学生，说top3布拉布拉的，但是他说top不是所有的都有，重新说，最后不会
我：用select top3 什么什么的，被反驳他说top不是所有的都有，然后说不会
答案：

“如果允许并列排名，并且希望看到所有并列前三的学生，单纯的LIMIT 3或TOP 3是不行的，因为它们只返回前三行。”

“标准的做法是使用窗口函数。这里有两种常用函数：

RANK()：如果有并列第一，那么下一个名次是第三。例如：1, 1, 3, 4, 5…
DENSE_RANK()：如果有并列第一，那么下一个名次是第二。例如：1, 1, 2, 3, 4…


“以DENSE_RANK()为例，SQL可以这样写：”
sql
-- 假设表名是 `students`， 有字段 `name` 和 `score`SELECT name, score, rankingFROM (  SELECT name, score, DENSE_RANK() OVER (ORDER BY score DESC) AS ranking  FROM students) AS tWHERE ranking &lt;= 3;

7.业务模块怎么相互调用，认证服务用的什么架构？
我：通过feign调用url和gateway统一转发api
答案：

服务调用： “内部服务间的调用，我们使用 Spring Cloud OpenFeign 进行声明式REST调用。这样就像调用本地方法一样，非常简洁。底层是通过HTTP协议+Json格式进行的通信。”
认证架构： “我们采用的是 Token-Based Authentication 架构，核心是 JWT。用户登录成功后，认证中心（Auth Service）会生成一个JWT Token返回给客户端。后续所有请求，客户端都会在Header中携带这个Token。”
流程： “API Gateway 作为统一入口，会校验Token的签名和有效期（这一步可以做简单的本地校验）。校验通过后，Gateway会将请求转发到对应的业务服务。业务服务本身不负责校验Token的合法性，但会从Token中解析出用户信息（如userId）来进行业务逻辑处理。”

8.登录token怎么保证安全和认证，调用不同服务token怎么校验
我：我在gateway写了filter和springsecretary统一拦截和校验token，再转发到各服务
答案：

安全保证：
数字签名： JWT最后一部分是签名，由服务端用私钥生成。任何对Header或Payload的篡改都会导致签名验证失败。
加密算法： 使用强算法如RS256（非对称加密）。
敏感信息： 不在Payload中存放敏感信息（如密码）。
HTTPS： 网络传输全程使用HTTPS，防止Token被窃取。
短期有效： 设置较短的Token过期时间，并配套刷新Token机制。


服务间校验： “在我们的架构中，业务服务本身不需要再次校验Token的签名。因为Gateway已经完成了这项最耗时的安全工作。业务服务只需要解析Token，取出其中的用户信息（如userId）即可。我们通过一个通用的JWT解析工具类来实现这一点，避免每个服务都写重复代码。”

9.管理端控制权限怎么实现
我：没写管理端但我想过这个问题，当时的想法是用ruoyi来管理
答案：

“虽然我的项目里没实现，但我思考过的方案是基于 RBAC（基于角色的访问控制） 模型来设计。”
“数据库层面会有五张核心表：用户表、角色表、权限表（或菜单表）、用户-角色关联表、角色-权限关联表。”
“在权限校验层面，我会在Gateway的全局过滤器或每个业务的Controller方法上，通过注解（如@PreAuthorize(&quot;hasAuthority(&#39;user:delete&#39;)&quot;)）的方式进行拦截。用户的权限信息可以在登录时一并加载并放入JWT，或者每次请求时从Redis中查询。”

10.什么模式来构建架构？不会，但是他说mvc什么什么的才想起来，然后追问自己在项目写的东西以及domain。感觉在怀疑我项目是不是自己写的
我：不知道什么事模式就是springboot那一套，但是他说mvc什么什么的才想起来，然后追问自己在项目写的东西以及domain，我说就是实体类加dto加vo这一套
答案：

“您指的是代码分层架构对吗？我们项目采用的是经典的 MVC分层架构 并结合了 DDD（领域驱动设计） 的一些思想。”
“具体分层是：
Controller层：接收请求，参数校验，返回响应。使用VO对象与前端交互。
Service层：核心业务逻辑层。接口和实现分离，使用DTO对象在层间传输。
Mapper&#x2F;Repository层：负责与数据库交互，操作Entity实体对象。
模型转换：我们会使用MapStruct或Spring的BeanUtils在Entity、DTO、VO之间进行转换，避免将数据库实体直接暴露给前端。”


“这样做的目的是为了解耦，让各层职责单一，便于维护和测试。”

11.微服务问了了解不了解netty什么什么，另一个微服务，我说我用的cloudalibaba。
我：不了解，我用的cloudalibaba
答案：

“Netty我知道，它是一个高性能的NIO网络编程框架，像Dubbo、RocketMQ、Elasticsearch这些中间件的网络通信层底层都用到了Netty。”
“虽然我现在的项目是基于Spring Cloud Alibaba的HTTP协议生态构建的，没有直接使用Netty API，但我理解它的重要性。如果未来有更高性能、需要长连接（如IM系统）的场景，我会优先考虑基于Netty的技术栈，比如直接使用Dubbo进行RPC调用。”

12.微服务两个表不在同一个，怎么关联？说了几种，都被否决了，应该是他没听到他想听的，然后我就不会了
我：我写的项目都用的一个库，没有不同微服务不同库，不会有这个问题。不满意后接着回答：每个调用方法调用其他方法返回的结果来关联，他说：那这样每次都需要调用其他方法，性能不好。接着回答：用gateway统一管理调用与返回，他说gateway不是必须的，没有gateway怎么办。之后我说不会。
答案：

“在标准的微服务架构下，数据库是随服务拆分的，禁止跨服务直接连库查询。对于这种需要关联查询的场景，常见的解决方案有几种：

API聚合（最常用）：在业务代码层进行。由服务A调用服务B的API获取所需数据，然后在内存中进行关联和组装。这是最直接的方式，但可能会增加网络开销。
数据冗余：（这可能是他最想听的） 将服务B的某些字段（如user_name）冗余到服务A的数据库中。通过MQ监听服务B的数据变更事件，来保证冗余数据的最终一致性。这是一种‘以空间换时间’的设计，非常适合高性能查询场景。
CQRS（命令查询职责分离）：构建一个专门用于查询的读服务，它的数据来自各个微服务，通过监听领域事件，将数据同步到一个只读数据库（如Elasticsearch）中，形成宽表，专门应对复杂的跨服务查询。”



13.问了rsa加密对称加密和非对称加密什么的，再说存密码用什么加密比较好
这个秒了，因为我打ctf就是密码方向的，没什么好说的
14.数据库索引，哪些情况会导致失效，运算符会不会导致索引失效
我：布拉布拉不拉，索引失效的八股文背上去了
答案：
15.然后问北京能过去不能之类的，大概是问方便不方便
16.反问问题
总结，八股基本没会的，java基础也好多不会，项目也有很多问题，基本没希望。
]]></content>
      <categories>
        <category>Java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>2025天机学堂</title>
    <url>/2025/08/11/2025%E5%A4%A9%E6%9C%BA%E5%AD%A6%E5%A0%82/</url>
    <content><![CDATA[2025天机学堂day01：初始化项目虚拟机密码：root      123321
192.168.150.101 git.tianji.com  tjxt  123321192.168.150.101 jenkins.tianji.com    root  123192.168.150.101 mq.tianji.com    tjxt  123321192.168.150.101 nacos.tianji.com      nacos   nacos192.168.150.101 xxljob.tianji.com192.168.150.101 es.tianji.com192.168.150.101 api.tianji.com192.168.150.101 www.tianji.com      jack  123   Rose  123456192.168.150.101 manage.tianji.com192.168.150.101 cpolar.tianji.com





点击init初始化虚拟机：
在VMware得到：

然后初始化网络配置，改成这样：

启动虚拟机，虚拟机中的环境会自启动，我们可以访问一个进行测试，访问是要访问我画红框的url：192.168.150.101:8848

然后我们也可以使用switchhost来代理，具体可以看我switchhost的文章
nginx无法启动问题，尝试重启进行解决：解决失败，但最后耗时四小时左右解决了，问题在于nginx的conf的语法问题，大概改成这样就好了：

然后复制初始化项目到本地：
http://192.168.150.101:10880/tjxt/tianji.git
git clone http://192.168.150.101:10880/tjxt/tianji.git -b lesson-init

然后打开项目刷新一下maven下下依赖就好了
遇到bug：

解决了一下午，到最后还是依赖问题：把这个注释的# 删掉

查找bug，Rose删除订单时显示不能删除他人订单
想远程调试，改成这样：

然后关掉tj-trade，启动tj-trade-debug
当然也可以直接本地调试，但是注意调试前编辑配置改为local

回到bug问题，将&#x3D;改成equals或者&#x3D;&#x3D;就好了
然后推送到本地的git就好了
day02：我的课表导入domain和enums然后下载mybatisplus插件然后连接：
jdbc:mysql:&#x2F;&#x2F;localhost:192.168.150.101:3306&#x2F;tj_learning?useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC
但是遇到问题：

还没解决，因为我数据库能连上但是这个插件连不上，所以暂时没管还能继续学下去
然后写那个课程弄到我的课表的代码，这就不复制了，比较简单
然后进行测试，他会显示报名失败，因为数据库数据太老了，你自己改一下时间就能报名成功了
然后第二个是分页查询课表，也是不难，但是别忘了在请求头中加user-info，要不然会报401
第三个查询正在学习的课程也是一样
课后作业我直接搬了
但是day02有个问题，没有解决：

但是后端接口正常使用，我就没管他
day03学习计划和进度写完代码后出现bug：

然后发现是serviceImpl忘加service注解了，加了就能解决了
遇到了问题：

这是数据库建表的问题，但感觉修改太麻烦了，我不改了。代码本身没问题
另外还是前端问题，导致数据没回显但是接口测试没问题
day3基本是水过去的
day04高并发优化u1s1面对高并发你会怎么办？hm飞书的答案：

要我说，口头表达一下大概就是：
1.存入redis后续更新数据库
2.消息队列，慢慢处理
3.限流
4.异步请求，先返回东西后进行处理  &#x2F;&#x2F;感觉和2重复了
然后就是改造代码，懒得看了，太无聊。
day05问答系统]]></content>
      <categories>
        <category>Java</category>
        <category>complete_item</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>complete_item</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见八股</title>
    <url>/2025/08/26/Java%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[Java常见八股一、Java 基础 (Java Basics)1. 接口 (Interface) vs 抽象类 (Abstract Class)面试官： 说一下接口和抽象类的区别。
我：好的，接口和抽象类主要有以下几个核心区别：

设计目的不同：抽象类描述的是 “is-a” 关系，强调类的本质是什么，比如 Manager 是一个 Employee。而接口描述的是 “has-a” 或 “can-do” 关系，强调类具备什么能力，比如 Bird 可以 Fly。
方法实现：抽象类可以有抽象方法，也可以有实现了的具体方法，用于代码复用。在JDK 8之前，接口只能有抽象方法；JDK 8之后，接口可以拥有默认方法（default）和静态方法（static）。
成员变量：抽象类中的变量可以是普通的，也可以是常量。而接口中定义的变量默认都是 public static final 的常量。
构造方法：抽象类有构造方法，虽然不能实例化自己，但可以供子类初始化时调用。接口没有构造方法。
继承性：这是最关键的差别。Java是单继承，一个类只能继承一个抽象类。但一个类可以实现多个接口，从而获得多种能力。

选用场景：

如果需要定义一系列密切相关对象的共同模板和行为，优先使用抽象类。
如果需要定义一种能力或契约，让不相关的类都能拥有，或者需要实现多重继承的效果，就使用接口。


2. 单例模式 (Singleton Pattern) 与双重检查锁 (Double-Checked Locking)面试官： 了解单例模式吗？写一个线程安全的单例。
我：单例模式的核心是保证一个类在任何情况下都只有一个实例，并提供一个全局访问点。
实现线程安全的单例有多种方式，比如饿汉式、懒汉式加锁、静态内部类等。其中，双重检查锁（DCL） 是一种性能和线程安全兼顾的懒加载方案。
（如果让写代码，我会写出DCL的代码。但按您要求，这里不做代码展示）
它的核心思路是：

将实例引用用 volatile 关键字修饰。
在 getInstance 方法中，先进行一次判空，如果实例不存在，再进入同步代码块。
进入同步块后，再进行第二次判空，最后才创建实例。

面试官： 为什么这里必须要用 volatile 关键字？
我：volatile 在这里主要作用是禁止指令重排序。
instance = new Singleton() 这行代码不是一个原子操作，它分为三步：1.分配内存、2.初始化对象、3.将引用指向内存地址。JVM可能对步骤2和3进行重排序。
如果没有 volatile，可能发生：线程A执行了1和3，此时 instance 不为null，但对象还未初始化（步骤2未执行）。这时线程B进来判断 instance 不为null，就直接返回了一个半成品对象去使用，从而导致错误。
volatile 通过内存屏障禁止了这种重排序，保证了对象的初始化完成在前，引用赋值在后，从而解决了这个隐蔽的问题。
其他实现方式的对比：

饿汉式：最简单，线程安全，但不是懒加载，可能造成资源浪费。
同步方法懒汉式：线程安全，但锁粒度太大，性能差。
静态内部类：我个人认为是最优雅的实现之一。它利用类加载机制保证了线程安全，且实现了懒加载，无需加锁，性能高。
枚举：最安全的方式，不仅能避免多线程问题，还能防止反射和反序列化破坏单例。

二、Java 集合框架 (Java Collections Framework)1. HashMap 深度解析面试官： 能详细说说 HashMap 的实现原理吗？
我：好的。HashMap 的核心实现是“数组 + 链表 + 红黑树”。

面试官： 具体讲讲它的数据结构？
我：

数据结构：
底层是一个 Node&lt;K,V&gt;[] table 数组。
数组的每个位置称为一个“桶”（bucket）。存入时，根据 key 的 hash 值计算出数组下标。
如果不同的 key 落到了同一个桶里（哈希冲突），就用链表来存储。
当链表长度超过阈值（默认为8），并且数组总长度达到一定规模（默认为64）时，链表会转换为红黑树。
当树节点数小于阈值（默认为6）时，红黑树会退化成链表。




面试官： 为什么要引入红黑树？
我：

引入红黑树的原因：

- 解决极端情况下（例如大量数据哈希冲突），链表过长导致的查询效率从 O(1) 退化为 O(n) 的问题。- 红黑树是一种自平衡的二叉查找树，能将查询、插入、删除的时间复杂度控制在 O(log n)，保证了性能下限。

面试官： HashMap 什么时候扩容？怎么扩？
我：

扩容机制（Rehashing）：

- 当元素数量超过 容量 * 负载因子（默认0.75）时，数组会进行扩容（通常扩为原来的2倍）。- 扩容后，所有元素需要重新计算在新数组中的位置，这是一个比较耗时的操作。

面试官： 为什么 HashMap 的长度总是2的幂次方？
我：

长度为何是2的幂次方：

- 为了高效地通过 (n - 1) &amp; hash 计算 key 的索引位置。- &amp; 操作比取模运算 % 效率高得多。当数组长度 n 为 2 的幂时，(n - 1) &amp; hash 等价于 hash % n，但效率更高，同时能保证计算结果均匀分布。

面试官： 从 JDK7 到 JDK8，HashMap 在解决冲突时有什么重要变化？
我：

JDK7头插法 -&gt; JDK8尾插法：

- JDK7 使用头插法，认为新插入的元素更可能被马上访问。但在多线程扩容时，头插法会改变链表的顺序，可能导致形成环形链表，引起死循环和数据丢失。- JDK8 改为尾插法，扩容时链表元素顺序不变，解决了这个潜在问题。（但HashMap本身仍非线程安全，只是解决了这个特定的死循环Bug）。

面试官： 为什么选择这种链表和红黑树结合的方式？
我：

为何采用链表+红黑树：

- 这是一种在空间和时间上的权衡。- 链表结构简单，占用内存少，但在节点多时性能差。- 红黑树性能好，但结构复杂，占用内存更多。- 这种设计保证了在绝大多数冲突较少的情况下使用高效的链表，仅在少数冲突严重时转为红黑树，以空间换时间，达到整体最优。
2. ArrayList vs LinkedList面试官： 对比一下 ArrayList 和 LinkedList。
我：好的。它们核心区别在于底层数据结构和由此带来的性能差异。

底层结构：
ArrayList 基于动态数组。内存中是连续的存储空间。
LinkedList 基于双向链表。内存中是通过节点指针连接的离散存储。




面试官： 它们在操作效率上有什么不同？
我：

操作效率：

- 随机访问 (get&#x2F;set)：ArrayList 的复杂度是 O(1)，因为它可以通过下标直接计算内存地址。LinkedList 是 O(n)，需要遍历链表。- 头部插入&#x2F;删除：ArrayList 是 O(n)，因为需要移动后续所有元素。LinkedList 是 O(1)，只需修改指针。- 尾部插入&#x2F;删除：两者在已知尾节点的情况下都接近 O(1)。ArrayList 在无需扩容时是 O(1)；LinkedList 需要先遍历到尾部（如果没有尾指针记录）是 O(n)，但通常实现会记录尾指针，所以也是 O(1)。- 中间插入&#x2F;删除：ArrayList 平均需要移动一半元素，是 O(n)。LinkedList 查找位置是 O(n)，但插入&#x2F;删除操作本身是 O(1)。

面试官： 它们的内存占用有什么特点？
我：

内存占用：

- ArrayList 只在数组尾部预留空间，内存利用率高。但扩容时会造成临时浪费。- LinkedList 每个元素都需要消耗额外空间存放前后节点的指针，内存开销更大。

面试官： 实际开发中如何选择？
我：

适用场景：

- 优先选择 ArrayList。因为它CPU缓存友好（内存连续），综合性能在大多数读多写少的场景下更好。- 只有在需要频繁在列表头部或中间进行插入&#x2F;删除操作时，才考虑使用 LinkedList。
3. ConcurrentHashMap 原理与演进面试官： 讲一下 ConcurrentHashMap 的原理，以及它在 JDK7 和 JDK8 的实现有什么不同。
我：好的。ConcurrentHashMap 是 HashMap 的线程安全版本，它的实现原理在 JDK7 和 JDK8 有重大变化。

面试官： 先说下 JDK7 是怎么实现的？
我：

JDK7分段锁实现 (Segment Locking)：
它内部有一个 Segment 数组，每个 Segment 本质上就是一个独立的、继承了 ReentrantLock 的 HashEntry[] 数组（一个小HashMap）。
“分段锁” 的思想是：锁不再针对整个Map，而是只锁住其中一个 Segment。这样，不同 Segment 的读写操作可以完全并行，大大提升了并发度。
默认有 16 个 Segment，所以理论上最多可以支持 16 个线程同时写入。




面试官： 那 JDK8 呢？为什么又改了？
我：

JDK8 CAS + synchronized 实现：

- JDK8 抛弃了 Segment 分段锁的概念，它的底层数据结构变得和 HashMap 一样，是 Node[] 数组 + 链表 + 红黑树。- 实现线程安全的方式更加细化：- CAS (无锁算法)：用于初始化数组、向桶中插入节点（当桶为空时）等无竞争场景，性能极高。- synchronized (同步锁)：当发生哈希冲突，需要操作链表或红黑树时，则只锁住当前发生冲突的桶（链表头节点&#x2F;树根节点）。锁的粒度从 JDK7 的一个 Segment（管着很多桶）缩小到了一个桶，并发度更高。- 这种设计结合了 CAS 的高性能和 synchronized 的稳定性，并且在锁粒度上做到了极致。

面试官： 从 JDK7 到 JDK8 这次升级主要带来了哪些好处？
我：

JDK7 到 JDK8 的升级：

- 锁粒度更小：从锁一段（Segment）到锁一桶（Bucket），并发性能得到极大提升。- 数据结构优化：引入了红黑树，解决了链表过长时查询慢的问题，保证了最坏情况下的性能。- API 增强：提供了更多方便的流式 API（如 forEach, reduce）。- 代码更简化：移除了复杂的 Segment 结构，底层实现变得更简洁、更统一（和 HashMap 类似），更易于维护和理解。
三、Java 并发编程 (Java Concurrency)1. 乐观锁与悲观锁面试官： 说说你对乐观锁和悲观锁的理解。
我：好的，这是两种不同的并发控制策略。

悲观锁：
思想：认为并发冲突是大概率事件，每次操作数据时，都假定别人会修改，所以先加锁再操作。
实现：synchronized 关键字、ReentrantLock 等。
类比：就像“写文档时先锁门”，防止别人打扰。


乐观锁：
思想：认为并发冲突是小概率事件，每次操作数据时，不会先加锁，而是在更新时判断此期间数据是否被他人修改过。
实现：通常使用 CAS (Compare-And-Swap) 算法或版本号机制。
类比：就像“写文档时不锁门”，提交时才检查有没有人动过原稿，没动过就提交，动了就放弃或重试。



适用场景：

悲观锁：适合写多读少的场景，冲突严重时性能高。
乐观锁：适合读多写少的场景，冲突少时性能远高于悲观锁，能减少上下文切换。

2. CAS 原理与原子类实现面试官： 讲一下 CAS 的原理。
我：

CAS实现原理：
CAS 的全称是 Compare-And-Swap，即比较并交换。它是一个CPU原子指令，保证了操作的原子性。
操作包含三个操作数：内存地址 V、旧的预期值 A、要更新的新值 B。
原理：当且仅当内存地址 V 中的当前值等于预期值 A 时，处理器才会自动将地址 V 的值更新为新值 B，否则什么都不做。整个操作是一个原子操作。




面试官： CAS 有什么优缺点？
我：优点：

高性能：它是一种无锁操作，避免了传统互斥锁（如 synchronized）带来的线程阻塞、上下文切换的开销，在低竞争环境下性能很高。

缺点：

ABA 问题：这是最经典的缺点。一个线程读取内存值为 A，此时另一个线程将值改为 B，然后又改回 A。等第一个线程执行 CAS 时，发现值还是 A，于是操作成功，但它并不知道这个 A 已经被“中间修改过”了。
循环时间长开销大：如果 CAS 操作长时间不成功（竞争激烈），CPU 会一直进行自旋（循环重试），消耗资源。
只能保证一个共享变量的原子操作：对于多个共享变量，CAS 无法保证原子性，可能需要加锁。


面试官： 那怎么解决 ABA 问题呢？
我：

可以通过给数据加上版本号（Stamp） 或时间戳来解决。
Java 提供了 AtomicStampedReference 类。它不仅在比较值，还会比较一个 int 型的版本号标记。任何对值的修改都会使版本号递增，这样即使值从 A 变回 A，版本号也变了，CAS 就会失败。


面试官： 原子类（比如 AtomicInteger）是如何利用 CAS 实现的？
我：

原子类实现原理：

- 原子类（如 AtomicInteger）内部的核心字段（如 value）都由 volatile 修饰，保证了可见性。- 它们的所有原子性方法（如 getAndIncrement()）内部都调用了 Unsafe 类的 CAS 方法（compareAndSwapInt）。- 以 i++ 为例，getAndIncrement() 的实现是一个 CAS 自旋循环：先获取当前值，计算新值，然后用 CAS 尝试更新。如果失败（值已被其他线程修改），就重新获取当前值，再次计算和尝试，直到成功为止。
3. synchronized 与 ReentrantLock 详解面试官： 对比一下 synchronized 和 ReentrantLock。
我：好的，它们的核心区别如下：

本质不同：synchronized 是 Java 关键字，由 JVM 底层实现；ReentrantLock 是一个 Java 类，基于 AQS 实现。
锁的释放：synchronized 在代码块执行完或发生异常时，由 JVM 自动释放锁；ReentrantLock 必须手动调用 unlock() 方法释放锁，通常在 finally 块中完成，否则容易造成死锁。
功能丰富性：ReentrantLock 功能更丰富。
可中断：lockInterruptibly() 可以响应中断，在等待锁的过程中可以被中断。
公平锁：可以选择创建公平锁（先等待的线程先获得锁），synchronized 是非公平锁。
条件队列：可以通过 Condition 实现多路通知，更精细地控制线程的等待与唤醒。


灵活性：synchronized 的加锁和释放锁是固化的；ReentrantLock 可以在方法内加锁，在另一方法内解锁，更灵活。
锁的实现机制：synchronized 在 JDK6 后引入了锁升级机制来优化性能；ReentrantLock 则通过 AQS 内部的 CAS 自旋来实现。

选用建议：

除非需要 ReentrantLock 的高级功能（如可中断、公平锁、Condition），否则优先使用 synchronized，因为它的写法更简洁，且由 JVM 维护和优化。


面试官： 详细说一下 synchronized 的锁升级流程。
我：

synchronized 的锁升级流程：

为了在性能和开销之间取得平衡，JVM 将 synchronized 的锁状态分为4级，并可以从低到高进行升级，但不可降级。
- **无锁 (No Lock)**：对象未作为同步锁使用。- **偏向锁 (Biased Locking)**：    - **目的**：在**没有竞争**的情况下，消除同步开销。假设锁总是由同一线程获得。    - **流程**：第一个线程访问同步块时，会通过 CAS 操作将对象头中的 Mark Word 里存储的线程 ID 改为自己的 ID。之后该线程再进入时，只需检查线程 ID 是否匹配，匹配则无需任何同步操作。- **轻量级锁 (Lightweight Lock)**：    - **触发条件**：当有**轻微竞争**（第二个线程来尝试获取锁）时，偏向锁会升级为轻量级锁。    - **流程**：线程会在自己的栈帧中创建一个锁记录（Lock Record），然后通过 **CAS** 操作尝试将对象头的 Mark Word 更新为指向该锁记录的指针。如果成功，当前线程就获得了锁。如果失败，会**自旋**重试一定次数。- **重量级锁 (Heavyweight Lock)**：    - **触发条件**：**自旋失败**（竞争加剧，线程数多或等待时间长）后，锁会升级为重量级锁。    - **流程**：此时，未获得锁的线程会**被挂起**，进入阻塞状态，等待操作系统调度，需要进行用户态到内核态的切换，开销最大。


面试官： 什么是 synchronized 的可重入性？
我：

synchronized 的可重入性：

- 概念：指同一个线程在执行完外层同步方法&#x2F;块后，再次进入它的内层同步方法&#x2F;块时，可以直接获得锁而不会被自己阻塞。- 原理：JVM 会为每个锁对象维护一个计数器和一个持有者线程标识。当线程第一次获取锁时，计数器变为1。每次重入，计数器就+1。退出同步块，计数器就-1。直到计数器为0，锁才被真正释放。- 重要性：可重入性避免了线程死锁自己，是设计同步代码的基础。
4. volatile 关键字的作用与原理面试官： 讲一下 volatile 关键字的作用和原理。
我：好的。volatile 是 Java 提供的轻量级同步机制，它主要有两大核心作用：保证内存可见性 和 禁止指令重排序。

面试官： 先解释一下什么是内存可见性，volatile 是如何保证的？
我：

内存可见性 (Memory Visibility)：
问题：根据 Java 内存模型 (JMM)，每个线程有自己的工作内存，用于缓存共享变量的副本。当一个线程修改了共享变量，可能只是先修改了自己的工作内存，未能立即写回主内存，导致其他线程读取到的仍然是旧的副本值。
volatile 的作用：当一个变量被声明为 volatile 后：
任何线程修改这个变量，都会立即强制将新值刷新到主内存。
任何线程读取这个变量，都会强制从主内存中重新读取最新的值，使当前工作内存中的副本失效。


原理：底层是通过内存屏障 (Memory Barrier) 来实现的。写操作前后会插入屏障，强制将缓存数据刷回主存；读操作前后也会插入屏障，强制使本地缓存失效，从主存拉取新数据。




面试官： 那禁止指令重排序呢？这又是什么？
我：

禁止指令重排序 (Prevention of Instruction Reordering)：

- 问题：为了提升性能，编译器和处理器常常会对指令进行重排序。但在多线程环境下，不恰当的重排序可能会导致程序运行结果与预期不符。（最经典的例子就是双重检查锁单例模式中，instance = new Singleton() 这行代码可能被重排序，导致其他线程拿到一个未初始化完全的对象）。- volatile 的作用：通过添加内存屏障，volatile 关键字禁止了 JVM 和处理器对修饰了 volatile 的变量的读写操作与其他指令进行重排序，从而保证了操作的有序性。- 原理：内存屏障就像一个“栅栏”，告诉编译器和 CPU，必须在这个屏障之前的所有操作都完成后，才能执行屏障之后的操作。
总结：volatile 的核心是通过内存屏障这一 CPU 指令来实现可见性和有序性。但它不保证原子性，像 i++ 这种复合操作依然需要加锁或使用原子类。
5. Java 内存模型 (JMM) 与 Happens-Before面试官： 谈谈你对 Java 内存模型 (JMM) 的理解。
我：好的。JMM 是一个抽象的概念，它定义了程序中各种变量（线程共享变量）的访问规则，以及如何在内存中进行读写操作的细节。它屏蔽了底层硬件内存结构的差异，旨在解决多线程下的可见性、原子性和有序性问题。

面试官： JMM 是如何抽象内存结构的？
我：

JMM抽象模型（主内存、工作内存）：

主内存 (Main Memory)：存储所有的共享变量。所有线程都能访问，但速度较慢。
工作内存 (Working Memory)：每个线程都有自己的工作内存，可以看作是CPU高速缓存和寄存器的抽象。它存储了该线程使用到的共享变量的副本。
交互协议：JMM 规定了线程如何与主内存进行交互：
read：从主内存读取数据到工作内存。
load：将 read 得到的值放入工作内存的变量副本中。
use：执行引擎使用工作内存中的变量值。
assign：执行引擎将新值赋给工作内存中的变量。
store：将工作内存中的变量值传送到主内存。
write：将 store 传来的值写入主内存的变量中。



JMM 通过这8种原子操作（还有 lock 和 unlock）来控制主内存与工作内存之间的同步，从而决定一个线程对共享变量的写入何时对另一个线程可见。volatile 的特殊规则就体现在它强制 read&#x2F;load&#x2F;use 和 assign&#x2F;store&#x2F;write 必须连续、按顺序执行。



面试官： 什么是指令重排序？它为什么会带来问题？
我：

指令重排序：

- 原因：为了充分发挥 CPU 性能，编译器和处理器常常会在不改变程序单线程执行结果的前提下，对指令的执行顺序进行重新排序优化。- 问题：在多线程环境下，这种重排序可能会破坏程序的语义，导致线程执行结果出现不可预测的错误。（例如，双重检查锁单例模式中，由于 new 操作的非原子性可能被重排序，导致其他线程拿到一个未初始化完全的对象引用）。

面试官： JMM 如何解决可见性和有序性问题？什么是 Happens-Before 原则？
我：

Happens-Before 原则：

- 这是 JMM 最核心的概念。它本质上是一种可见性保证规则，用于描述两个操作之间的内存可见性。如果操作 A Happens-Before 于操作 B，那么 A 操作所产生的所有内存更改（结果）对 B 操作都是可见的。- 它是一些规则的集合，无需任何同步手段就天然具有 Happens-Before 关系：

程序次序规则：在一个线程内，书写在前面的操作 Happens-Before 于后面的操作。（注意：这仅指执行结果上的顺序，依然可能被重排序，但重排序后的结果必须与按代码顺序执行的结果一致）。
监视器锁规则：对一个锁的 unlock 操作 Happens-Before 于后续对这个锁的 lock 操作。
volatile变量规则：对一个 volatile 变量的写操作 Happens-Before 于后续对这个变量的读操作。
线程启动规则：Thread 对象的 start() 方法调用 Happens-Before 于此线程的任何动作。
线程终止规则：线程中的所有操作都 Happens-Before 于其他线程检测到该线程已经终止（如 thread.join() 返回）。
传递性：如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

**总结**：Happens-Before 关系并不代表实际执行的时间顺序，而是**内存可见性的保证**。它是判断数据是否存在竞争、线程是否安全的主要依据。

6. AQS 原理浅析面试官： 讲一下 AQS 的核心原理。
我：好的。AQS (AbstractQueuedSynchronizer) 是 JUC 并发包的核心基础组件，像 ReentrantLock、CountDownLatch 等工具都是基于它实现的。它的核心思想是 “一个状态位（state）+ 一个FIFO线程等待队列（CLH）”。

面试官： 具体说说 state 和 CLH 队列的作用。
我：

AQS核心思想（state、CLH队列）：
状态 (state)：这是一个由 volatile 修饰的 int 成员变量，表示共享资源的状态。具体含义由子类定义，例如：
在 ReentrantLock 中，state=0 表示锁未被占用，state&gt;0 表示锁被占用，且数值表示重入次数。
在 Semaphore 中，state 表示剩余的许可证数量。


CLH队列：这是一个虚拟的双向 FIFO 队列，用于管理获取资源失败的线程。当线程争抢资源失败时，AQS 会将当前线程及其等待状态等信息构造成一个节点（Node）并加入队尾，然后阻塞该线程（LockSupport.park()）。队列头节点表示当前正持有资源的线程。




面试官： AQS 是如何基于这个核心思想来实现公平锁的？
我：

如何实现公平锁：

- 公平锁 的核心原则是：先来后到，即等待时间最长的线程（队列头节点的后继节点）优先获取资源。- 实现机制：当一个线程（Thread-A）尝试通过 lock() 方法获取锁时，它的核心逻辑是：

检查 state 是否为 0（锁是否空闲）。
在判断锁空闲后，公平锁的实现会先调用 hasQueuedPredecessors() 方法检查等待队列中是否有其他线程在排队。

- 如果队列为空，或者当前线程自己就是队列的头节点（即将被唤醒的下一个），那么它才有资格去用 CAS 竞争锁。- 如果发现队列中有其他线程在等待，那么当前线程会放弃竞争，直接将自己加入队列末尾进行等待，这就保证了“先来后到”的公平性。- 与非公平锁的区别：非公平锁（ReentrantLock 的默认方式）在尝试获取锁时，不管队列里有没有线程在等，都会直接去用 CAS 抢锁。抢失败了才入队。这提高了吞吐量但可能导致“插队”现象，造成线程饥饿。
四、Java 虚拟机 (JVM)1. JVM 内存区域与分配面试官： 说一下 JVM 的内存区域是如何划分的。
我：好的。JVM 内存区域主要分为线程共享区和线程私有区。

面试官： 线程共享区包含哪些？各自的作用是什么？
我：

线程共享区：
堆 (Heap)：
作用：这是最大的一块内存区域，用于存放对象实例和数组。GC（垃圾回收）主要发生在这里。
细分：从垃圾回收角度，可分为新生代 (Young Generation) 和老年代 (Old Generation)。新生代又分为 Eden 区和两个 Survivor区 (S0&#x2F;S1)。


方法区 (Method Area)：
作用：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
实现：在 JDK8 之前，它的实现是“永久代”(PermGen)。在 JDK8 及之后，改为了元空间 (Metaspace)，并使用本地内存 (Native Memory) 来实现，大大降低了OOM的风险。






面试官： 那线程私有区呢？
我：

线程私有区：

- 虚拟机栈 (VM Stack)：- 作用：描述的是 Java 方法执行的内存模型。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。我们常说的“栈内存”就是指这里。- 异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError；如果栈可以动态扩展但无法申请到足够内存，则抛出 OutOfMemoryError。- 本地方法栈 (Native Method Stack)：- 作用：与虚拟机栈非常相似，区别在于它为虚拟机使用的 Native 方法服务。- 程序计数器 (Program Counter Register)：- 作用：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域。

面试官： 你刚才还提到了直接内存，它属于 JVM 内存区域吗？
我：

直接内存 (Direct Memory)：

- 不属于 JVM 运行时数据区，也不是 JVM 规范中定义的内存区域。- 作用：它是由 NIO 的 DirectByteBuffer 引用的内存区域，通常直接在物理内存上分配，避免了在 Java 堆和 Native 堆之间来回复制数据，从而能显著提高性能。- 影响：虽然不受 JVM 内存管理，但其大小也会受到本机总内存的限制。如果各个内存区域的总和大于物理内存限制，动态扩展时可能导致 OutOfMemoryError。
2. 垃圾回收算法与收集器面试官： 讲一下 JVM 如何确定一个对象是垃圾？以及有哪些垃圾回收算法。
我：好的。垃圾回收主要分两步：首先确定对象是否存活（是垃圾），然后进行回收。

面试官： 先说下如何确定垃圾。
我：

确定垃圾的算法：
引用计数法：
原理：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为0的对象就是不可能再被使用的。
缺点：它无法解决对象之间循环引用的问题（即A引用B，B也引用A，但再无第三方引用它们俩），从而导致内存泄漏。因此，主流的 Java 虚拟机都没有选用引用计数法。


可达性分析算法：
原理：这是 JVM 采用的算法。通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。如果某个对象到 GC Roots 间没有任何引用链相连（即从 GC Roots 到这个对象不可达），则证明此对象是不可能再被使用的。
哪些对象可以作为 GC Roots：
虚拟机栈（栈帧中的局部变量表）中引用的对象。
本地方法栈中 JNI（即 Native 方法）引用的对象。
方法区中类静态属性引用的对象。
方法区中常量引用的对象。
Java 虚拟机内部的引用（如基本类型对应的 Class 对象，常驻的异常对象等）。
被同步锁（synchronized）持有的对象。








面试官： 确定了垃圾之后，有哪些回收算法？
我：

回收垃圾的算法：

- 标记-清除算法：- 过程：分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。- 缺点：效率不高，且会产生大量不连续的内存碎片，导致以后需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次 GC。
- **复制算法**：    - **过程**：将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象**复制**到另外一块上面，然后再把已使用过的内存空间一次清理掉。    - **优点**：实现简单，运行高效，且没有内存碎片。    - **缺点**：**内存代价太高**，可用内存缩小为了原来的一半。    - **应用**：是**新生代**垃圾回收的主要算法。商业虚拟机都采用这种算法来回收新生代，但并不是按1:1的比例划分，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。- **标记-整理算法**：    - **过程**：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。    - **优点**：避免了内存碎片，也避免了复制算法的空间浪费。    - **缺点**：移动存活对象并更新所有引用地址是一项负重操作，需要暂停用户线程（Stop The World）。    - **应用**：主要用于**老年代**的垃圾回收。- **分代收集算法**：    - **本质**：这不是一种具体的算法，而是一种**理论**。当前商业虚拟机的垃圾收集器都采用它。    - **思想**：根据对象存活周期的不同，将 Java 堆划分为**新生代**和**老年代**，然后根据各个年代的特点采用最适当的收集算法。        - 在**新生代**中，每次垃圾收集时都有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。        - 在**老年代**中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记-清除**或**标记-整理**算法来进行回收。

3. 性能调优、OOM与内存泄漏面试官： 谈谈JVM调优的目标和常用参数。
我：好的。JVM调优的核心目标是在吞吐量、延迟和内存占用三者间找到最佳平衡。

JVM调优目标：
低延迟：减少 GC停顿时间（Stop-The-World），提高应用响应速度，适合Web等交互式应用。
高吞吐量：减少GC总耗时，增大应用运行时间占比，适合后台计算型任务。
减少内存占用：在满足需求的前提下，控制堆内存大小。


常用参数：
-Xms 和 -Xmx：设置堆的初始大小(-Xms)和最大大小(-Xmx)，通常设为相同值以避免扩容带来的性能抖动。
-Xmn：设置新生代大小。整个JVM堆大小 &#x3D; 新生代 + 老年代。
-XX:SurvivorRatio：设置Eden区与一个Survivor区的比例（默认为8，即Eden:S0:S1&#x3D;8:1:1）。
-XX:+UseG1GC：指定使用G1垃圾收集器。
-XX:+PrintGC &#x2F; -XX:+PrintGCDetails：打印GC日志，用于排查。
-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize：设置元空间初始大小和最大大小。




面试官： 什么是逃逸分析？栈上分配又是什么？
我：

逃逸分析：是JIT编译器的一种高级优化技术。它通过分析对象的作用域，判断一个对象是否会被外部方法或外部线程所引用。
方法逃逸：对象被作为参数传递给其他方法。
线程逃逸：对象被赋值给其他线程可访问的实例变量。


栈上分配：
如果逃逸分析证明一个对象不会逃逸出方法，那么这个对象就可以在栈上分配内存，而不是在堆上。
好处：对象随方法栈帧出栈而自动销毁，无需垃圾回收器介入，极大减轻了GC压力，提升了性能。




面试官： 常见的OutOfMemoryError有哪些？如何排查？
我：

OutOfMemoryError避免与排查：

OOM错误有多种类型，每种原因不同：- Java heap space：堆内存溢出。最常见，原因是对象太多或存在内存泄漏，堆空间不足。- 排查：使用-XX:+HeapDumpOnOutOfMemoryError参数在OOM时自动生成堆转储文件，然后用MAT、JProfiler等工具分析，找到是哪些对象占用了大量内存以及它们的GC Roots引用链。- Metaspace &#x2F; PermGen space：元空间（方法区）溢出。原因是加载的类过多，如大量动态代理、反射。- GC overhead limit exceeded：GC overhead limit exceeded：GC回收效率过低导致的溢出。默认如果超过98%的时间都在做GC并且回收不到2%的堆空间，就会抛出此错误。本质是堆内存太小或内存泄漏。- Unable to create new native thread：无法创建本地线程。原因是创建的线程数超过系统限制（如Linux的ulimit）或内存不足。

面试官： 什么是内存泄漏？举几个常见例子。
我：

内存泄漏概念与常见案例：

- 概念：指程序中已动态分配的堆内存由于某种原因未能被释放或无法被释放，造成系统内存的浪费，最终可能导致OOM。- 它与内存溢出的关系：内存泄漏是原因，内存溢出是结果。持续的泄漏最终会导致溢出。
**常见案例**：- **缓存泄漏**：使用了无大小限制的缓存（如`HashMap`作为缓存），对象只放入不取出。应使用`WeakHashMap`或类似Guava Cache的、具有LRU淘汰机制的缓存。- **监听器未移除**：向全局集合（如一个静态List）注册了监听器，但在对象不用后没有取消注册，导致集合一直持有对象的引用，无法被回收。- **数据库连接、文件流未关闭**：这些资源不仅占用内存，还占用系统句柄。- **内部类持有外部类引用**：非静态内部类会隐式持有外部类的引用。如果这个内部类的实例被一个长生命周期对象引用，就会导致外部类也无法被回收。



五、Java 多线程 (Java Multithreading)1. 线程池核心原理与参数配置面试官： 说一下线程池的7个核心参数。
我：好的。通过 ThreadPoolExecutor 的构造函数，可以看到7个核心参数：

corePoolSize：核心线程数。线程池维护的最小线程数量，即使它们处于空闲状态，也不会被回收（除非设置了 allowCoreThreadTimeOut）。
maximumPoolSize：最大线程数。线程池允许创建的最大线程数量。
keepAliveTime：空闲线程存活时间。当线程数超过 corePoolSize 时，多余的空闲线程在终止前等待新任务的最长时间。
unit：keepAliveTime 参数的时间单位。
workQueue：任务队列。用于保存等待执行的任务的阻塞队列（如 ArrayBlockingQueue, LinkedBlockingQueue）。
threadFactory：线程工厂。用于创建新线程，可以设置线程名、优先级等，便于排查问题。
handler：拒绝策略。当线程池和队列都已满时，用于处理新提交任务的策略（如抛出异常、直接丢弃等）。


面试官： 描述一下任务提交到线程池后的执行流程。
我：

任务提交流程：

当一个新任务被提交 (execute()) 时，流程如下：

首先，判断当前运行的线程数是否小于 corePoolSize。如果是，则创建新的核心线程来执行该任务（即使有其他空闲线程）。
如果当前线程数已达到 corePoolSize，则尝试将任务放入工作队列 (workQueue) 等待。
如果队列已满，则判断当前线程数是否小于 maximumPoolSize。如果是，则创建新的非核心线程来执行该任务。
如果线程数也已达到 maximumPoolSize，并且队列已满，则触发拒绝策略 (handler)。

**简单记法**：**先核心 -&gt; 再入队 -&gt; 后扩容 -&gt; 最后拒绝**。


面试官： 在实际项目中，如何设置核心线程数？
我：

核心参数计算：

这是一个经验值，需要根据任务类型是 CPU密集型 还是 IO密集型 来调整。
- **CPU密集型**：    - **特点**：任务主要消耗CPU资源，需要进行大量计算（例如，计算圆周率、视频编码）。    - **设置**：线程数不宜过多，通常设置为 **`CPU核心数 + 1`**。设置过多会导致大量的线程上下文切换，反而降低性能。- **IO密集型**：    - **特点**：任务大部分时间在等待IO操作（如数据库查询、网络请求、文件读写），CPU空闲。    - **设置**：线程数可以设置得多一些，以充分利用CPU资源。通常可以设置为 **`2 * CPU核心数`**，或者更高。更精确的估算公式是：**`线程数 = CPU核心数 * (1 + 平均等待时间 / 平均计算时间)`**。**注意**：这只是一个理论上的起始值，**实际生产中需要通过压测来找到最适合自己应用的参数**。



六、数据库 (Database)1. MySQL1.1 事务与 ACID 属性
面试官： 你先说说 MySQL 的事务和它的 ACID 属性吧。
我：
好的。事务是数据库操作的基本单元，它是一个不可分割的工作序列，要么全部执行成功，要么全部执行失败，能保证数据的一致性和完整性。
事务的 ACID 属性是其核心特性，具体指：

原子性（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成，不会存在部分执行的情况。比如转账时，“从 A 账户扣钱” 和 “给 B 账户加钱” 这两个操作要么都成功，要么都失败，不会出现 A 扣了钱但 B 没收到的情况。

一致性（Consistency）：事务执行前后，数据库的完整性约束不会被破坏。例如，假设表中有 “总金额 &#x3D; A 账户金额 + B 账户金额” 的约束，转账事务执行后，这个等式依然成立。

隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应被其他事务干扰，每个事务都像在独立执行一样。避免因并发操作导致的数据不一致问题。

持久性（Durability）：一旦事务提交成功，它对数据库中数据的修改就是永久性的，即使之后发生数据库崩溃等故障，修改的数据也不会丢失。


1.2 事务隔离级别与 MVCC 机制
面试官： 那事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？MVCC 机制你了解吗？
我：
事务隔离级别是为了应对并发事务可能出现的问题（如脏读、不可重复读、幻读）而设定的，主要有 4 种：

读未提交（Read Uncommitted）：最低的隔离级别。一个事务可以读取到另一个未提交事务修改的数据，可能导致脏读（读取到未提交的无效数据）。

读已提交（Read Committed）：一个事务只能读取到另一个已提交事务修改的数据，解决了脏读问题，但可能出现不可重复读（同一事务中多次读取同一数据，结果因其他事务提交的修改而不同）。

可重复读（Repeatable Read）：MySQL 的默认隔离级别。保证同一事务中多次读取同一数据时，结果一致，解决了不可重复读问题，但在默认情况下可能出现幻读（同一事务中，按同一条件多次查询，结果集行数因其他事务的插入 &#x2F; 删除而变化）。

串行化（Serializable）：最高的隔离级别。事务串行执行，完全避免了并发问题，但性能极低，通常只在数据一致性要求极高且并发量低的场景使用。


MVCC（Multi-Version Concurrency Control，多版本并发控制）是 MySQL 实现读已提交和可重复读隔离级别的核心机制，它通过为数据保存多个版本，让读写操作不相互阻塞，提升并发性能。其实现原理主要涉及版本链和ReadView：

版本链：每行数据在被修改时，会生成一个新的版本，旧版本不会被立即删除，而是保留下来并通过隐藏列（如DB_TRX_ID记录修改事务 ID、DB_ROLL_PTR指向旧版本数据）形成链表，即版本链。

ReadView：事务在进行快照读（普通 SELECT 操作）时，会生成一个 ReadView，它包含当前活跃事务的 ID 列表等信息。通过比较数据版本的DB_TRX_ID与 ReadView 中的信息，来判断该版本数据是否可见：若数据版本的事务 ID 不在活跃列表中且小于 ReadView 中的最大事务 ID 等（不同隔离级别下判断逻辑有差异），则数据可见。


读已提交隔离级别下，每次执行 SELECT 都会生成一个新的 ReadView，所以能看到其他事务已提交的修改；可重复读隔离级别下，仅在第一次 SELECT 时生成 ReadView，之后复用该 ReadView，因此能保证同一事务中多次读取结果一致。
面试官： 那可重复读级别下是怎么解决幻读的呢？
我：
MySQL 的可重复读级别通过 “MVCC 快照读 + Next-Key Lock 当前读” 的组合来解决幻读问题：

MVCC 快照读：对于普通的 SELECT 查询（快照读），由于复用第一次生成的 ReadView，即使其他事务插入了新数据，新数据的事务 ID 在当前 ReadView 中可能被判定为不可见，因此不会读取到新插入的数据，避免了快照读场景下的幻读。

Next-Key Lock 当前读：对于加锁的查询（如SELECT … FOR UPDATE、UPDATE、DELETE等当前读操作），MySQL 会使用 Next-Key Lock。它是行锁和间隙锁的组合，不仅会锁定符合条件的行，还会锁定这些行所在间隙（即不存在的、可能被插入数据的区间），防止其他事务在间隙中插入新数据，从而避免了当前读场景下的幻读。


1.3 锁机制：间隙锁与临键锁
面试官： 聊完隔离级别，再说说 MySQL 的锁机制吧，特别是间隙锁和临键锁。
我：
MySQL 的锁机制按粒度可分为表锁、行锁等，行锁是并发控制的关键，而间隙锁和临键锁是行锁的扩展：

间隙锁（Gap Lock）：锁定的是一个区间，而不是具体的行。当事务对某条记录加锁时，若该记录所在索引区间存在未使用的间隙，会对这些间隙加锁。例如，表中有 id 为 1、3、5 的记录，对 id&#x3D;3 的记录加锁时，可能会锁定 (1,3)、(3,5) 这样的间隙，防止其他事务在这些间隙中插入 id&#x3D;2、4 的记录，主要用于解决幻读。

临键锁（Next-Key Lock）：是行锁和间隙锁的结合，锁定的是 “记录 + 间隙”。它会锁定当前记录以及该记录前面的间隙。比如上述 id&#x3D;3 的例子，临键锁会锁定 (1,3] 这个区间（包含 3 这条记录和 1 到 3 之间的间隙）。在可重复读隔离级别下，MySQL 默认使用临键锁进行当前读操作，当查询条件是唯一索引且精确匹配时，临键锁会降级为行锁。


1.4 索引与优化：回表查询与覆盖索引
面试官： 索引相关的，回表查询和覆盖索引你清楚吗？
我：
这两个概念和索引的结构密切相关，MySQL 中最常用的索引是 B + 树索引：

回表查询：B + 树索引分为聚簇索引和非聚簇索引（二级索引）。聚簇索引的叶子节点存储的是完整的行数据，而非聚簇索引的叶子节点存储的是行数据的主键值。当使用非聚簇索引查询数据时，若查询的字段不在非聚簇索引中，需要先通过非聚簇索引找到主键值，再到聚簇索引中根据主键值查找完整的行数据，这个过程就叫回表查询。回表会增加 IO 操作，影响查询效率。

覆盖索引：若查询的所有字段都包含在非聚簇索引中（即非聚簇索引的叶子节点已包含查询所需的全部数据），则不需要回表，直接通过非聚簇索引就能获取到数据，这种索引就是覆盖索引。例如，表有索引idx_name(name)，执行SELECT name, age FROM table WHERE name&#x3D;’xxx’，若age也在idx_name索引中（如联合索引idx_name_age(name, age)），则该索引就是覆盖索引，能避免回表，提升查询效率。


1.5 性能分析：EXPLAIN 与索引失效
面试官： 那怎么分析 SQL 性能？索引为什么会失效呢？
我：
分析 MySQL SQL 性能最常用的工具是EXPLAIN命令，在 SQL 语句前加上EXPLAIN，执行后会得到查询计划，通过查看各列（如type、key、rows、extra等）的信息，能判断索引是否被使用、查询效率如何：

type：表示访问类型，从好到差有system、const、eq_ref、ref、range、index、ALL等，range及以上通常表示使用了索引，ALL是全表扫描，效率低。

key：显示实际使用的索引，若为NULL则未使用索引。

rows：预估需要扫描的行数，行数越少越好。

extra：包含额外信息，如Using index表示使用了覆盖索引，Using filesort表示需要额外排序（效率低），Using temporary表示使用了临时表（效率低）等。


索引失效的原因有很多，常见的有：

索引列上使用了函数或表达式，如WHERE SUBSTR(name, 1, 1)&#x3D;’a’，会导致索引无法被使用。

索引列进行了隐式类型转换，如索引列是varchar类型，查询时用WHERE id&#x3D;123（123 是数字），MySQL 会进行类型转换，导致索引失效。

使用NOT IN、!&#x3D;、&lt;&gt;等否定操作符，可能导致索引失效（视情况而定，部分场景下可能使用索引）。

LIKE查询以%开头，如WHERE name LIKE ‘%abc’，无法使用索引的前缀匹配，导致索引失效。

联合索引未遵循 “最左前缀原则”，即查询条件不包含联合索引的第一个列，如联合索引(a,b,c)，查询WHERE b&#x3D;1 AND c&#x3D;2，会导致索引失效。

表中数据量极少，MySQL 认为全表扫描比使用索引更高效，会放弃使用索引。


1.6 日志系统：三大日志解析（undo log、redo log、binlog）
面试官： 最后说说 MySQL 的三大日志吧，undo log、redo log、binlog。
我：
MySQL 的三大日志在数据一致性、事务恢复、主从复制等方面起着关键作用：

undo log（回滚日志）：

作用：用于事务回滚和 MVCC。当事务修改数据时，会先将数据的旧版本记录到 undo log 中。若事务需要回滚（如执行ROLLBACK），可以通过 undo log 恢复数据到修改前的状态；同时，undo log 也是 MVCC 中版本链的重要组成部分，供快照读时获取旧版本数据。

特点：是逻辑日志，记录的是 “做了什么操作可以恢复数据”，且会随着事务的提交或回滚被清理。

redo log（重做日志）：

作用：保证事务的持久性。事务执行过程中，对数据的修改会先写入内存的缓冲池，同时将修改操作记录到 redo log（先写 redo log buffer，再刷到磁盘）。若数据库发生崩溃，重启后可以通过 redo log 重新执行已提交的事务操作，恢复数据，避免因内存数据丢失导致的数据不一致。

特点：是物理日志，记录的是 “某个数据页做了什么修改”，采用循环写的方式，有固定大小。

binlog（二进制日志）：

作用：用于主从复制和数据备份恢复。它记录了所有对数据库的修改操作（如INSERT、UPDATE、DELETE等），不记录查询操作。主库将 binlog 发送给从库，从库通过执行 binlog 中的操作实现主从数据同步；同时，若数据库发生故障，可通过 binlog 结合备份恢复到指定时间点的数据。

特点：是逻辑日志，记录的是操作的逻辑（如 “插入一条 id&#x3D;1 的记录”），采用追加写的方式，不会覆盖旧日志，可通过expire_logs_days等参数设置自动清理策略。


三者的配合：事务执行时，先写 undo log，再修改缓冲池数据，同时写 redo log（prepare 阶段），事务提交时，写 binlog，最后将 redo log 标记为提交（commit 阶段），确保数据的一致性和持久性。
2. Redis2.1 核心数据类型与应用场景（String, Hash, List, Set, ZSet 等）
面试官： 说说 Redis 的核心数据类型有哪些，各自的应用场景是什么？
我：
Redis 的核心数据类型是其基础，常见的有 String、Hash、List、Set、ZSet 这五种，每种都有独特的结构和适用场景：

String（字符串）：

结构：最基础的数据类型，底层可存储字符串、整数或浮点数，最大能存储 512MB。

应用场景：缓存简单数据（如用户信息 JSON 串）、计数器（用INCR&#x2F;DECR实现点赞数、访问量统计）、分布式锁（通过SETNX命令）、Session 共享等。

Hash（哈希）：

结构：键值对的集合，类似 Java 中的 HashMap，适合存储对象类数据，每个 Hash 可包含最多 2^32-1 个字段。

应用场景：存储用户信息（如user:100为 key，name“age” 等为字段）、商品属性存储等，能只修改对象的某个字段，节省内存和带宽。

List（列表）：

结构：有序的字符串列表，底层是双向链表，支持从两端插入 &#x2F; 删除元素，按索引访问。

应用场景：消息队列（用LPUSH生产消息、RPOP消费消息）、最新消息展示（如朋友圈点赞列表）、排行榜前 N 条数据等。

Set（集合）：

结构：无序且不重复的字符串集合，支持交集、并集、差集等运算。

应用场景：好友关系（如共同好友用交集SINTER）、标签存储（如用户兴趣标签）、去重操作（如 UV 统计）等。

ZSet（有序集合）：

结构：在 Set 基础上给每个元素关联一个分数（score），按分数排序，元素唯一但分数可重复。

应用场景：排行榜（如游戏积分排名用ZREVRANGE）、带权重的消息队列、范围查询（如查询分数在 80-100 的用户）等。


2.2 缓存问题：穿透、击穿、雪崩及解决方案
面试官： Redis 作为缓存时，常见的缓存穿透、击穿、雪崩问题怎么解决？
我：
这三类问题都是缓存使用中可能遇到的并发或数据一致性问题，具体及解决方案如下：

缓存穿透：

问题：查询不存在的数据（如用户查 id&#x3D;-1 的用户），缓存和数据库都无结果，请求直接打向数据库，大量此类请求会压垮数据库。

解决方案：① 空值缓存，对不存在的 key 缓存空值（设较短过期时间，避免占用内存）；② 布隆过滤器，在缓存前加布隆过滤器，先判断 key 是否存在，不存在直接返回，过滤无效请求；③ 接口层校验，对非法参数（如 id 为负）直接拦截。

缓存击穿：

问题：一个热点 key 突然过期，此时大量并发请求同时访问该 key，缓存未命中，都去查数据库，导致数据库瞬间压力骤增。

解决方案：① 热点 key 永不过期，在业务层不设置过期时间，手动更新；② 互斥锁，缓存未命中时，用分布式锁（如 Redis 的SETNX）保证只有一个线程去查数据库，其他线程等待重试；③ 预热缓存，在高峰前主动加载热点数据到缓存并设合理过期时间。

缓存雪崩：

问题：大量缓存 key 在同一时间过期，或 Redis 集群宕机，导致大量请求穿透到数据库，数据库因压力过大崩溃。

解决方案：① 过期时间随机化，给 key 的过期时间加随机值（如 10±2 秒），避免同时过期；② 多级缓存，用本地缓存（如 Caffeine）+ Redis 缓存，减少 Redis 压力；③ Redis 集群高可用，部署主从 + 哨兵或 Redis Cluster，避免单点故障；④ 限流降级，在数据库前加限流组件（如 Sentinel），超过阈值则降级返回默认数据。


2.3 数据一致性问题与解决方案（Cache-Aside 策略、延迟双删、监听 binlog）
面试官： Redis 和数据库如何保证数据一致性？有哪些常用方案？
我：
缓存与数据库的数据一致性指两者数据保持同步，常用方案需根据业务场景选择：

Cache-Aside 策略（旁路缓存）：

流程：读操作时，先查缓存，命中直接返回；未命中查数据库，再把数据写入缓存。写操作时，先更数据库，再删除缓存（而非更新缓存，避免多次写缓存浪费资源）。

适用场景：大多数普通业务场景，简单易实现，但可能因删除缓存失败导致不一致（可配合重试机制）。

延迟双删：

流程：写操作时，① 先删除缓存；② 再更新数据库；③ 过一段时间（如 500ms）再次删除缓存。

作用：解决 “更新数据库时，其他线程可能已从旧数据库读数据写入缓存” 的问题，第二次删除可清除可能的旧缓存。

适用场景：并发较高，对一致性要求稍高的场景，需合理设置延迟时间（根据业务耗时调整）。

监听 binlog 同步：

流程：借助数据库的 binlog（如 MySQL 的 binlog），通过中间件（如 Canal）监听 binlog 变化，解析后异步更新或删除 Redis 缓存。

优势：解耦业务代码，可靠性高，适合复杂的更新场景。

注意：异步更新有延迟，需接受短暂的不一致，且需保证中间件的高可用。


2.4 高性能原理：I&#x2F;O 多路复用模型（Reactor 模式、epoll）
面试官： Redis 为什么性能高？I&#x2F;O 多路复用模型是怎么回事？
我：
Redis 高性能的原因包括基于内存、单线程（避免线程切换开销）等，其中 I&#x2F;O 多路复用模型是关键：

I&#x2F;O 多路复用：允许单个线程同时监听多个文件描述符（Socket），当某个描述符就绪（如可读、可写）时，通知应用程序处理。Redis 用它解决了单线程下处理多客户端连接的问题，避免了阻塞等待。

Reactor 模式：Redis 的 I&#x2F;O 模型基于 Reactor 模式实现，核心是 “事件驱动”：① 主线程负责监听 Socket，将就绪的事件（如连接、读写）放入事件队列；② 工作线程（Redis 单线程下主线程即工作线程）从队列取事件并处理（如解析命令、执行操作）。

epoll：Redis 在 Linux 下采用 epoll 作为 I&#x2F;O 多路复用的实现（不同系统有差异，如 FreeBSD 用 kqueue），相比 select&#x2F;poll 更高效：① select&#x2F;poll 需轮询所有描述符，epoll 通过回调通知就绪描述符，无轮询开销；② select 支持的描述符数量有限（默认 1024），epoll 无此限制；③ epoll 能精准获取就绪描述符，减少无效操作。


正是 I&#x2F;O 多路复用让 Redis 单线程也能高效处理数万并发连接。
2.5 实战应用：登录机制与防抖节流实现
面试官： Redis 在实战中有哪些典型应用？比如登录和防抖节流怎么用它实现？
我：
Redis 在业务中有很多实用场景，登录机制和防抖节流是常见案例：

登录机制实现：

流程：用户登录成功后，生成唯一 token（如 UUID），以token:xxx为 key，用户信息为 value 存入 Redis（设过期时间，如 2 小时）；客户端后续请求携带 token，服务端查 Redis 验证 token 是否有效，有效则允许访问。

扩展：可结合 Redis 的EXPIRE续期（如用户操作时刷新过期时间），或用DEL实现登出；还能通过SETNX防止同一账号多设备登录（登录时先删旧 token，再存新 token）。

防抖节流实现：

防抖（避免重复触发）：如按钮点击，用 Redis 记录触发时间，规定 “n 秒内再次触发则重置时间”。例：用SET key timestamp NX PX n*1000，若 key 不存在则设置（触发操作），存在则不处理。

节流（控制触发频率）：如接口限流，规定 “n 秒内最多触发 m 次”。例：用INCR key计数，EXPIRE key n设过期时间，若计数≤m 则允许，否则拒绝。


2.6 高可用与持久化：主从同步与 AOF&#x2F;RDB
面试官： Redis 如何保证高可用？持久化机制 AOF 和 RDB 有什么区别？
我：
高可用涉及主从、持久化等，确保 Redis 不丢失数据且持续可用：

主从同步：

作用：实现数据备份和读写分离。主库负责写操作，从库通过复制主库数据实现备份，同时可分担读请求。

流程：① 从库连接主库，发送SYNC命令；② 主库生成 RDB 文件并发送给从库，从库加载 RDB 同步全量数据；③ 之后主库将写命令异步发送给从库，从库执行命令保持增量同步。

高可用：配合哨兵（Sentinel），哨兵监控主从节点，主库故障时自动将从库切换为主库，实现故障转移。

持久化机制：

RDB：在指定时间间隔生成数据集的快照（如save 60 1000表示 60 秒内 1000 次修改则触发），将数据写入二进制文件（dump.rdb）。

优势：文件小，恢复速度快；适合全量备份。

劣势：快照间隔内数据可能丢失（如宕机）；生成快照时可能阻塞主线程（用bgsave可异步，但有资源开销）。

AOF：记录所有写命令（如SET、HSET），追加到日志文件（appendonly.aof），恢复时重新执行命令。

优势：数据安全性高（可设appendfsync always实时写入）；日志可读懂，便于排查问题。

劣势：文件大，恢复慢；写命令追加可能影响性能。

实际选择：通常混合使用 AOF+RDB，RDB 用于快速恢复，AOF 弥补 RDB 的数据丢失风险。


2.7 生产优化：大 Key 与热 Key 处理
面试官： 生产环境中，Redis 的大 Key 和热 Key 怎么处理？
我：
大 Key 和热 Key 会影响 Redis 性能（如大 Key 导致阻塞，热 Key 导致节点过载），需针对性优化：

大 Key 处理：

识别：用redis-cli –bigkeys命令扫描大 Key（如 String&gt;100MB，Hash&#x2F;List 元素过多）。

拆分：① String 大 Key 拆分为多个小 Key（如user:info拆为user:info:name、user:info:age）；② Hash&#x2F;List 大 Key 按范围拆分（如 Hash 按字段首字母拆分，List 按索引分段）。

删除：大 Key 直接DEL会阻塞线程，用UNLINK（异步删除）或逐步删除（如 List 用LPOP分批删）。

热 Key 处理：

识别：通过监控工具（如 Redis Insight）统计访问频率高的 Key，或根据业务判断（如秒杀商品 ID）。

分散存储：① 给热 Key 加前缀 &#x2F; 后缀（如key:1、key:2），分散到不同 Redis 节点；② 用本地缓存（如应用内存）分担部分请求，减少 Redis 访问。

优化缓存：热 Key 设永不过期，或用主从复制（从库分担读请求），避免单节点压力过大。


七、开发框架 (Development Framework)SpringBoot 1. 核心思想：IoC (控制反转) 与 DI (依赖注入)
面试官： 请说说 SpringBoot 的核心思想 IoC 和 DI 分别是什么，它们之间有什么关系？
我：
IoC（Inversion of Control，控制反转）是 Spring 框架的核心思想，它颠覆了传统程序中对象创建和依赖管理的方式：传统方式中，对象由开发者主动通过new关键字创建，依赖关系也由开发者手动维护；而在 IoC 思想下，对象的创建权、生命周期管理以及依赖关系的组装都交给了 Spring 容器，开发者只需定义对象的需求，由容器 “反向” 将所需对象注入，实现了 “控制权从开发者到容器的转移”。
DI（Dependency Injection，依赖注入）是 IoC 的具体实现方式。当一个对象需要依赖另一个对象时，Spring 容器会主动将被依赖的对象 “注入” 到依赖对象中，无需开发者手动设置。比如在 Service 层中需要 Dao 层对象，只需用@Autowired注解标记，Spring 就会自动将 Dao 实例注入到 Service 中。
简单来说，IoC 是设计思想，DI 是实现该思想的手段，二者相辅相成，共同降低了组件间的耦合度，让代码更易维护和扩展。
2. 进阶特性：循环依赖解决机制（三级缓存）
面试官： SpringBoot 是如何解决 Bean 之间的循环依赖问题的？三级缓存在这里起到了什么作用？
我：
循环依赖指的是两个或多个 Bean 之间互相依赖，比如 A 依赖 B，B 又依赖 A。Spring 通过三级缓存机制来解决单例 Bean 的循环依赖问题，核心是提前暴露未初始化完成的 Bean 实例。
三级缓存具体指 Spring 容器中的三个 Map 结构：

一级缓存（singletonObjects）：存储已完全初始化完成的单例 Bean，是最终供外部使用的 Bean 实例。

二级缓存（earlySingletonObjects）：存储提前暴露的、已完成实例化但未完成属性注入和初始化的 Bean 实例（半成品 Bean）。

三级缓存（singletonFactories）：存储 Bean 的工厂对象（ObjectFactory），该工厂可以生成 Bean 的早期代理对象或原始实例。


解决循环依赖的流程以 A 和 B 循环依赖为例：

容器创建 A 时，先实例化 A（完成构造方法调用），然后将 A 的工厂对象放入三级缓存。

A 需要注入 B，容器开始创建 B，同样先实例化 B，将 B 的工厂对象放入三级缓存。

B 需要注入 A，容器先查一级缓存（无 A），再查二级缓存（无 A），最后查三级缓存，通过 A 的工厂对象获取 A 的早期实例，将 A 从三级缓存移到二级缓存，然后将 A 注入到 B 中。

B 完成属性注入和初始化，成为完整 Bean，放入一级缓存，之后将 B 注入到 A 中。

A 完成属性注入和初始化，放入一级缓存，循环依赖解决。


三级缓存的关键作用是应对 Bean 被 AOP 代理的场景：若 Bean 需要生成代理对象，工厂对象会提前生成代理实例并暴露，避免注入原始实例导致的代理失效问题，二级缓存则用于快速获取提前暴露的实例，减少工厂对象的重复执行。不过三级缓存仅能解决单例 Bean 的循环依赖，原型 Bean（prototype）的循环依赖无法解决，会直接抛出异常。
3. 面向切面编程：AOP 实现原理（JDK 动态代理 vs CGLIB）
面试官： SpringBoot 的 AOP 是如何实现的？JDK 动态代理和 CGLIB 代理有什么区别，Spring 会如何选择？
我：
AOP（Aspect-Oriented Programming，面向切面编程）通过将日志、事务、权限控制等通用功能抽取为 “切面”，在不修改业务代码的情况下，通过 “织入” 机制将切面与业务逻辑结合，实现代码复用。Spring AOP 的底层通过动态代理技术实现，主要有 JDK 动态代理和 CGLIB 代理两种方式。
二者的区别主要体现在实现方式和适用场景上：

JDK 动态代理：

基于 Java 反射机制实现，要求被代理的类必须实现接口，代理对象是接口的实现类。

原理是通过Proxy类生成代理实例，代理实例在调用方法时，会回调InvocationHandler中的invoke方法，在该方法中执行切面逻辑和目标方法。

优势：JDK 原生支持，无需依赖第三方库，效率较高（在代理逻辑简单时）。

局限：只能代理实现了接口的类，无法代理无接口的类。

CGLIB 代理：

基于字节码生成技术实现，通过继承被代理类生成子类作为代理对象，无需被代理类实现接口。

原理是通过 ASM 框架修改字节码，在子类中重写父类的方法，在重写方法中嵌入切面逻辑和目标方法调用。

优势：可代理无接口的类，适用范围更广。

局限：若被代理类被final修饰（无法继承），则无法生成代理对象；由于是继承实现，父类的final方法无法被重写，也就无法被增强。


Spring 对代理方式的选择逻辑：

若被代理的类实现了接口，默认使用 JDK 动态代理。

若被代理的类未实现接口，默认使用 CGLIB 代理。

可通过配置spring.aop.proxy-target-class&#x3D;true强制使用 CGLIB 代理（SpringBoot 2.x 后该配置默认值为 true）。


4. 事务管理：@Transactional 注解失效场景分析
面试官： 在 SpringBoot 中使用@Transactional注解时，哪些情况会导致事务失效？
我：
@Transactional注解通过 AOP 实现事务管理，但在一些场景下会因不符合 AOP 代理机制或注解生效条件而失效，常见场景有：

非公共方法上使用注解：@Transactional默认只对公共（public）方法生效，若在 private、protected 或 default 修饰的方法上使用，Spring 不会生成事务代理，注解失效。

自身方法调用（内部调用）：在同一个类中，一个无事务的方法调用另一个有@Transactional注解的方法，由于内部调用不会经过代理对象，事务切面无法生效。例如：


TypeScript取消自动换行复制
public class Service {
​    public void methodA() {
​        methodB(); &#x2F;&#x2F; 内部调用，methodB的事务失效
​    }
​    @Transactional
​    public void methodB() {
​        &#x2F;&#x2F; 业务逻辑
​    }
}

异常被捕获未抛出：事务默认在遇到未捕获的 RuntimeException 或 Error 时回滚，若方法内部捕获了异常且未重新抛出，事务管理器无法感知异常，会认为事务执行成功，导致不回滚。

错误的异常类型：若注解指定了rollbackFor属性（如@Transactional(rollbackFor &#x3D; IOException.class)），但实际抛出的异常不是该类型且未被rollbackFor包含，事务不会回滚；若未指定rollbackFor，checked 异常（如 IOException）默认不会触发回滚。

Bean 未被 Spring 管理：若类未通过@Service、@Component等注解交给 Spring 容器管理，@Transactional注解无法被解析，自然失效。

事务传播机制设置不当：若传播机制设置为PROPAGATION_NOT_SUPPORTED（不支持事务）、PROPAGATION_NEVER（禁止事务）等，会导致当前方法不使用事务；或PROPAGATION_REQUIRES_NEW等在特定场景下因事务嵌套逻辑导致预期外的结果。


5. 设计模式应用（工厂、单例、代理、模板方法等）
面试官： SpringBoot 中应用了哪些常见的设计模式？能举例说明吗？
我：
SpringBoot 基于 Spring 框架，内部大量应用了设计模式，以下是几种典型模式的应用：

工厂模式：Spring 的 Bean 创建过程主要依赖工厂模式。BeanFactory是 Bean 工厂的核心接口，负责创建和管理 Bean；DefaultListableBeanFactory等实现类通过读取配置（如注解、XML），根据 Bean 的定义信息生成 Bean 实例，开发者无需关心 Bean 的创建细节，只需通过工厂获取。

单例模式：Spring 容器中的 Bean 默认是单例的（scope 为 singleton），通过一级缓存（singletonObjects）保证一个 Bean 在容器中只有一个实例。容器启动时创建 Bean 并缓存，后续多次获取的都是同一个实例，减少了对象创建的开销。

代理模式：如 AOP 的实现中，JDK 动态代理和 CGLIB 代理都是代理模式的应用。代理对象在目标对象的方法前后嵌入切面逻辑（如事务、日志），既扩展了功能，又不修改目标对象的代码，符合 “开闭原则”。

模板方法模式：在数据访问层（如 JdbcTemplate、RedisTemplate）中大量使用。模板类定义了操作的整体流程（如数据库连接、执行 SQL、关闭连接），将可变的步骤（如 SQL 语句、结果集处理）抽象为抽象方法或通过回调接口让用户实现，避免了重复代码，同时保证流程的一致性。

观察者模式：Spring 的事件驱动模型基于观察者模式。ApplicationEvent是事件源，ApplicationListener是观察者，当事件发布（如ContextRefreshedEvent表示容器刷新完成）时，所有监听该事件的 Listener 会被触发执行，常用于业务解耦（如订单创建后发送通知）。


这些设计模式的应用让 SpringBoot 的架构更灵活、可扩展，也是其能快速集成各类组件的重要原因。
]]></content>
      <categories>
        <category>Java</category>
        <category>为了实习说是</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>为了实习说是</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试3</title>
    <url>/2025/10/21/Java%E9%9D%A2%E8%AF%953/</url>
    <content><![CDATA[Java面试31. MyBatis 的作用标准答案：MyBatis 是一个优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。它的主要作用是简化 JDBC 的开发，解决原生 JDBC 代码的繁琐和重复工作问题。
核心作用包括：

解耦 SQL 与程序代码：将 SQL 语句从 Java 代码中剥离出来，配置在 XML 文件或注解中，使得代码更清晰、更易于维护。
自动完成 ORM（对象关系映射）：执行 SQL 后，MyBatis 可以自动将查询结果集封装成 Java 对象（POJO），或将 Java 对象参数自动映射到 SQL 中。
提供强大的动态 SQL 功能：可以通过 XML 标签（如 &lt;if&gt;, &lt;foreach&gt;, &lt;where&gt;）灵活地拼接复杂的 SQL 语句，避免了在 Java 代码中拼接字符串的麻烦和潜在的安全风险（如 SQL 注入）。
简化数据库连接和事务管理：可以与 Spring 等框架无缝集成，由这些框架来管理数据源和事务。

你回答的分析：你可能只回答了“持久层框架”，但没有展开说明它具体解决了什么问题和带来了什么好处。面试官想听到的是你对框架价值的理解。

2. 表之间怎么连接查询标准答案：表之间的连接查询主要通过 SQL 的 JOIN 关键字来实现，而不是通过外键。外键是一种数据库层面的约束，用于保证数据的参照完整性，它定义了表之间的关系，但不直接用于查询。
常见的连接查询有：

内连接（INNER JOIN）：返回两个表中连接字段匹配的记录。
sql
SELECT * FROM 订单表 o INNER JOIN 用户表 u ON o.user_id = u.id;



左外连接（LEFT JOIN）：返回左表的所有记录，以及右表中连接字段匹配的记录。如果右表没有匹配，则返回 NULL。
sql
SELECT * FROM 用户表 u LEFT JOIN 订单表 o ON u.id = o.user_id;



右外连接（RIGHT JOIN）：与左连接相反，返回右表的所有记录和左表中匹配的记录。

全外连接（FULL JOIN）：返回左右两表的所有记录。


你回答的分析：你回答“外键”是不准确的。这是一个常见的概念混淆。面试官听到这个回答，可能会认为你不太熟悉 SQL 查询本身。一定要明确：外键是约束，JOIN 是查询操作。

3. SQL 的函数怎么执行标准答案：SQL 函数是在数据库服务器端执行的。我们在 SQL 语句中直接调用函数，数据库引擎会负责解析和执行这些函数。
具体方式：

在 SQL 语句中直接调用：将函数作为 SQL 的一部分写入。

日期函数：SELECT NOW(); – 获取数据库当前时间
聚合函数：SELECT COUNT(*) FROM table_name;
字符串函数：SELECT CONCAT(first_name, &#39; &#39;, last_name) AS full_name FROM users;


在 MyBatis 中，我们就是在 XML 映射文件或注解的 SQL 里直接使用这些函数。
xml
&lt;select id=&quot;getCurrentTime&quot; resultType=&quot;string&quot;&gt;    SELECT NOW()&lt;/select&gt;

你回答的分析：你的回答“在方法中对写入参数赋值然后再执行sql”描述的是设置普通参数的过程，并没有涉及到 SQL 函数。面试官提示的“实时时间”（NOW()）就是一个典型的在数据库端执行的函数。你需要区分清楚：简单参数由应用程序传入，而函数由数据库计算。

4. 模糊查询怎么实现的标准答案：模糊查询是使用 SQL 的 LIKE 关键字配合通配符 %（代表任意多个字符）和 _（代表一个字符）来实现的。
具体实现（以 MyBatis 为例）：查询值应该作为参数传递给 SQL 语句，并在参数值的两端加上 %。

方式一：在 Java 代码中拼接好 %（不推荐，易引发 SQL 注入）
java
String name = &quot;%&quot; + userInput + &quot;%&quot;;



方式二：在 MyBatis XML 中使用 #&#123;&#125; 并拼接 %（推荐）
xml
&lt;select id=&quot;findUserByName&quot; resultType=&quot;User&quot;&gt;    SELECT * FROM users WHERE name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&lt;/select&gt;



方式三：在 MyBatis XML 中使用 bind 标签（推荐）
xml
&lt;select id=&quot;findUserByName&quot; resultType=&quot;User&quot;&gt;    &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + name + &#x27;%&#x27;&quot; /&gt;    SELECT * FROM users WHERE name LIKE #&#123;pattern&#125;&lt;/select&gt;

你回答的分析：你只答出了“%连接”，这是正确的，但不够完整。面试官追问“具体怎么实现，查询值要在哪”是在考察你如何在 MyBatis 框架中安全、正确地传递这个带 % 的参数。你需要说明参数来自哪里，以及如何组织。

5. 分页查询怎么实现的标准答案：分页查询的实现主要有两种方式：

数据库原生分页（推荐，效率高）：编写带有分页关键字的 SQL 语句。

MySQL：使用 LIMIT
sql
SELECT * FROM table_name LIMIT #&#123;offset&#125;, #&#123;pageSize&#125;



（offset = (pageNum - 1) * pageSize）

Oracle：使用 ROWNUM 或 ROW_NUMBER()

PostgreSQL：使用 LIMIT OFFSET



使用分页插件（最方便）：在 MyBatis 中，可以使用像 PageHelper 这样的第三方分页插件。你只需要在查询方法前设置分页参数，插件会自动拦截下一个查询语句，并为其加上数据库对应的分页语句。
java
// 使用 PageHelperPageHelper.startPage(1, 10); // 查询第1页，每页10条List&lt;User&gt; userList = userMapper.selectAll();// userList 就是一个分页后的列表，PageHelper 还会提供一个 PageInfo 对象包含总记录数等分页信息

你回答的分析：这个问题很常见。如果你只回答了逻辑分页（在内存中分页），或者说不清楚 LIMIT 关键字，就会暴露经验不足。一定要掌握一种数据库的原生分页写法，并了解主流的分页插件。

6. Bean 的生命周期标准答案（以 Spring Bean 为例）：Bean 的生命周期指的是一个 Bean 从创建到销毁的整个过程。主要阶段如下：

实例化：Spring 容器通过反射调用构造函数创建 Bean 的实例。
属性赋值（依赖注入）：容器将 Bean 的依赖项（其他 Bean 或配置值）注入到 Bean 的属性中。
BeanPostProcessor 的前置处理：调用 postProcessBeforeInitialization 方法。
初始化：
如果 Bean 实现了 InitializingBean 接口，则调用其 afterPropertiesSet() 方法。
如果 Bean 配置了 init-method 方法，则调用此自定义的初始化方法。


BeanPostProcessor 的后置处理：调用 postProcessAfterInitialization 方法（AOP 代理通常在此处生成）。
使用中：此时 Bean 已准备就绪，可以被应用程序使用。
销毁：
当容器关闭时，如果 Bean 实现了 DisposableBean 接口，则调用其 destroy() 方法。
如果 Bean 配置了 destroy-method 方法，则调用此自定义的销毁方法。



你回答的分析：这是一个考察 Spring 框架理解深度的经典问题。如果你只能说出一两个阶段（如“创建、初始化、销毁”），就显得比较肤浅。如果能流利地说出上述 5-7 个核心阶段，并提及 BeanPostProcessor 这样的扩展点，会给面试官留下很好的印象。
总结与建议
概念清晰：区分开“外键”（约束）和“连接查询”（操作）这类易混淆的概念。
理解原理：不要只记名词，要理解背后的原理。比如 SQL 函数在哪执行，关系到应用程序和数据库的职责划分。
框架熟练度：对于 MyBatis&#x2F;Spring 这类必问框架，不仅要会用，还要了解其核心机制和最佳实践（如分页、动态SQL、生命周期）。
多动手：把这些问题的答案自己写代码验证一遍，印象会更深刻。

这次面试虽然挂了，但暴露出的问题非常典型，正好为你指明了下一步学习的方向。加油！
]]></content>
      <categories>
        <category>Java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SwitchHosts下载安装使用</title>
    <url>/2025/08/11/SwitchHosts%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[SwitchHosts下载安装使用github直接搜然后下载

然后直接修改

注意，要关代理并且重启浏览器！！！
]]></content>
      <categories>
        <category>Java</category>
        <category>util</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/09/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[算法刷题心得体会与经典刷题226. 翻转二叉树简单
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
示例 1：

输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]

示例 2：

输入：root = [2,1,3]输出：[2,3,1]

示例 3：
输入：root = []输出：[]





题解：
递归深度优先搜索（DFS）
public TreeNode invertTree(TreeNode root) &#123;    if (root == null) return null;        TreeNode left = invertTree(root.left);    TreeNode right = invertTree(root.right);        root.left = right;    root.right = left;        return root;&#125;

迭代（BFS）- 使用队列
public TreeNode invertTree(TreeNode root) &#123;    if (root == null) return null;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);        while (!queue.isEmpty()) &#123;        TreeNode node = queue.poll();                // 交换左右子节点        TreeNode temp = node.left;        node.left = node.right;        node.right = temp;                if (node.left != null) queue.offer(node.left);        if (node.right != null) queue.offer(node.right);    &#125;        return root;&#125;

迭代（DFS）- 使用栈
public TreeNode invertTree(TreeNode root) &#123;    if (root == null) return null;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    stack.push(root);        while (!stack.isEmpty()) &#123;        TreeNode node = stack.pop();                // 交换左右子节点        TreeNode temp = node.left;        node.left = node.right;        node.right = temp;                if (node.left != null) stack.push(node.left);        if (node.right != null) stack.push(node.right);    &#125;        return root;&#125;





221. 最大正方形在一个由 &#39;0&#39; 和 &#39;1&#39; 组成的二维矩阵内，找到只包含 &#39;1&#39; 的最大正方形，并返回其面积。
示例 1：

输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：4

示例 2：

输入：matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]输出：1

示例 3：
输入：matrix = [[&quot;0&quot;]]输出：0



动态规划
题解：
public int maximalSquare(char[][] matrix) &#123;    if (matrix == null || matrix.length == 0) return 0;        int rows = matrix.length, cols = matrix[0].length;    int maxSide = 0;        // dp[i][j] 表示以(i,j)为右下角的最大正方形边长    int[][] dp = new int[rows][cols];        for (int i = 0; i &lt; rows; i++) &#123;        for (int j = 0; j &lt; cols; j++) &#123;            if (matrix[i][j] == &#x27;1&#x27;) &#123;                if (i == 0 || j == 0) &#123;                    // 第一行或第一列，最大边长只能是1                    dp[i][j] = 1;                &#125; else &#123;                    // 关键公式：取左、上、左上三个方向的最小值 + 1                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;                &#125;                maxSide = Math.max(maxSide, dp[i][j]);            &#125;        &#125;    &#125;        return maxSide * maxSide;&#125;

爆破：
public int maximalSquare(char[][] matrix) &#123;    if (matrix == null || matrix.length == 0) return 0;        int maxSide = 0;    int rows = matrix.length, cols = matrix[0].length;        for (int i = 0; i &lt; rows; i++) &#123;        for (int j = 0; j &lt; cols; j++) &#123;            if (matrix[i][j] == &#x27;1&#x27;) &#123;                maxSide = Math.max(maxSide, 1); // 至少是1x1的正方形                                // 尝试扩展正方形                int currentMaxSide = Math.min(rows - i, cols - j);                for (int k = 1; k &lt; currentMaxSide; k++) &#123;                    if (isSquare(matrix, i, j, k)) &#123;                        maxSide = Math.max(maxSide, k + 1);                    &#125; else &#123;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;        return maxSide * maxSide; // 返回面积&#125;// 检查从(i,j)开始，边长为side+1的正方形是否全是&#x27;1&#x27;private boolean isSquare(char[][] matrix, int i, int j, int side) &#123;    // 检查新增的行和列    for (int k = 0; k &lt;= side; k++) &#123;        if (matrix[i + side][j + k] != &#x27;1&#x27;) return false;        if (matrix[i + k][j + side] != &#x27;1&#x27;) return false;    &#125;    return true;&#125;



215. 数组中的第K个最大元素给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1:
输入: [3,2,1,5,6,4], k = 2输出: 5

示例 2:
输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4



题解：
选择排序，但是这个超时了：
class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;        for(int i = 0;i &lt; k;i++)&#123;            int maxIndex = i;            // 找到[i+1...R]上最大元素的索引            for(int j = i+1;j &lt; nums.length;j++)                if(nums[j] &gt; nums[maxIndex])                    maxIndex = j;            // 将该元素放到i位置            if(maxIndex != i)&#123;                int temp = nums[i];                nums[i] = nums[maxIndex];                nums[maxIndex] = temp;            &#125;        &#125;        return nums[k-1];    &#125;&#125;

调库：
import java.util.Arrays;class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;        if (nums == null || nums.length == 0) &#123;            return 0;        &#125;                // 对数组进行排序（升序）        Arrays.sort(nums);                // 第k大的元素在排序后的位置是 nums.length - k        return nums[nums.length - k];    &#125;&#125;

]]></content>
  </entry>
  <entry>
    <title>为了实习说是</title>
    <url>/2025/09/16/%E4%B8%BA%E4%BA%86%E5%AE%9E%E4%B9%A0%E8%AF%B4%E6%98%AF/</url>
    <content><![CDATA[为了实习说是MySQL1. 事务（Transaction）名词与定义
事务：数据库操作的最小工作单元，一个事务内的所有操作作为一个整体，要么全部成功，要么全部失败。
ACID 特性：
原子性 (Atomicity)：事务是一个不可分割的整体，要么全部提交，要么全部回滚。
一致性 (Consistency)：事务执行前后，数据库必须从一个一致性状态变换到另一个一致性状态（数据完整性约束不被破坏）。
隔离性 (Isolation)：并发事务之间相互隔离，一个事务的执行不应影响其他事务。
持久性 (Durability)：事务一旦提交，其对数据的修改就是永久性的，即使系统故障也不会丢失。



面试深入追问与解答Q：ACID特性分别靠什么保证？

A (原子性) 和 D (持久性)：主要靠 Redo Log 和 Undo Log。
Undo Log：用于回滚和MVCC。事务修改数据前，会先记录修改前的数据到Undo Log。如果事务需要回滚，就可以利用Undo Log将数据恢复到之前的状态。保证了原子性。
Redo Log：用于崩溃恢复。事务提交时，会先写Redo Log（顺序写，速度快），记录数据页的物理修改。即使修改的数据页还没有刷盘，MySQL宕机重启后也能根据Redo Log重做，将数据恢复到提交状态。保证了持久性。


I (隔离性)：靠 锁机制 和 MVCC 来保证。
C (一致性)：是最终目标，由原子性、隔离性、持久性共同来保证。

Q：谈谈四大隔离级别及其解决的问题？

读未提交 (Read Uncommitted)：一个事务能读到另一个事务未提交的修改。问题：脏读。
读已提交 (Read Committed, RC)：一个事务只能读到另一个事务已提交的修改。解决：脏读。问题：不可重复读（同一事务内两次相同的查询可能得到不同结果）。
可重复读 (Repeatable Read, RR)：MySQL的默认级别。一个事务内多次读取同一数据，结果是一致的。解决：脏读、不可重复读。问题：幻读（同一事务内两次范围查询，结果集数量不一致）。
串行化 (Serializable)：最高隔离级别，所有事务串行执行。解决：所有并发问题。问题：性能极低。

Q：MySQL的RR级别真的解决了幻读吗？

答案：部分解决，但并非完全免疫。
如何解决：
快照读（普通SELECT ...）：通过MVCC解决。事务首次读时会建立一致性视图（ReadView），后续读都基于这个视图，看不到其他事务新提交的数据，因此不会幻读。
当前读（SELECT ... FOR UPDATE, UPDATE, DELETE）：通过**Next-Key Lock（临键锁）**解决。当前读不仅会锁住扫描到的索引记录，还会锁住这些记录之间的“间隙”（Gap），防止其他事务在间隙中插入新数据，从而避免了幻读。


未完全解决的情况：如果一个事务先进行快照读，然后自己又执行了当前写操作（如UPDATE），这个写操作是能“看到”其他事务最新提交的数据的，可能会破坏该事务自身的一致性视图，产生一种特殊的幻读。


2. 锁（Locking）名词与定义
共享锁 (S Lock)：又称读锁。事务读数据时加共享锁，允许其他事务读，但不允许写。
排他锁 (X Lock)：又称写锁。事务写数据时加排他锁，不允许其他事务读和写。
行锁：锁住一行数据。InnoDB支持。
表锁：锁住整张表。MyISAM引擎的主要锁机制。
意向锁：表级锁。IS（意向共享锁）和IX（意向排他锁）。用于快速判断表中是否有行被上锁，避免逐行检查。

面试深入追问与解答Q：InnoDB的行锁是怎么实现的？

答案：InnoDB的行锁是基于索引实现的！
原理：如果一条SQL语句走索引，它只会锁住满足条件的索引项和对应的数据行。
致命追问：如果查询条件没有用到索引呢？
答：会升级为表锁！因为引擎无法通过索引快速定位到行，为了安全，它会直接锁住整个表。这就是为什么必须优化SQL、建立索引的重要原因之一。



Q：什么是间隙锁（Gap Lock）和临键锁（Next-Key Lock）？

间隙锁 (Gap Lock)：锁住索引记录之间的间隙，防止其他事务在这个间隙中插入新数据。例如，id值有 1, 5, 10，那么间隙锁可以锁住 (1,5), (5,10), (10, +∞) 这些区间。
临键锁 (Next-Key Lock)：行锁 + 间隙锁。它锁住一个索引记录和它之前的间隙。例如，临键锁可能锁住 (1,5] 这个左开右闭的区间。它是RR隔离级别下防止幻读的关键机制。

Q：什么是死锁？如何排查和避免？

定义：两个或多个事务相互等待对方释放锁，导致它们都无法继续执行。
MySQL如何处理：InnoDB有死锁检测机制，一旦检测到死锁，会立即回滚其中一个成本最小的事务，让另一个事务得以继续。
如何排查：使用命令 SHOW ENGINE INNODB STATUS;，查看 LATEST DETECTED DEADLOCK 部分，分析死锁日志。
如何避免：
保持事务短小，尽快提交。
多个事务以相同的顺序访问资源（例如，总是先更新表A再更新表B）。
为高频操作建立合适的索引，减少锁的竞争范围。




3. 索引（Indexing）名词与定义
索引：一种帮助MySQL高效获取数据的排好序的数据结构。
B+Tree：MySQL InnoDB引擎索引的默认数据结构。相比B-Tree，所有数据都存储在叶子节点，且叶子节点间有指针相连，更适合范围查询和排序。
聚簇索引 (Clustered Index)：表数据本身按主键顺序存储在B+Tree的叶子节点中。一张表只有一个聚簇索引。
非聚簇索引 (Secondary Index)：又称辅助索引。其叶子节点存储的是主键值，而不是行数据本身。查询时需要回表。

面试深入追问与解答Q：为什么推荐使用自增主键？

性能：自增主键是顺序写入的，能很好地填充B+Tree的页，减少页分裂和碎片。
空间：主键长度越小，非聚簇索引的叶子节点存储的主键值也就越小，占用的空间就越小。

Q：什么是“回表”和“覆盖索引”？

回表：通过非聚簇索引查询时，先在索引树中找到主键值，再根据主键值回到聚簇索引树中查找完整行数据的过程。
覆盖索引：如果索引字段已经包含了要查询的所有字段（例如，在(name, age)索引上查SELECT name, age FROM user），则引擎可以直接在索引页中拿到数据，避免回表，极大提升性能。

Q：什么情况下索引会失效？

对索引列进行计算、函数或类型转换：WHERE YEAR(create_time) = 2023，WHERE amount * 2 &gt; 100。
Like以通配符开头：WHERE name LIKE &#39;%三丰&#39;。
违反最左前缀原则：对于联合索引(a, b, c)，查询条件没有a，如WHERE b = 1 AND c = 2。
使用OR连接：如果OR前后的条件并非都有索引，索引会失效。
索引列使用 != 或 NOT IN：可能（不是一定）导致失效。


4. MVCC (多版本并发控制)名词与定义
MVCC：通过保存数据在某个时间点的快照来实现并发控制。读操作不会阻塞写操作，写操作也不会阻塞读操作。
ReadView：事务在执行快照读时产生的一致性读视图。它决定了当前事务能看到哪个版本的数据。
Undo Log链：一行数据可能有多个版本（由DB_ROLL_PTR回滚指针串联），每个版本保存在Undo Log中。

面试深入追问与解答Q：MVCC在RC和RR隔离级别下是如何工作的？

核心：在于ReadView的生成时机不同。
Read Committed (RC)：每次执行快照读时都会生成一个新的ReadView。因此，它能读到其他事务最新已提交的数据。
Repeatable Read (RR)：只在第一次执行快照读时生成一个ReadView，后续所有读操作都复用这个视图。因此，它看不到其他事务之后提交的数据，实现了可重复读。

Q：MVCC能解决幻读吗？

对于快照读：能。因为RR级别下ReadView不变，即使其他事务插入了新数据，当前事务也看不到，因此不会发生幻读。
对于当前读：不能。当前读读取的是最新数据，需要靠Next-Key Lock来防止幻读。


5. EXPLAIN 执行计划与SQL优化核心： EXPLAIN 是你的SQL性能诊断器，你必须能看懂它的输出。
关键字段解读：
type：访问类型，从好到坏：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。
至少要优化到range级别，最好达到ref。
index：全索引扫描。
ALL：全表扫描，必须优化。


key：实际使用的索引。如果为NULL，说明没用到索引。
rows：预估需要扫描的行数。值越小越好。
Extra：额外信息，非常重要！
Using filesort：MySQL无法利用索引完成排序，需要额外的排序操作。需要优化。
Using temporary：使用了临时表来处理查询（常见于GROUP BY、ORDER BY）。必须优化。
Using index：使用了覆盖索引，性能极佳。



优化实战思路：
用EXPLAIN分析：找到性能瓶颈（全表扫描？文件排序？）。
检查索引：
查询条件列是否有索引？
是否违反了最左前缀原则？
是否可以考虑使用覆盖索引？


优化SQL写法：
避免使用SELECT *，只取需要的字段。
将复杂的查询拆分成多个简单查询（MySQL对简单查询支持更好）。
优化JOIN，确保ON条件的列有索引。


** redesign 表结构**：如果必要，考虑分表。

redis1. Redis 线程模型 (核心中的核心)名词与定义
文件事件处理器：Redis基于Reactor模式开发的网络事件处理器。它是一个单线程的、高性能的事件循环，负责处理所有客户端连接、命令请求和响应。
I&#x2F;O多路复用：文件事件处理器的核心。通过epoll、kqueue、select等系统调用，一个线程可以监听和管理成千上万个网络连接 socket 的就绪状态（可读、可写）。

面试深入追问与解答Q：为什么Redis选择单线程模型？还能这么快？

答案：快的原因并非因为单线程，而是因为：
纯内存操作：数据在内存中，读写速度极快。
I&#x2F;O多路复用：单线程可以高效处理大量并发连接，避免了多线程的上下文切换和锁竞争开销。
高效的数据结构：如跳跃表、哈希表等，为不同场景做了优化。


为什么用单线程？：避免了多线程的上下文切换和竞争锁的损耗，使得模型非常简单、可预测，不存在并发读写带来的数据一致性问题。

Q：Redis 6.0之后的多线程是怎么回事？

答案：Redis 6.0引入的多线程仅限于网络I&#x2F;O和处理协议解析，命令的执行依然是单线程的。
工作原理：
主线程（单线程）通过I&#x2F;O多路复用接收所有连接，并将就绪的Socket放入一个队列。
一组I&#x2F;O线程（可配置数量）并行地从队列中获取Socket，进行读写网络数据和解析命令（read()和parse）。
主线程串行地执行所有解析好的命令。
主线程将命令结果写入缓冲区。
I&#x2F;O线程再次并行地将缓冲区中的结果写回网络（send()）发送给客户端。


结论：多线程I&#x2F;O只是为了缓解网络读写这个瓶颈，核心的命令处理逻辑仍然是单线程的，所以不存在线程安全问题。


2. 核心数据结构与使用场景面试官不会只问你5种基本类型，会问底层和场景。
| 数据类型 | 底层实现（可能不止一种） | 典型使用场景 || ：— | ：— | :— || String | SDS (Simple Dynamic String) | 缓存、计数器、分布式锁 (SETNX)、Session || List | 压缩列表 (ziplist) &#x2F; 双向链表 (linkedlist) | 消息队列（LPUSH+BRPOP）、最新列表、排行榜 || Hash | 压缩列表 (ziplist) &#x2F; 哈希表 (hashtable) | 缓存对象（用户信息、商品信息）、存储结构化数据 || Set | 整数集合 (intset) &#x2F; 哈希表 (hashtable) | 共同关注（交集）、抽奖（随机元素）、标签系统 || ZSet | 压缩列表 (ziplist) &#x2F; 跳跃表 (skiplist) + 哈希表 | 排行榜、带权重的消息队列、延迟任务 || HyperLogLog | - | 大数据量的基数统计（UV统计），有误差 || Bitmap | - | 二值状态统计（签到打卡、用户是否在线） || GEO | 基于ZSet实现 | 地理位置信息、附近的人 |
追问：ZSet为什么用跳跃表而不用红黑树？

范围查询效率：跳跃表在范围查询（ZRANGE）上效率极高，只需遍历最底层的链表。而红黑树进行中序遍历相对复杂。
实现和维护简单：跳跃表的实现和调试比红黑树简单得多。
并发友好：虽然Redis是单线程用不到，但跳跃表在并发环境下更容易扩展。


3. 缓存问题解决方案 (必考)缓存雪崩
问题：大量缓存数据在同一时间过期或Redis实例宕机，导致所有请求瞬间打到数据库，造成数据库压力过大甚至宕机。
解决方案：
过期时间随机：给缓存数据的TTL加上一个随机值，避免同时过期。
集群高可用：搭建Redis集群（哨兵或Cluster模式），实现故障自动转移，避免整体宕机。
服务降级与熔断：使用Hystrix或Sentinel，当数据库压力过大时，对非核心业务进行降级，甚至直接返回预定义信息（熔断）。
缓存永不过期：后台定时任务主动更新缓存。



缓存穿透
问题：查询一个数据库中肯定不存在的数据（如id为负数的商品）。导致每次请求都无法命中缓存，直接穿透到数据库。
解决方案：
缓存空对象：即使从数据库没查到，也将这个null或空值缓存起来，并设置一个较短的过期时间。缺点：可能缓存大量无用的key。
布隆过滤器 (Bloom Filter)：最优解。将所有可能存在的key哈希到一个巨大的bitmap中。请求来时，先经过布隆过滤器：
如果判断不存在，则直接返回。
如果判断存在，则继续后续的缓存、数据库流程。
优点：空间效率极高。
缺点：有误判率（可能存在判断为存在，但实际不存在，但这个问题影响不大），且数据删除困难。





缓存击穿
问题：一个热点key在过期瞬间，大量并发请求这个key，全部穿透到数据库，像一个“子弹”击穿了缓存。
解决方案：
互斥锁 (Mutex Lock)：第一个请求发现缓存失效后，去查询数据库前，先使用SETNX或Redisson等工具获取一个分布式锁。其他请求获取锁失败则等待或返回默认值，待第一个请求重建缓存后，后续请求再从缓存读取。
逻辑过期&#x2F;永不过期：缓存值不设置TTL，而是在value中封装一个逻辑过期时间。业务线程发现逻辑时间过期后，获取互斥锁，然后启动一个新线程去异步更新缓存，自己先返回旧的缓存数据。



双写一致性
问题：如何保证缓存中的数据与数据库中的数据一致？
解决方案：没有银弹，根据业务对一致性的要求选择策略。
最终一致性（常用）：
先更新数据库，再删除缓存：这是最推荐的模式。即使第二步删除缓存失败，也只会造成一次旧数据脏读，下次读取时就会更新。可以通过消息队列重试机制来保证删除成功。
延迟双删：先删缓存 -&gt; 再更新数据库 -&gt; 延迟几百毫秒再删一次缓存。目的是为了清除在“更新数据库”期间其他请求可能写入的旧缓存。


强一致性：几乎无法实现，且性能代价极大。可以通过Redisson的读写锁或Canel监听数据库binlog来异步淘汰缓存，但延迟不可避免。




4. 持久化策略| | RDB (Redis Database) | AOF (Append Only File) || ：— | :— | :— || 原理 | 定时fork子进程，生成内存快照 | 记录每一次写操作命令到日志文件 || 优点 | 文件小，恢复速度快，适合冷备 | 数据安全性高，最多丢失1秒数据 || 缺点 | 可能丢失上次快照后的数据 | 文件大，恢复速度慢，写入性能有影响 || 配置 | save 900 1 (900秒内1次修改则触发) | appendfsync always/everysec/no || 最佳实践 | 混合持久化 (AOF + RDB)：aof-use-rdb-preamble yes。重写后的AOF文件前半部分是RDB格式的快照，后半部分是增量的AOF日志。兼顾了速度和数据安全性。 |

5. 分布式锁 &amp; 分片集群Q：如何用Redis实现一个可靠的分布式锁？

加锁：SET lock_key random_value NX PX 30000

NX：仅当key不存在时才能设置成功。
PX：设置过期时间，防止客户端宕机导致锁无法释放。
random_value（唯一值）：防止误删。只能由加锁的客户端来解锁。


解锁：使用Lua脚本保证原子性。
lua
if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then    return redis.call(&quot;del&quot;, KEYS[1])else    return 0end

追问：RedLock算法了解吗？用于在多个独立的Redis主节点上实现更高可靠的分布式锁。流程是向超过半数的节点申请锁，全部成功才算加锁成功。争议较大，一般不推荐使用，优先考虑使用ZooKeeper或etcd实现分布式锁。
Q：你搭建的Redis分片集群（Cluster）是如何工作的？

数据分片：采用哈希槽（Slot），共16384个槽。每个节点负责一部分槽。key通过CRC16(key) % 16384计算属于哪个槽。
请求路由：
客户端直连任意节点，如果key不在该节点，节点返回MOVED错误和正确节点地址，客户端重定向访问。
使用智能客户端（如Lettuce）或代理中间件（如Codis）可以缓存槽位映射，直接路由到正确节点。


扩容与重新分片：
使用redis-cli --cluster add-node添加新节点。
使用redis-cli --cluster reshard命令，将一部分哈希槽从现有节点在线迁移到新节点。迁移过程中，客户端请求无需停机。



Q：集群的高可用如何保证？Redis Cluster本身通过主从复制实现高可用。每个主节点都有1个或多个从节点。当主节点宕机，其从节点会通过选举晋升为新的主节点，继续提供服务。
并发编程1. Java 内存模型 (JMM) - 理论基础这是理解所有并发问题的基石。

核心问题：在多线程环境下，线程之间如何“看到”共享变量的值？为什么有时线程A修改了变量，线程B却看不到？
JMM定义：JMM是一种规范，规定了线程如何与主内存（共享内存）和工作内存（线程私有，可类比CPU缓存）交互，以及何时将工作内存中的值刷新到主内存。
三大特性：
原子性：基本数据类型的访问读写是原子性的（long和double非原子性，但商用虚拟机都实现了原子性）。synchronized和Lock可以保证更大范围的原子性。
可见性：一个线程修改了共享变量，其他线程能立即看到修改后的值。
有序性：程序执行的顺序不一定就是代码编写的顺序。为了提高性能，编译器和处理器会做指令重排序。单线程下没问题，但多线程下可能导致诡异问题。



面试追问：什么是happens-before原则？它是JMM中定义的两个操作之间的偏序关系，用来判断数据是否存在竞争、线程是否安全。如果操作A happens-before 操作B，那么A的结果对B可见。常见的happens-before规则包括：

程序次序规则：一个线程内，前面的操作happens-before于后面的操作。
监视器锁规则：对一个锁的解锁happens-before于随后对这个锁的加锁。
volatile变量规则：对一个volatile域的写happens-before于任意后续对这个volatile域的读。
传递性：如果A hb B, B hb C，那么A hb C。


2. synchronized 关键字原理
作用：提供了一种独占的加锁方式，保证了原子性、可见性和有序性。
实现：JVM基于Monitor（管程） 实现。每个Java对象都可以关联一个Monitor。
代码同步块编译后，会生成monitorenter和monitorexit指令。
同步方法会被标记ACC_SYNCHRONIZED访问标志。



锁升级过程 (非常重要！)为了提高性能，synchronized的锁状态会随着竞争情况升级，方向不可逆：

无锁 (New)：新创建的对象。
偏向锁 (Biased Locking)：适用于只有一个线程访问同步块。线程第一次获得锁时，会在对象头和栈帧中记录偏向的线程ID。以后该线程进入和退出同步块时，不需要进行CAS加锁和解锁，性能极高。
轻量级锁 (Lightweight Lock)：适用于线程交替执行，竞争不激烈。当有另一个线程来竞争锁时，偏向锁会升级为轻量级锁。该线程会在自己的栈帧中创建锁记录（Lock Record），通过CAS操作尝试将对象头的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示有其他线程竞争，会自旋尝试获取锁。
重量级锁 (Heavyweight Lock)：适用于竞争激烈。如果自旋失败（或自旋超过一定次数），锁会升级为重量级锁。此时，其他尝试获取锁的线程都会进入阻塞状态（BLOCKED），等待操作系统的调度，需要进行用户态到内核态的切换，开销巨大。

面试追问：为什么引入锁升级？为了避免在无竞争或低竞争情况下，直接使用重量级锁带来的性能开销（用户态到内核态的切换）。通过偏向锁和轻量级锁这两种乐观策略来优化性能。

3. ReentrantLock (可重入锁)与synchronized对比| 特性 | synchronized (隐式锁) | ReentrantLock (显式锁) || ：— | :— | :— || 实现 | JVM层面，关键字 | JDK层面，API || 锁获取 | 自动加锁与释放 | 必须手动lock()和unlock()，通常在finally中释放 || 灵活性 | 较差 | 很强，可尝试非阻塞获取(tryLock)、可中断(lockInterruptibly)、超时获取 || 公平性 | 非公平 | 可选公平或非公平（构造方法传入true） || ** Condition ** | 只能有一个等待队列 | 可以绑定多个Condition，实现更精细的线程等待&#x2F;唤醒 |
核心原理：AQS (AbstractQueuedSynchronizer)这是JUC并发包的灵魂，必须理解。

是什么：一个用于构建锁和同步器的框架。ReentrantLock、Semaphore、CountDownLatch等都是基于AQS构建的。
核心思想：
它维护了一个volatile int state（代表共享资源状态）和一个FIFO线程等待队列（CLH变体）。
state：对于ReentrantLock，state=0表示锁空闲，state&gt;0表示锁被占用，且数值表示重入次数。
等待队列：获取资源失败的线程会被封装成Node节点入队。


工作流程 (以非公平锁为例)：
线程A调用lock()，尝试用CAS将state从0改为1，成功则获取锁，并设置独占线程为A。
线程B也来尝试CAS，失败。则调用AQS的acquire方法。
acquire会再次尝试获取（tryAcquire），失败后，将线程B包装成Node节点，CAS地加入等待队列尾部，然后线程B会** park（阻塞）**。
线程A执行完unlock()，将state减1。然后去唤醒（unpark）队列中的头节点的后继节点（线程B）。
线程B被唤醒，再次尝试获取锁（CAS修改state）。



面试追问：公平锁和非公平锁的实现区别？

非公平锁：线程获取锁时，直接先尝试CAS抢锁，不管队列里有没有线程在等。抢失败了才入队。ReentrantLock默认是非公平的，吞吐量高，但可能造成“饥饿”。
公平锁：线程获取锁时，先检查队列是否为空（或有比自己更早的线程在等），如果是，则直接乖乖入队；如果不是，才尝试CAS抢锁。


4. volatile 关键字
作用：
保证可见性：对一个volatile变量的写，会立刻刷新到主内存；对一个volatile变量的读，会从主内存读取最新值。
禁止指令重排序：通过插入内存屏障来实现。


原理：在汇编层面，修改volatile变量会多执行一个lock addl $0x0, (%esp)操作。这个操作相当于一个内存屏障，并会触发缓存一致性协议（如MESI），使得其他CPU的缓存行失效，从而必须从主内存重新读取数据。
注意：volatile不保证原子性！count++这种复合操作即使加了volatile也不是线程安全的。


5. ThreadLocal
是什么：提供线程局部变量。每个线程都有一个该变量的独立副本，实现了线程隔离。
原理：
每个Thread对象内部都有一个ThreadLocalMap类型的变量threadLocals。
ThreadLocalMap的key是弱引用的ThreadLocal对象，value是存储的值。
当你调用threadLocal.set(value)时，实际上是以当前ThreadLocal实例为key，value为值，存入了当前线程的ThreadLocalMap中。


内存泄漏问题 (必问！)：
成因：由于ThreadLocalMap的key是弱引用，当ThreadLocal实例没有强引用指向时（比如置为null），在下次GC时，key会被回收，但value是强引用，还会存在。这就导致了一条key=null而value有值的无效Entry，如果线程迟迟不结束（例如线程池中的线程），就会造成内存泄漏。
解决方案：每次使用完ThreadLocal后，必须调用remove()方法，手动清除Entry。




6. 线程池 (ThreadPoolExecutor)核心参数 (7个)
corePoolSize：核心线程数，即使空闲也会保留的线程数量。
maximumPoolSize：最大线程数。
keepAliveTime：非核心线程空闲时的存活时间。
unit：存活时间的单位。
workQueue：用于保存等待执行的任务的阻塞队列（如ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue）。
threadFactory：用于创建新线程的工厂。
handler：饱和策略。当队列和线程池都满了时的处理策略（AbortPolicy抛出异常、CallerRunsPolicy用调用者线程执行、DiscardPolicy直接丢弃、DiscardOldestPolicy丢弃队列中最老的任务）。

工作流程 (非常重要！)
提交一个任务。
如果当前线程数 &lt; corePoolSize，创建新核心线程执行任务。
如果已达到核心线程数，则将任务放入workQueue等待。
如果队列已满，且当前线程数 &lt; maximumPoolSize，创建新非核心线程执行任务。
如果队列已满且线程数已达最大值，则触发饱和策略handler。
当线程空闲时间超过keepAliveTime，且是非核心线程，该线程会被回收。核心线程默认不回收（可通过allowCoreThreadTimeOut(true)设置回收）。

面试追问：如何配置线程池参数？没有固定公式，需要根据任务类型压测。

CPU密集型：线程数 ≈ CPU核数 + 1（避免过多线程上下文切换）
IO密集型：线程数可以设置得多一些，如 ≈ CPU核数 * 2 （或更高），因为线程大部分时间在阻塞等待IO。


7. JUC 并发工具包其他组件
CountDownLatch：倒计时器。一个或多个线程等待其他线程完成操作。await()等待，countDown()计数减一。
CyclicBarrier：循环栅栏。一组线程相互等待，到达一个公共屏障点后再继续执行。可重用。
Semaphore：信号量。控制同时访问特定资源的线程数量。acquire()获取许可，release()释放。

框架1. IOC (控制反转) 与 DI (依赖注入)核心概念
IoC (Inversion of Control)：是一种设计思想，将原本由程序主动创建和管理对象（new Object()）的控制权，反转给外部容器（Spring Framework）来管理。
DI (Dependency Injection)：是实现IoC的一种方式。由容器在运行期动态地将某种依赖关系注入到对象之中（通过构造函数、Setter方法等方式）。

一句话总结：IoC是目的，DI是手段。
面试追问Q：IoC容器做了什么？它的好处是什么？

做了什么：负责对象的创建、组装（注入依赖）、配置、和管理其整个生命周期。
好处：
解耦：对象之间的依赖关系由容器维护，降低了代码的耦合度。
资源集中管理：统一管理大量对象的创建和销毁，易于配置和维护。
易于测试：可以通过容器注入一个模拟对象（Mock）来进行单元测试。



Q：有哪些依赖注入的方式？

构造器注入：Spring官方推荐的方式。保证依赖不可变、完全初始化的状态。能避免循环依赖问题。
java
@Servicepublic class UserService &#123;    private final OrderService orderService;    // 构造器注入    public UserService(OrderService orderService) &#123;        this.orderService = orderService;    &#125;&#125;



Setter方法注入：可选依赖，允许对象在创建后重新配置。
java
public class UserService &#123;    private OrderService orderService;    // Setter注入    @Autowired    public void setOrderService(OrderService orderService) &#123;        this.orderService = orderService;    &#125;&#125;



字段注入（不推荐）：使用@Autowired直接标注在字段上。代码简洁，但缺点很多：不利于测试（必须通过反射注入）、隐藏了依赖关系、容易导致NPE（因为字段可能为null）。
java
public class UserService &#123;    @Autowired // 不推荐    private OrderService orderService;&#125;


2. Bean 的生命周期 (非常非常重要)一个Bean从创建到销毁的完整过程。你需要能说出关键步骤和扩展点。
简化版核心流程：

实例化 (Instantiate)：通过反射调用构造方法创建Bean的实例。
属性赋值 (Populate)：为Bean的属性注入值（依赖注入发生在这里）。
初始化 (Initialize)：
如果Bean实现了BeanNameAware、BeanFactoryAware等接口，会调用相应的回调方法。
执行所有BeanPostProcessor的**postProcessBeforeInitialization**方法。
如果Bean指定了init-method或实现了InitializingBean接口，调用初始化方法。
执行所有BeanPostProcessor的**postProcessAfterInitialization**方法（AOP代理对象的生成就在这一步！）。


使用 (Ready)：Bean已经完全初始化，存放在IoC容器中，可供应用程序使用。
销毁 (Destroy)：容器关闭时，如果Bean指定了destroy-method或实现了DisposableBean接口，会调用销毁方法。

面试追问：请详细说一下BeanPostProcessor的作用？

作用：它是Spring提供的一个强大的扩展点，允许开发者在Bean初始化前后“插手”，进行自定义逻辑。
postProcessBeforeInitialization：在初始化方法（如@PostConstruct）调用之前执行。
postProcessAfterInitialization：在初始化方法调用之后执行。Spring AOP就是通过AbstractAutoProxyCreator（它是一个BeanPostProcessor）在这一步创建代理对象的。

追问：@PostConstruct、InitializingBean、init-method的执行顺序？

@PostConstruct 注解标注的方法
InitializingBean 接口的 afterPropertiesSet() 方法
自定义的 init-method 方法


3. 循环依赖 (Circular Dependency)问题场景比如：AService 依赖 BService，同时 BService 又依赖 AService。
Spring的解决方案 (三级缓存)Spring通过三级缓存来解决单例Bean的Setter注入&#x2F;字段注入的循环依赖。

第一级缓存 (singletonObjects)：存放已经完全初始化好的Bean。
第二级缓存 (earlySingletonObjects)：存放提前暴露的原始Bean（尚未填充属性），用于解决循环依赖。
第三级缓存 (singletonFactories)：存放ObjectFactory，用于生成原始Bean的早期引用（可能被AOP代理）。

解决流程（以A、B循环依赖为例）：

开始创建A，实例化A（只是调用构造方法），得到一个原始对象。此时，将A对应的ObjectFactory放入第三级缓存。
为A进行属性赋值，发现需要注入B。于是去创建B。
开始创建B，实例化B，将B的ObjectFactory放入第三级缓存。
为B进行属性赋值，发现需要注入A。于是尝试从缓存中获取A：
从第一级缓存singletonObjects获取A -&gt; 没有。
从第二级缓存earlySingletonObjects获取A -&gt; 没有。
从第三级缓存singletonFactories中获取A的ObjectFactory，并调用getObject()方法。这个方法可能会提前进行AOP（如果A需要被代理），然后得到一个A的早期引用（可能是代理对象），并将这个早期引用放入第二级缓存，同时从第三级缓存移除A的ObjectFactory。


B成功获取到A的早期引用，完成属性赋值和初始化，成为一个完整的Bean，放入第一级缓存。
A接着注入B，完成属性赋值和初始化，也成为一个完整的Bean，放入第一级缓存。

面试追问：为什么构造器注入的循环依赖无法解决？因为构造器注入发生在实例化这一步。在实例化A时，就需要先得到B；而实例化B时，又需要先得到A。双方都卡在第一步，无法完成实例化，更无法提前暴露引用，因此三级缓存机制失效，Spring会直接抛出BeanCurrentlyInCreationException异常。

4. AOP (面向切面编程)核心概念
作用：将那些与核心业务逻辑无关但又遍布在代码中的功能（如日志、事务、安全等）分离出来，作为“横切关注点”，集中管理。
重要术语：
切面 (Aspect)：封装横切关注点的模块（一个@Aspect注解的类）。
连接点 (Joinpoint)：程序执行过程中可以插入切面的点（如方法调用、异常抛出）。
通知 (Advice)：切面在特定连接点执行的动作（@Before, @After, @Around, @AfterReturning, @AfterThrowing）。
切点 (Pointcut)：匹配连接点的表达式，定义了通知何时被执行（@Pointcut）。
织入 (Weaving)：将切面应用到目标对象并创建代理对象的过程。



实现原理：动态代理Spring AOP默认使用动态代理，根据条件选择：

JDK动态代理 (默认)：要求目标类必须实现至少一个接口。代理对象会实现相同的接口。
CGLIB动态代理：通过继承目标类来生成子类作为代理。不需要实现接口。可以通过@EnableAspectJAutoProxy(proxyTargetClass = true)强制使用。

面试追问：@Around和@After的区别？

@Around：最强大的通知。它包围了连接点，可以控制目标方法是否执行、何时执行、执行多少次，并可以修改返回值。它需要显式调用ProceedingJoinPoint.proceed()来执行目标方法。
@After：最终通知。无论目标方法是正常返回还是抛出异常，它都会执行（类似于finally块）。


5. Spring Boot 自动配置原理 (Magic)这是Spring Boot的核心魅力所在。
核心注解：@SpringBootApplication它是一个复合注解，主要由三个注解组成：

@SpringBootConfiguration：表明这是一个配置类。
@ComponentScan：开启组件扫描。
@EnableAutoConfiguration (关键)：启用自动配置。

@EnableAutoConfiguration 的工作原理：

它导入了AutoConfigurationImportSelector类。
这个类会调用SpringFactoriesLoader.loadFactoryNames()方法，从所有jar包的META-INF/spring.factories文件中读取EnableAutoConfiguration键对应的全限定类名列表（这些就是自动配置类）。
这些自动配置类（如DataSourceAutoConfiguration）使用@Configuration注解，并利用@ConditionalOnClass, @ConditionalOnProperty, @ConditionalOnMissingBean等条件注解进行判断。
条件注解的逻辑是： “如果类路径下有某个类”、“如果配置了某个属性”、“如果容器中没有某个Bean”，才创建配置中定义的Bean。
这样就实现了：只要你引入了spring-boot-starter-web，Tomcat和Spring MVC所需的Bean就会自动配置好；只要你引入了spring-boot-starter-jdbc并配置了数据源，DataSource和JdbcTemplate就会自动配置好。

面试追问：如何自定义一个Starter？

创建一个项目，包含自动配置模块your-starter-autoconfigure和可选依赖模块your-starter。
在your-starter-autoconfigure中创建：
一个YourServiceProperties类，绑定@ConfigurationProperties。
一个YourServiceAutoConfiguration类，使用@Configuration和@EnableConfigurationProperties(YourServiceProperties.class)，并用条件注解控制Bean的创建。


在resources/META-INF/下创建spring.factories文件，添加org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.you.YourServiceAutoConfiguration。
将your-starter-autoconfigure打包，并在your-starter中依赖它。

消息队列一、消息队列核心模型与价值消息队列（MQ）是分布式系统中实现异步通信、解耦服务、削峰填谷的核心组件，核心模型是发布 - 订阅模式：

生产者（Producer）：发送消息的服务；
消费者（Consumer）：接收并处理消息的服务；
** broker**：中间件服务器，存储消息并转发给消费者；
主题（Topic）：消息的分类标识，生产者向 Topic 发送消息，消费者从 Topic 订阅消息。

核心价值：

解耦：服务间通过 MQ 通信，无需直接依赖；
异步：非核心流程异步处理（如下单后异步发送通知），提升主流程响应速度；
削峰：高并发场景下（如秒杀），MQ 缓冲请求，避免下游服务被压垮；
可靠通信：通过持久化、重试机制确保消息不丢失。

二、Kafka 深度解析Kafka 是高吞吐、低延迟的分布式消息系统，适合大数据场景（如日志收集、实时计算）。
1. 核心架构组件（示意图：展示生产者、broker 集群、消费者组与 ZooKeeper 的关系）

Producer（生产者）：发送消息到 Topic，支持同步 &#x2F; 异步发送，通过分区策略（默认按 key 哈希）将消息分配到具体分区。
Consumer（消费者）：从 Topic 订阅消息，以消费者组（Consumer Group） 为单位工作：
同一组内的消费者分工消费不同分区（一个分区仅被组内一个消费者消费）；
不同组可独立消费同一 Topic（广播模式）。


Broker（ broker 节点）：存储消息的服务器，多个 broker 组成集群。每个 broker 负责多个 Topic 的分区存储。
Topic 与 Partition（分区）：
Topic 是消息的逻辑分类，物理上被划分为多个分区（Partition），分区是 Kafka 并行处理的最小单位；
每个分区是有序的、不可变的消息日志（按时间顺序追加），消息被分配全局唯一的 offset（偏移量）标识位置。


Replica（副本）：每个分区有多个副本（1 个 leader + N 个 follower），实现高可用：
leader 副本：处理读写请求；
follower 副本：同步 leader 数据，leader 故障时通过选举成为新 leader。
ISR（In-Sync Replicas）：与 leader 保持同步的副本集合（延迟不超过阈值），只有 ISR 内的副本可参与 leader 选举。


ZooKeeper（Kafka 2.8 前）：管理集群元数据（如 broker 节点列表、分区 - 副本映射、消费者组 offset），协调 leader 选举。注：Kafka 2.8+ 支持 KRaft 模式（去 ZooKeeper 化），用内置元数据控制器替代 ZooKeeper。

2. 消息可靠原理（生产 - 存储 - 消费全链路）（1）生产端可靠性：确保消息成功发送到 broker
acks 参数控制确认级别
：

acks=0：生产者发送后不等待确认（可能丢失，吞吐最高）；
acks=1：仅等待 leader 写入成功确认（leader 故障可能丢失）；
acks=all（或 -1）：等待 leader 和所有 ISR 中的 follower 写入成功确认（最可靠，吞吐最低）。


重试机制：配置 retries（重试次数）和 retry.backoff.ms（重试间隔），应对网络抖动等临时故障。


（2）存储端可靠性：确保消息持久化不丢失
分区副本机制：通过多副本（如 3 副本），即使单个 broker 故障，数据仍可从其他副本恢复；
日志持久化：消息写入分区后，先存于页缓存（PageCache），再通过刷盘策略写入磁盘（log.flush.interval.messages 控制消息数触发刷盘，log.flush.interval.ms 控制时间触发）；
ISR 动态维护：follower 若落后 leader 超过阈值（replica.lag.time.max.ms，默认 30s），会被移出 ISR，确保仅同步状态良好的副本参与确认。

（3）消费端可靠性：确保消息被正确处理
offset 提交机制
：消费者处理完消息后，手动提交 offset（记录已消费到的位置）：

自动提交（enable.auto.commit=true）：按间隔自动提交，可能重复消费（处理中未提交，消费者重启）；
手动提交：commitSync()（同步阻塞）或 commitAsync()（异步非阻塞），确保处理成功后再提交，避免消息丢失。


消费者组重平衡（Rebalance）：当消费者组内成员变化（新增 &#x2F; 下线）或分区数量变化时，重新分配分区与消费者的映射，需通过 group.id 标识组，session.timeout.ms 检测消费者存活。


3. 典型问题与解决方案
消息重复消费：因网络延迟导致 offset 提交失败，消费者重启后重复拉取。解决：消费逻辑设计为幂等性（如基于消息 ID 去重）。
顺序消息：Kafka 仅保证分区内消息有序（按 offset 递增），全局无序。若需全局有序，需将 Topic 设为 1 个分区（牺牲并行性）。

三、RocketMQ 深度解析RocketMQ 是阿里开源的消息中间件，侧重金融级可靠性、低延迟和丰富的消息类型（如事务消息、定时消息），适合业务系统（如电商交易）。
1. 核心架构组件（示意图：展示生产者、消费者、broker 集群、NameServer 的关系）

Producer（生产者）：发送消息到 Topic，支持同步、异步、单向发送，提供事务消息、定时消息等高级特性。
Consumer（消费者）：从 Topic 消费消息，分两种模式：
集群消费（Clustering）：同组消费者分摊消费（类似 Kafka 的消费者组）；
广播消费（Broadcasting）：同组每个消费者都收到全量消息。


Broker（ broker 节点）：存储消息并处理读写请求，分Master（可读写）和Slave（只读，同步 Master 数据），支持多 Master 多 Slave 架构。
Topic 与 Queue（队列）：
Topic 是消息逻辑分类，物理上划分为多个队列（Queue）（类似 Kafka 的 Partition）；
每个 Queue 是有序的消息列表，消息按发送顺序存储，支持顺序消费。


NameServer：轻量级路由注册中心，存储 Topic 与 broker 的映射关系（无状态，可集群部署，节点间不通信）：
生产者 &#x2F; 消费者启动时从 NameServer 获取 Topic 的路由信息（Queue 分布在哪些 broker）；
broker 定期向 NameServer 发送心跳，维持存活状态。


CommitLog 与 ConsumeQueue：
CommitLog：全局统一的消息存储文件（所有 Topic 的消息混合存储），按顺序追加写入；
ConsumeQueue：每个 Queue 对应一个 ConsumeQueue（索引文件），记录消息在 CommitLog 中的偏移量、大小和 Tag 哈希值，加速消息检索。



2. 消息可靠原理（生产 - 存储 - 消费全链路）（1）生产端可靠性：确保消息成功投递
发送确认机制
：

同步发送：等待 broker 返回确认（SEND_OK），失败则重试（retryTimesWhenSendFailed）；
异步发送：通过回调函数处理发送结果，失败时触发重试。


事务消息：支持分布式事务（2PC 思想），通过 “半消息 + 确认 &#x2F; 回滚” 机制确保事务一致性。


（2）存储端可靠性：确保消息持久化
刷盘策略
：消息写入 CommitLog 时，可配置：

同步刷盘（SYNC_FLUSH）：消息写入磁盘后才返回确认（可靠性高，性能低）；
异步刷盘（ASYNC_FLUSH）：消息写入页缓存后即返回，后台线程异步刷盘（性能高，可能丢失未刷盘数据）。


主从复制策略
：Master 与 Slave 的数据同步：

同步复制：Master 等待 Slave 复制完成后才返回确认（无单点丢失风险）；
异步复制：Master 无需等待 Slave，直接返回（性能高，Slave 未同步时 Master 故障会丢失数据）。



（3）消费端可靠性：确保消息被正确处理
消费确认（Ack）
：

消费者处理完消息后，需发送 Ack 给 broker（默认自动 Ack，可配置手动 Ack）；
未 Ack 的消息会被放入重试队列（最多重试 16 次，间隔递增），避免消息丢失。


消费位点管理：broker 存储消费者组的消费位点（消费到哪个 Queue 的哪个位置），消费者重启后可从位点继续消费。


3. 典型问题与解决方案
事务消息实现
：解决分布式事务（如 “下单 + 扣库存”），流程：

生产者发送 “半消息”（暂不能被消费）；
执行本地事务；
发送 “确认”（半消息变为可消费）或 “回滚”（半消息被删除）；
若超时未确认，broker 通过 “回查” 生产者确认事务状态。


顺序消息：支持全局顺序（Topic 仅 1 个 Queue）和分区顺序（按业务 key 路由到固定 Queue），确保同一 key 的消息有序消费。


四、Kafka vs RocketMQ 核心差异


维度
Kafka
RocketMQ



定位
高吞吐大数据场景（日志、流处理）
业务系统（交易、通知），侧重可靠性


元数据管理
依赖 ZooKeeper（或 KRaft）
轻量级 NameServer（无状态）


消息存储
分区日志文件（按 Topic - 分区隔离）
全局 CommitLog + 索引 ConsumeQueue


高级特性
基础消息、流处理集成（Kafka Streams）
事务消息、定时消息、重试队列等


吞吐量
极高（单机十万级 &#x2F; 秒）
高（单机万级 &#x2F; 秒，满足业务场景）


延迟
毫秒级
毫秒级（略高于 Kafka）


总结Kafka 和 RocketMQ 均基于发布 - 订阅模式，通过分区 &#x2F; 队列实现并行处理，通过副本机制保证可靠性。Kafka 以高吞吐见长，适合大数据场景；RocketMQ 以丰富特性和金融级可靠性为优势，适合业务系统。理解两者的架构设计（如分区 &#x2F; 队列、元数据管理）和可靠性保障机制（生产确认、存储持久化、消费确认），是正确选型和解决问题的核心。
微服务一、微服务核心认知与开发流程微服务是将单体应用拆分为独立部署、职责单一、通信轻量的小型服务集群，每个服务聚焦特定业务域，通过 HTTP&#x2F;RPC 等协议协作。其核心目标是解决单体应用 “迭代慢、扩展性差、故障影响范围大” 的问题。
1. 微服务开发全流程


阶段
核心任务
关键原则 &#x2F; 工具



需求分析与服务拆分
将业务拆分为独立服务（如电商拆分为用户、订单、商品、支付服务）
按业务域拆分、单一职责、高内聚低耦合（DDD 领域驱动设计可辅助）


技术选型
确定注册中心、配置中心、服务调用、流量控制、网关等组件
主流栈：Spring Cloud Alibaba（Nacos&#x2F;Feign&#x2F;Sentinel）或 Spring Cloud Netflix


服务开发
单个服务按 “分层架构” 实现（Controller→Service→DAO），暴露 API 接口
统一接口规范（如 RESTful）、定义服务契约（OpenAPI&#x2F;Swagger）


服务治理
解决服务注册发现、配置同步、调用熔断、流量控制、监控告警等问题
Nacos（注册 &#x2F; 配置）、Sentinel（流量）、Prometheus+Grafana（监控）


部署运维
服务容器化（Docker）、编排（K8s）、持续集成 &#x2F; 部署（CI&#x2F;CD）
容器化部署、灰度发布、滚动更新


2. 服务拆分关键原则
避免 “过细拆分”：拆分过细会导致服务间调用频繁（“分布式事务地狱”），通常按 “业务能力” 拆分（如 “商品管理” 而非 “商品查询”“商品修改” 两个服务）；
数据自治：每个服务拥有独立数据库（避免跨服务读写库），跨服务数据交互通过 API 而非直接操作 DB；
接口稳定：服务对外 API 一旦发布，避免频繁变更（如需变更，兼容旧版本或版本化 API）。

二、核心技术栈详解（Spring Cloud Alibaba 体系）1. Nacos：注册中心 + 配置中心（双核心角色）Nacos（Dynamic Naming and Configuration Service）是微服务的 “地址簿” 和 “配置中心”，替代传统的 Eureka（注册）+ Config（配置），支持高可用、动态更新。
（1）核心作用：服务注册与发现解决 “服务间如何找到彼此” 的问题（如订单服务需调用商品服务，需知道商品服务的 IP:Port）。
工作流程：

服务注册：服务启动时，通过 Nacos 客户端将自身信息（服务名、IP、Port、健康状态）注册到 Nacos Server；
心跳续约：服务每 5 秒发送心跳到 Nacos，Nacos 超过 15 秒未收到心跳则标记 “不健康”，30 秒未收到则移除服务；
服务发现：消费者通过服务名向 Nacos 查询可用实例列表，Nacos 返回健康实例（默认采用 “加权随机” 负载均衡策略）。

使用实践：

依赖引入（Spring Boot 项目）：
xml
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;

配置
application.yml

：
yaml
spring:  cloud:    nacos:      discovery:        server-addr: 192.168.1.100:8848  # Nacos Server地址  application:    name: order-service  # 服务名（核心标识，消费者通过此名调用）

（2）核心作用：配置中心解决 “多环境、多服务配置集中管理与动态更新” 的问题（如开发 &#x2F; 测试 &#x2F; 生产环境的数据库配置，无需重启服务即可生效）。
工作流程：

配置发布：在 Nacos 控制台创建配置（如order-service-dev.yml），关联服务名和环境；
配置拉取：服务启动时，Nacos 客户端根据 “服务名 + 环境” 拉取配置，覆盖本地配置；
动态更新：配置变更时，Nacos 通过 HTTP 长轮询通知客户端，客户端自动刷新配置（无需重启）。

使用实践：

依赖引入：
xml
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;

配置
bootstrap.yml

（优先于
application.yml

加载）：
yaml
spring:  cloud:    nacos:      config:        server-addr: 192.168.1.100:8848        file-extension: yml  # 配置文件格式        group: DEFAULT_GROUP  # 配置分组（默认即可）  application:    name: order-service  profiles:    active: dev  # 环境（对应配置名：order-service-dev.yml）

动态刷新配置：在需要刷新的类上加
@RefreshScope

：
java
@RestController@RefreshScope  // 配置变更时自动刷新public class OrderController &#123;    @Value(&quot;$&#123;order.timeout:3000&#125;&quot;)  // 从Nacos获取配置，默认3000    private Integer timeout;&#125;

（3）Nacos 高可用部署生产环境需部署 Nacos 集群（至少 3 节点），通过 MySQL 共享元数据（避免单机故障），并配置负载均衡器（如 Nginx）代理 Nacos Server 地址。
2. Feign：声明式服务调用工具Feign 是基于Netflix Feign封装的 HTTP 客户端，通过注解定义接口即可实现服务间调用，无需手动编写RestTemplate+URL 的繁琐代码，且默认集成 Ribbon（负载均衡）和 Sentinel（熔断降级）。
（1）核心原理：动态代理
扫描@FeignClient注解的接口，生成动态代理实现类；
代理类将接口方法转换为 HTTP 请求（解析@GetMapping&#x2F;@PostMapping等注解）；
通过 Ribbon 从 Nacos 获取服务实例列表，选择一个实例发起请求；
接收响应，转换为 Java 对象返回给调用者。

（2）使用实践
依赖引入：
xml
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;!-- 集成Sentinel熔断 --&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt;

启动类加
@EnableFeignClients

：
java
@SpringBootApplication@EnableFeignClients  // 开启Feign扫描public class OrderServiceApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderServiceApplication.class, args);    &#125;&#125;

定义 Feign 接口（调用商品服务）：
java
@FeignClient(    value = &quot;product-service&quot;,  // 目标服务名（Nacos中注册的名称）    fallback = ProductFeignFallback.class  // 熔断降级回调类)public interface ProductFeignClient &#123;    // 对应商品服务的接口：GET /product/&#123;id&#125;    @GetMapping(&quot;/product/&#123;id&#125;&quot;)    ProductDTO getById(@PathVariable(&quot;id&quot;) Long id);&#125;// 熔断降级实现类@Componentpublic class ProductFeignFallback implements ProductFeignClient &#123;    @Override    public ProductDTO getById(Long id) &#123;        // 服务不可用时返回默认值或提示        return new ProductDTO(id, &quot;服务暂不可用&quot;, 0.0);    &#125;&#125;

服务中调用：
java
@Servicepublic class OrderService &#123;    @Autowired    private ProductFeignClient productFeignClient;    public OrderDTO createOrder(Long productId) &#123;        // 调用商品服务获取商品信息（Feign自动处理服务发现和负载均衡）        ProductDTO product = productFeignClient.getById(productId);        // 业务逻辑...        return new OrderDTO(1L, productId, product.getName());    &#125;&#125;

（3）关键特性与问题
负载均衡：默认集成 Ribbon，支持 “轮询”“加权随机” 等策略（可通过ribbon.NFLoadBalancerRuleClassName配置）；

超时配置
：避免服务调用卡住，需配置超时时间：
yaml
feign:  client:    config:      default:  # 全局配置（也可指定服务名如product-service）        connect-timeout: 5000  # 连接超时        read-timeout: 3000     # 读取超时

与 RestTemplate 的区别：Feign 是 “声明式”（接口 + 注解），代码更简洁；RestTemplate 是 “命令式”（需手动拼接 URL 和参数），灵活性更高。


3. Sentinel：流量控制与服务容错工具Sentinel（哨兵）是阿里开源的流量治理组件，解决微服务中的 “流量突增压垮服务”“服务故障级联扩散（雪崩）” 等问题，核心功能：限流、熔断、降级。
（1）核心概念
资源：需要保护的对象（如 Feign 调用、Controller 方法，通过@SentinelResource标记）；
规则：限流 &#x2F; 熔断 &#x2F; 降级的配置（如 “每秒最多 100 个请求”“异常比例超过 50% 则熔断”）；
插槽链（Slot Chain）：Sentinel 的核心骨架，依次执行 “节点选择→规则校验→统计” 等逻辑（如限流 Slot、熔断 Slot）。

（2）三大核心功能


功能
作用
典型场景



限流
限制单位时间内的请求量，避免服务过载
秒杀活动、接口峰值防护


熔断
服务调用异常（超时 &#x2F; 异常比例高）时，暂时切断调用，避免故障扩散
下游服务故障，防止上游服务被拖垮


降级
熔断或限流触发后，返回默认值 &#x2F; 缓存数据，避免返回错误给用户
商品详情接口降级，返回缓存数据


（3）使用实践（结合 Spring Cloud）
依赖引入（同 Feign 部分的sentinel依赖）；

配置 Sentinel Dashboard（可视化控制台，用于配置规则和监控）：
yaml
spring:  cloud:    sentinel:      transport:        dashboard: 192.168.1.100:8080  # Sentinel控制台地址        port: 8719  # 客户端与控制台通信端口

标记资源并配置规则：
java
@RestControllerpublic class OrderController &#123;    // 标记资源：order-create，配置限流规则    @SentinelResource(        value = &quot;order-create&quot;,  // 资源名        blockHandler = &quot;blockHandler&quot;,  // 限流/熔断触发的回调        fallback = &quot;fallback&quot;  // 业务异常触发的降级    )    @PostMapping(&quot;/order&quot;)    public ResultDTO createOrder(@RequestBody OrderVO orderVO) &#123;        // 业务逻辑（如调用商品服务扣库存）        return ResultDTO.success(&quot;订单创建成功&quot;);    &#125;    // 限流/熔断回调（参数和返回值需与原方法一致，额外加BlockException参数）    public ResultDTO blockHandler(OrderVO orderVO, BlockException e) &#123;        return ResultDTO.fail(&quot;请求过于频繁，请稍后再试&quot;);    &#125;    // 业务异常回调    public ResultDTO fallback(OrderVO orderVO, Throwable e) &#123;        return ResultDTO.fail(&quot;系统异常，请稍后再试&quot;);    &#125;&#125;

在 Sentinel 控制台配置限流规则：

访问http://192.168.1.100:8080（默认账号密码 sentinel&#x2F;sentinel）；

找到
order-service

服务，点击 “流控规则”→“新增”，配置：

资源名：order-create；
限流类型：QPS（每秒请求数）；
阈值：10（每秒最多 10 个请求）。





（4）关键规则详解
限流算法：
固定窗口：简单但可能出现 “临界问题”（如 1 秒拆为两个 500ms 窗口，每个窗口阈值 100，实际 1 秒可能 200 请求）；
滑动窗口：将 1 秒拆分为多个小窗口（如 10 个 100ms 窗口），滑动统计请求数，解决临界问题（Sentinel 默认）；
令牌桶：匀速生成令牌，请求需获取令牌才允许通过（适合平滑流量）；
漏桶：请求匀速流出，应对突发流量（类似 “泄洪”）。


熔断规则：支持三种熔断策略：
慢调用比例：慢调用（超过阈值）占比超过设定值，触发熔断；
异常比例：异常请求占比超过设定值，触发熔断；
异常数：单位时间内异常数超过设定值，触发熔断。



三、微服务核心治理场景与解决方案


场景
技术组合
解决方案



服务间调用
Nacos + Feign
Feign 声明式调用，Nacos 提供服务发现，Ribbon 负载均衡


配置集中管理
Nacos 配置中心
多环境配置集中存储，动态刷新（@RefreshScope）


流量峰值防护
Sentinel 限流
基于 QPS 配置限流规则，避免服务过载


服务故障隔离
Sentinel 熔断
下游服务故障时熔断，防止级联雪崩


接口文档统一管理
Feign + Knife4j（Swagger 增强）
自动生成接口文档，支持调试


分布式事务
Seata（Spring Cloud Alibaba 组件）
基于 TCC&#x2F;SAGA 模式，解决跨服务事务一致性（如订单 + 支付 + 库存的事务）


总结微服务开发的核心是 “服务治理”，Nacos 解决 “注册与配置” 的基础问题，Feign 简化 “服务间调用”，Sentinel 保障 “流量与容错”，三者构成 Spring Cloud Alibaba 体系的核心骨架。实际开发中，需结合业务场景合理拆分服务、配置组件参数（如 Feign 超时、Sentinel 阈值），并通过监控工具（如 Sentinel Dashboard、Prometheus）实时感知服务状态，确保微服务集群稳定运行。
java基础一、面向对象思想（OOP）核心名词解释
封装：将对象的属性（数据）和方法（操作）封装在类中，通过访问修饰符（private&#x2F;protected&#x2F;public&#x2F; 默认）控制外部访问权限，仅暴露必要接口（如 getter&#x2F;setter），隐藏内部实现细节。
继承：子类通过关键字继承父类，复用父类的属性和方法，同时可新增功能或重写父类方法，体现 “is-a” 关系。
多态：同一行为在不同对象上表现出不同实现，核心是 “父类引用指向子类对象”，依赖继承 &#x2F; 实现关系、方法重写两大前提。
抽象：通过抽象类或接口提取事物共性行为，忽略具体实现，约束子类必须实现核心功能，聚焦 “做什么” 而非 “怎么做”。

核心问答
问：封装的核心价值是什么？答：一是隐藏实现细节，避免外部误修改数据（如对年龄属性加合法性校验）；二是降低代码耦合，外部仅通过接口交互，内部逻辑修改不影响外部使用。
问：继承有哪些限制？实际开发中如何规避继承的弊端？答：Java 仅支持单继承（一个类只能有一个直接父类），且父类修改可能引发子类 “雪崩式” 变更（强耦合）。规避方式：优先使用组合（“has-a” 关系，如汽车包含发动机对象），通过对象关联实现功能复用，降低耦合。
问：多态的实现条件和核心价值是什么？答：实现条件有三：一是存在继承或接口实现关系；二是子类重写父类方法；三是父类引用指向子类对象。核心价值是降低耦合（依赖抽象而非具体实现），提升扩展性（新增子类无需修改原有调用逻辑）。

追问
追问 1：多态在框架中的典型应用场景有哪些？答：比如 Spring 的 BeanPostProcessor 接口，不同实现类可对 Bean 初始化做不同增强，框架通过父类引用调用具体实现；又如日志框架的 LoggerFactory，返回 Logger 接口即可切换不同日志实现，调用者无需关心底层。
追问 2：抽象类和接口的核心区别是什么？JDK8 后接口有哪些变化？答：抽象类可含普通方法和抽象方法，支持任意属性，子类通过 extends 单继承；接口早期仅含抽象方法和常量，JDK8 后新增默认方法（default）和静态方法，类通过 implements 多实现。核心区别是抽象类侧重 “部分实现”，接口侧重 “行为规范”。

二、常用集合及底层数据结构核心名词解释
ArrayList：基于动态数组实现的 List 集合，初始容量 10，扩容时为原容量的 1.5 倍，支持随机访问。
LinkedList：基于双向链表实现的 List 集合，每个节点包含 prev（前驱）和 next（后继）指针，插入删除首尾元素效率高。
HashMap：基于 “数组 + 链表 + 红黑树” 实现的 Map 集合，通过哈希函数定位元素，链表长度超过 8 且数组容量≥64 时转为红黑树。
ConcurrentHashMap：线程安全的 Map 集合，JDK8 后通过 “CAS+ synchronized” 保证安全，锁粒度为哈希桶（链表 &#x2F; 红黑树的头节点）。
HashSet：基于 HashMap 实现的 Set 集合，将元素作为 HashMap 的 key 存储，依赖 hashCode () 和 equals () 保证元素不可重复。

核心问答
问：HashMap 的底层结构演变（JDK7 vs JDK8）及扩容机制是什么？答：JDK7 底层是 “数组 + 链表”，JDK8 新增红黑树优化（解决长链表查询慢问题）。扩容机制：当元素数超过 “容量 × 负载因子（默认 0.75）” 时，容量翻倍（保证为 2 的幂次，方便计算索引），重新计算元素哈希值并迁移。
问：ArrayList 和 LinkedList 的核心区别及适用场景是什么？答：从结构看，ArrayList 是动态数组，LinkedList 是双向链表；从性能看，ArrayList 随机访问快（O (1)）、插入删除中间慢（O (n)），LinkedList 插入删除首尾快（O (1)）、随机访问慢（O (n)）。适用场景：频繁查询用 ArrayList，频繁增删首尾用 LinkedList。
问：HashSet 如何保证元素不可重复？为什么要同时重写 hashCode () 和 equals ()？答：HashSet 本质是 HashMap 的 key 集合（value 固定为常量），添加元素时先通过 hashCode () 计算哈希值定位数组位置，再通过 equals () 比较该位置的元素是否相同，两者都相同则判定为重复元素，拒绝添加。若仅重写 equals ()，可能因 hashCode () 不同导致相同元素存入不同位置；仅重写 hashCode ()，可能因 equals () 不同导致重复元素存入同一位置，均无法保证去重。

追问
追问 1：HashMap 为什么不是线程安全的？JDK8 的 ConcurrentHashMap 如何解决线程安全问题？答：HashMap 线程不安全体现在两方面：多线程扩容时 JDK7 的头插法可能导致链表成环（JDK8 尾插法解决）；多线程 put 时可能覆盖彼此结果。ConcurrentHashMap JDK8 后摒弃分段锁，改用 “CAS+ synchronized”：写操作锁定哈希桶头节点，不同桶可并发；读操作无锁，依赖 volatile 保证节点值可见性。
追问 2：TreeSet 和 LinkedHashSet 的排序机制有何不同？答：TreeSet 基于红黑树实现，通过元素的 Comparable 接口或外部 Comparator 实现自然排序或自定义排序，排序与插入顺序无关；LinkedHashSet 基于 LinkedHashMap 实现，通过双向链表维护元素的插入顺序，同时保证去重，排序与插入顺序一致。

三、Lambda 表达式与 Stream 流核心名词解释
Lambda 表达式：Java8 引入的函数式编程语法，用于简化匿名内部类，格式为 “(参数列表) -&gt; 方法体”，仅能用于函数式接口（含一个抽象方法的接口）。
函数式接口：仅包含一个抽象方法的接口，可通过 @FunctionalInterface 注解校验，如 Runnable、Consumer、Comparator 等。
Stream 流：Java8 用于处理集合的 “流水线式” 工具，将集合转换为元素序列，支持中间操作（惰性执行）和终止操作（触发执行），实现高效的集合处理。
中间操作：Stream 流的非终止操作，返回新的 Stream，不立即执行，如 filter（筛选）、map（转换）、sorted（排序）。
终止操作：触发 Stream 流实际处理的操作，返回非 Stream 结果，如 collect（收集）、forEach（遍历）、count（计数）。

核心问答
问：Lambda 表达式的使用前提是什么？相比匿名内部类有哪些优势？答：使用前提是必须关联函数式接口（仅含一个抽象方法）。优势在于：代码更简洁，省去匿名内部类的类名、方法名等冗余结构；语义更清晰，直接聚焦核心逻辑；支持方法引用，进一步简化代码。
问：Stream 流的 “惰性求值” 是什么意思？为什么要设计成惰性求值？答：惰性求值指仅调用终止操作时，中间操作才会实际执行，若没有终止操作，中间操作不会触发任何计算。设计目的是优化性能：可合并多个中间操作一次性处理（减少遍历次数），避免无效计算（如提前过滤掉大部分元素后再转换）。
问：Stream 流的并行流（parallelStream）原理是什么？使用时需注意什么？答：并行流基于 Fork&#x2F;Join 框架实现，将数据拆分为多个子任务，由多个线程并行处理后合并结果，适合 CPU 密集型任务。注意事项：避免处理非线程安全的集合（如 ArrayList），可能导致数据错乱；避免在并行流中修改共享变量，需额外加锁反而降低性能。

追问
追问 1：使用 Stream 流时常见的 “坑” 有哪些？如何规避？答：一是重复消费，Stream 流只能被消费一次（终止操作后关闭），重复调用会抛异常，规避需重新创建 Stream；二是线程安全问题，并行流操作非线程安全集合会出问题，规避需使用线程安全集合或在处理时加锁；三是忽略惰性求值，忘记加终止操作导致中间操作无效，规避需确保每个 Stream 流都有明确的终止操作。
追问 2：方法引用是什么？有哪些常见类型？答：方法引用是 Lambda 表达式的简化形式，当 Lambda 体仅调用一个现有方法时，可通过 “类名：：方法名” 或 “对象：：方法名” 替代。常见类型有：实例方法引用（如 user::getName）、静态方法引用（如 Math::max）、构造方法引用（如 User::new）。

四、多线程及并发容器核心名词解释
线程：进程内的最小执行单元，一个进程可包含多个线程，共享进程资源，实现并发执行。
线程生命周期：线程从创建到销毁的状态变化，包含 NEW（新建）、RUNNABLE（就绪 &#x2F; 运行）、BLOCKED（阻塞）、WAITING（无超时等待）、TIMED_WAITING（超时等待）、TERMINATED（终止）6 种状态。
Callable：带返回值的线程任务接口，定义了 call () 方法，可抛出受检异常，需结合 FutureTask 获取执行结果。
ConcurrentHashMap：线程安全的 HashMap 实现，JDK8 后通过 “CAS+ synchronized” 保证并发安全，锁粒度细，性能优于 Hashtable。
CopyOnWriteArrayList：基于 “写时复制” 机制的线程安全 List，读操作无锁，写操作复制原数组修改后替换，适合读多写少场景。
BlockingQueue：支持阻塞操作的队列，提供 put ()（队列满时阻塞）和 take ()（队列空时阻塞）方法，常用于生产者 - 消费者模型。

核心问答
问：线程的 6 种生命周期状态及转换触发场景是什么？答：① NEW：new Thread () 后未调用 start ()；② RUNNABLE：调用 start () 后等待 CPU 调度或正在运行；③ BLOCKED：获取 synchronized 锁失败时进入；④ WAITING：调用 object.wait ()、thread.join () 等无超时方法时进入，需被唤醒；⑤ TIMED_WAITING：调用 Thread.sleep (long)、object.wait (long) 等超时方法时进入，超时自动唤醒；⑥ TERMINATED：run () 执行完毕或异常终止。
问：CopyOnWriteArrayList 的 “写时复制” 机制是什么？有哪些优缺点？答：写时复制指：读操作直接访问原数组（无锁，效率高）；写操作（add&#x2F;remove）先复制一份原数组，在新数组上修改，修改完成后用 volatile 变量替换原数组引用。优点是读操作无锁、线程安全；缺点是内存开销大（复制数组）、弱一致性（写后读可能看到旧数据）。
问：线程创建的三种方式及核心区别是什么？答：三种方式分别是：① 继承 Thread 类：重写 run () 方法，无返回值，无法抛受检异常，受单继承限制；② 实现 Runnable 接口：重写 run () 方法，无返回值，无法抛受检异常，可避免单继承限制；③ 实现 Callable 接口：重写 call () 方法，有返回值，可抛受检异常，需结合 FutureTask 获取结果。核心区别在于是否有返回值、是否受单继承限制、是否能抛受检异常。

追问
追问 1：wait () 和 sleep () 的核心区别是什么？答：从锁释放看，wait () 会释放持有的对象锁，sleep () 不会；从调用场景看，wait () 必须在 synchronized 块中调用，sleep () 可在任意场景调用；从唤醒方式看，wait () 需通过 notify ()&#x2F;notifyAll () 唤醒，sleep () 超时自动唤醒；从所属类看，wait () 是 Object 类方法（所有对象都有），sleep () 是 Thread 类方法。

追问 2：ConcurrentHashMap 在 JDK7 和 JDK8 的实现有何不同？为什么 JDK8 性能更优？答：JDK7 采用 “分段锁（Segment）”，将数组分为多个 Segment，每个 Segment 是独立的 HashMap，锁粒度为 Segment；JDK8 摒弃分段锁，改用 “数组 + 链表 + 红黑树”，通过 “CAS+ synchronized” 锁定哈希桶头节点，锁粒度更细（仅单个桶）。JDK8 性能更优是因为锁粒度细化，不同桶的操作可并发执行，减少锁竞争。


]]></content>
      <categories>
        <category>Java</category>
        <category>为了实习说是</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>为了实习说是</tag>
      </tags>
  </entry>
</search>
