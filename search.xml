<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025Lilctf(Reverse)</title>
    <url>/2025/08/15/2025Lilctf(Revese)/</url>
    <content><![CDATA[2025Lilctf(Reverse)1.ARM ASM发现是apk，放到jadx看一下，发现：

然后ida打开看到：

找到这三个关键函数以及：

推测是变表和移位的base64，扔给ai分析一下，生成脚本：
import base64# 自定义Base64表custom_b64_table = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ3456780129+/&quot;standard_b64_table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;# 目标密文target_b64 = &quot;KRD2c1XRSJL9e0fqCIbiyJrHW1bu0ZnTYJvYw1DM2RzPK1XIQJnN2ZfRMY4So09S&quot;# 转换到标准Base64def to_standard_b64(s):    return s.translate(str.maketrans(custom_b64_table, standard_b64_table))# 解码Base64std_b64_str = to_standard_b64(target_b64)decoded = base64.b64decode(std_b64_str)data = list(decoded)  # 解码后的48字节数据# 移位逆操作（每3字节一组）def reverse_shift(data):    result = []    for i in range(0, len(data), 3):        # 第1字节：循环右移3位（加密时循环左移3位）        b0 = data[i]        b0 = ((b0 &gt;&gt; 3) | (b0 &lt;&lt; 5)) &amp; 0xFF                # 第2字节：循环左移1位（加密时循环右移1位）        b1 = data[i+1]        b1 = ((b1 &lt;&lt; 1) | (b1 &gt;&gt; 7)) &amp; 0xFF                # 第3字节不变        b2 = data[i+2]        result.extend([b0, b1, b2])    return result# 置换表tt0 = [0x0D, 0x0E, 0x0F, 0x0C, 0x0B, 0x0A, 0x09, 0x08,       0x06, 0x07, 0x05, 0x04, 0x02, 0x03, 0x01, 0x00]# 构造逆置换表inv_t = [0] * 16for i in range(16):    inv_t[t0[i]] = i# 三轮变换逆操作（正确密钥）def reverse_blocks(blocks):    # 块0：使用密钥 t0    block0 = [blocks[0][i] ^ t0[i] for i in range(16)]    block0 = [block0[inv_t[i]] for i in range(16)]        # 块1：使用密钥 t0    block1 = [blocks[1][i] ^ t0[i] for i in range(16)]    block1 = [block1[inv_t[i]] for i in range(16)]        # 块2：使用密钥 t0⊕1（关键修正！）    key2 = [b ^ 0x01 for b in t0]    block2 = [blocks[2][i] ^ key2[i] for i in range(16)]    block2 = [block2[inv_t[i]] for i in range(16)]        return block0 + block1 + block2# 步骤1: 移位逆操作data = reverse_shift(data)# 分块（16字节/块）blocks = [    data[0:16],   # 块0: 0-15字节    data[16:32],  # 块1: 16-31字节    data[32:48]   # 块2: 32-47字节]# 步骤2: 三轮逆操作（使用正确密钥）original_data = reverse_blocks(blocks)# 转换为字符串flag = &#x27;&#x27;.join(chr(b) for b in original_data)print(&quot;完整的Flag:&quot;, flag)print(&quot;Flag长度:&quot;, len(flag))

完整的Flag: LILCTF{ez_arm_asm_meow_meow_meowm_oe_wemwom_oe}wFlag长度: 48
提交不上，猜了一下，最后试了试这个
LILCTF{ez_arm_asm_meow_meow_meow_meow_meow_meow}
提交成功
]]></content>
      <categories>
        <category>CTF</category>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>2025Lilctf(Crypto)</title>
    <url>/2025/08/15/2025Lilctf(Crypto)/</url>
    <content><![CDATA[2025Lilctf(Crypto)1.ez_math原题：
from sage.all import *from Crypto.Util.number import *flag = b&#x27;LILCTF&#123;test_flag&#125;&#x27;[7:-1]lambda1 = bytes_to_long(flag[:len(flag)//2])lambda2 = bytes_to_long(flag[len(flag)//2:])p = getPrime(512)def mul(vector, c):    return [vector[0]*c, vector[1]*c]v1 = [getPrime(128), getPrime(128)]v2 = [getPrime(128), getPrime(128)]A = matrix(GF(p), [v1, v2])B = matrix(GF(p), [mul(v1,lambda1), mul(v2,lambda2)])C = A.inverse() * Bprint(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;C = &#123;str(C).replace(&quot; &quot;, &quot;,&quot;).replace(&quot;\n&quot;, &quot;,&quot;).replace(&quot;[,&quot;, &quot;[&quot;)&#125;&#x27;)# p = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161# C = [7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645,7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801],[7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808,2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872]

根据矩阵求flag，跟moe那个有点像

from sage.all import *from Crypto.Util.number import long_to_bytes# 已知的p和C矩阵元素p = 9620154777088870694266521670168986508003314866222315790126552504304846236696183733266828489404860276326158191906907396234236947215466295418632056113826161c11 = 7062910478232783138765983170626687981202937184255408287607971780139482616525215270216675887321965798418829038273232695370210503086491228434856538620699645c12 = 7096268905956462643320137667780334763649635657732499491108171622164208662688609295607684620630301031789132814209784948222802930089030287484015336757787801c21 = 7341430053606172329602911405905754386729224669425325419124733847060694853483825396200841609125574923525535532184467150746385826443392039086079562905059808c22 = 2557244298856087555500538499542298526800377681966907502518580724165363620170968463050152602083665991230143669519866828587671059318627542153367879596260872# 在GF(p)域上进行计算F = GF(p)c11 = F(c11)c12 = F(c12)c21 = F(c21)c22 = F(c22)# 计算特征方程的系数sum_c = c11 + c22product_c = c11 * c22 - c12 * c21# 计算判别式和平方根D = sum_c^2 - 4 * product_csqrt_D = D.sqrt()# 计算2的逆元inv2 = F(2)^-1# 求解特征值（λ₁和λ₂）lambda1 = int((sum_c + sqrt_D) * inv2)lambda2 = int((sum_c - sqrt_D) * inv2)# 转换为字节part1 = long_to_bytes(lambda1)part2 = long_to_bytes(lambda2)# 生成可能的flag（两种组合，因为λ₁和λ₂可能顺序互换）flag1 = b&#x27;LILCTF&#123;&#x27; + part1 + part2 + b&#x27;&#125;&#x27;flag2 = b&#x27;LILCTF&#123;&#x27; + part2 + part1 + b&#x27;&#125;&#x27;print(&quot;可能的flag1:&quot;, flag1)print(&quot;可能的flag2:&quot;, flag2)

可能的flag1: b’LILCTF{It_w4s_the_be5t_of_times_1t_wa5_the_w0rst_of_t1me5}’可能的flag2: b’LILCTF{1t_wa5_the_w0rst_of_t1me5It_w4s_the_be5t_of_times_}’
2.linear原题：
import osimport randomimport signalsignal.alarm(10)flag = os.getenv(&quot;LILCTF_FLAG&quot;, &quot;LILCTF&#123;default&#125;&quot;)nrows = 16ncols = 32A = [[random.randint(1, 1919810) for _ in range(ncols)] for _ in range(nrows)]x = [random.randint(1, 114514) for _ in range(ncols)]b = [sum(A[i][j] * x[j] for j in range(ncols)) for i in range(nrows)]print(A)print(b)xx = list(map(int, input(&quot;Enter your solution: &quot;).strip().split()))if xx != x:    print(&quot;Oh, your linear algebra needs to be practiced.&quot;)else:    print(&quot;Bravo! Here is your flag:&quot;)    print(flag)

比较简单的一个线性代数题，但是一般求出来的结果好像不准确，那么我们可以使用格基来求解，问题是要求是10s限制比较麻烦，因为我不会在sagemath连端口，所以就用vscode连接端口，使用sagemath出x，这样的话再复制到交互端口就好了
sagemath：
# 读取文本数据with open(&quot;E:/edge下载/CTF/2025LilCTF/Crypto/problem_data.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as file:    data = file.read()# 假设数据的格式是类似于JSON或Python列表的结构# 你可以手动解析文件内容，假设数据格式是这样的：# A = [[...], [...], ...] 和 b = [...], 你可以使用eval()或json.loads()来解析import ast# 假设 data 中有 A 和 b 的定义A = ast.literal_eval(data.split(&quot;A = &quot;)[1].split(&quot;b = &quot;)[0].strip())  # 提取并解析Ab = ast.literal_eval(data.split(&quot;b = &quot;)[1].strip())  # 提取并解析b# 之后使用这些数据进行计算n = 32  # 变量数m = 16  # 方程数W = 2**40  # 权重# 构造格基矩阵M = matrix(ZZ, n+1, n+m)for i in range(n):    M[i, i] = 1    for j in range(m):        M[i, n+j] = A[j][i] * W  # 注意：A是16行32列，所以A[j][i]是第j行第i列for j in range(m):    M[n, n+j] = b[j] * W# LLL约简（使用更快参数）M_lll = M.LLL(delta=0.99, eta=0.51)# 寻找解solution = Nonefor i in range(n+1):    # 检查后m个分量是否全为0    if all(M_lll[i, n+j] == 0 for j in range(m)):        x_sol = [abs(int(M_lll[i, j])) for j in range(n)]        # 将解限制在[1,114514]范围内        x_sol = [max(1, min(x, 114514)) for x in x_sol]        solution = x_sol        break# 如果LLL未找到解，使用伪逆作为备选if solution is None:    print(&quot;LLL未找到解，使用伪逆法...&quot;)    A_np = matrix(RDF, A)    b_np = vector(RDF, b)    x_float = A_np.pseudoinverse() * b_np    solution = [int(round(num)) for num in x_float]    solution = [max(1, min(x, 114514)) for x in solution]# 打印解（复制这个到client.py）print(&quot;\n&quot; + &quot;=&quot;*80)print(&quot;解x (复制这个到client.py):&quot;)print(&quot; &quot;.join(map(str, solution)))print(&quot;=&quot;*80)# 验证解（可选）b_calculated = [sum(A[i][j] * solution[j] for j in range(n)) for i in range(m)]if b_calculated == b:    print(&quot;验证成功: Ax = b&quot;)else:    print(&quot;验证失败: Ax ≠ b&quot;)    print(f&quot;原始b: &#123;b&#125;&quot;)    print(f&quot;计算b: &#123;b_calculated&#125;&quot;)

vscode
from pwn import *import timeimport osdef main():    # 连接到服务器    io = remote(&quot;challenge.xinshi.fun&quot;, 46755)        # 接收数据直到出现输入提示    data = b&quot;&quot;    start_time = time.time()    while b&quot;Enter your solution:&quot; not in data:        chunk = io.recv(1024)        if not chunk:            break        data += chunk                # 超时检查        if time.time() - start_time &gt; 15:            print(&quot;Timeout waiting for data!&quot;)            io.close()            return        # 提取并保存矩阵A和向量b    A_start = data.find(b&quot;[[&quot;)    A_end = data.find(b&quot;]]&quot;) + 2    b_start = data.find(b&quot;[&quot;, A_end)    b_end = data.find(b&quot;]&quot;, b_start) + 1        A_str = data[A_start:A_end].decode()    b_str = data[b_start:b_end].decode()        # 保存到文件    with open(&quot;problem_data.txt&quot;, &quot;w&quot;) as f:        f.write(f&quot;A = &#123;A_str&#125;\n&quot;)        f.write(f&quot;b = &#123;b_str&#125;\n&quot;)        print(&quot;问题数据已保存到 problem_data.txt&quot;)    print(&quot;请立即运行SageMath脚本计算解...&quot;)        # 等待用户粘贴解    print(&quot;\n计算完成后，将解x粘贴在这里（空格分隔的32个整数）&quot;)    print(&quot;注意：您有10秒时间完成计算！&quot;)    xx = input(&quot;&gt;&gt;&gt; &quot;).strip()        # 提交解    io.sendline(xx.encode())        # 获取结果    try:        result = io.recvall(timeout=5).decode()        print(&quot;\nServer response:&quot;)        print(result)    except:        print(&quot;\nTimeout waiting for server response&quot;)        io.close()if __name__ == &quot;__main__&quot;:    main()


flag：     LILCTF{60b2bfea-b0f7-4aed-9c94-b2301afd828f}
3.mid_math原题：
from sage.all import *from Crypto.Util.number import *from tqdm import tqdmfrom random import randintfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padflag = b&#x27;LILCTF&#123;test_flag&#125;&#x27;p = getPrime(64)P = GF(p)key = randint(2**62, p)def mul(vector, c):    return [vector[0]*c, vector[1]*c, vector[2]*c, vector[3]*c, vector[4]*c]v1 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v2 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v3 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v4 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]v5 = [getPrime(64), getPrime(64), getPrime(64), getPrime(64), getPrime(64)]a, b, c, d, e = getPrime(64), getPrime(64), getPrime(64), getPrime(64),  0A = matrix(P, [v1, v2, v3, v4, v5])B = matrix(P, [mul(v1,a), mul(v2,b), mul(v3, c), mul(v4, d), mul(v5, e)])C = A.inverse() * BD = C**keykey = pad(long_to_bytes(key), 16)aes = AES.new(key,AES.MODE_ECB)msg = aes.encrypt(pad(flag, 64))print(f&quot;p = &#123;p&#125;&quot;)print(f&#x27;C = &#123;[i for i in C]&#125;&#x27;.replace(&#x27;(&#x27;, &#x27;[&#x27;).replace(&#x27;)&#x27;, &#x27;]&#x27;))print(f&#x27;D = &#123;[i for i in D]&#125;&#x27;.replace(&#x27;(&#x27;, &#x27;[&#x27;).replace(&#x27;)&#x27;, &#x27;]&#x27;))print(f&quot;msg = &#123;msg&#125;&quot;)#p = 14668080038311483271#C = [[11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212], [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914], [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670], [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413], [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707]]#D = [[1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044], [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372], [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427], [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551], [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395]]#msg = b&quot;\xcc]B:\xe8\xbc\x91\xe2\x93\xaa\x88\x17\xc4\xe5\x97\x87@\x0fd\xb5p\x81\x1e\x98,Z\xe1n`\xaf\xe0%:\xb7\x8aD\x03\xd2Wu5\xcd\xc4#m&#x27;\xa7\xa4\x80\x0b\xf7\xda8\x1b\x82k#\xc1gP\xbd/\xb5j&quot;



由于 D = C ** key，我们可以利用矩阵的特征值（eigenvalues）来恢复 key：

计算 C 和 D 的特征值：
C 的特征值 eigC 包含 0 和 4 个非零值。
D 的特征值 eigD 包含 0 和 eigC 的非零值的 key 次幂。


过滤掉 0，得到非零特征值：
L1 = [x for x in eigC if x != 0]
L2 = [x for x in eigD if x != 0]


通过离散对数恢复 key：
对 L1 和 L2 中的每一对 (x, y)，解 y = x ** key mod p。
由于 key 的范围是 [2^62, p]，解出的 k 必须满足这个范围。


验证 key：
检查是否 &#123;x ** key for x in L1&#125; == set(L2)。


解密 msg：
将 key 转为字节，填充到16字节，用AES-ECB解密 msg



ai拷打两下就梭出来了
from sage.all import *from Crypto.Util.number import *from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpad  # Import pad and unpad# Given datap = 14668080038311483271C_list = [    [11315841881544731102, 2283439871732792326, 6800685968958241983, 6426158106328779372, 9681186993951502212],    [4729583429936371197, 9934441408437898498, 12454838789798706101, 1137624354220162514, 8961427323294527914],    [12212265161975165517, 8264257544674837561, 10531819068765930248, 4088354401871232602, 14653951889442072670],    [6045978019175462652, 11202714988272207073, 13562937263226951112, 6648446245634067896, 13902820281072641413],    [1046075193917103481, 3617988773170202613, 3590111338369894405, 2646640112163975771, 5966864698750134707]]D_list = [    [1785348659555163021, 3612773974290420260, 8587341808081935796, 4393730037042586815, 10490463205723658044],    [10457678631610076741, 1645527195687648140, 13013316081830726847, 12925223531522879912, 5478687620744215372],    [9878636900393157276, 13274969755872629366, 3231582918568068174, 7045188483430589163, 5126509884591016427],    [4914941908205759200, 7480989013464904670, 5860406622199128154, 8016615177615097542, 13266674393818320551],    [3005316032591310201, 6624508725257625760, 7972954954270186094, 5331046349070112118, 6127026494304272395]]msg = b&quot;\xcc]B:\xe8\xbc\x91\xe2\x93\xaa\x88\x17\xc4\xe5\x97\x87@\x0fd\xb5p\x81\x1e\x98,Z\xe1n`\xaf\xe0%:\xb7\x8aD\x03\xd2Wu5\xcd\xc4#m&#x27;\xa7\xa4\x80\x0b\xf7\xda8\x1b\x82k#\xc1gP\xbd/\xb5j&quot;# Set up finite field and matricesF = GF(p)C = matrix(F, C_list)D = matrix(F, D_list)# Compute eigenvalueseigC = C.eigenvalues()eigD = D.eigenvalues()# Remove zero eigenvalues (one for each matrix)L1 = [x for x in eigC if x != F(0)]L2 = [x for x in eigD if x != F(0)]if len(L1) != 4 or len(L2) != 4:    print(&quot;Error: Expected 4 non-zero eigenvalues for both matrices.&quot;)    exit(1)# Find key by matching eigenvalues via discrete logarithmkey_candidate = Nonefor i in range(4):    x0 = L1[i]    for j in range(4):        y0 = L2[j]        try:            k0 = discrete_log(y0, x0)  # Solve y0 = x0^k0 mod p            candidates = []            # Check if k0 is in the valid range            if 2**62 &lt;= k0 &lt;= p:                candidates.append(k0)            # If k0 is too small, try k0 + order of x0            if k0 &lt; 2**62:                ord_val = x0.multiplicative_order()                k1 = k0 + ord_val                if 2**62 &lt;= k1 &lt;= p:                    candidates.append(k1)            # Verify candidate keys            for k_cand in candidates:                S = set(x**k_cand for x in L1)                if S == set(L2):                    key_candidate = k_cand                    print(f&quot;Found key: &#123;key_candidate&#125;&quot;)                    break            if key_candidate is not None:                break        except Exception as e:            continue    if key_candidate is not None:        breakif key_candidate is None:    print(&quot;Failed to find key.&quot;)    exit(1)# Decrypt the message using the recovered keykey_bytes = long_to_bytes(key_candidate)# Pad the key to 16 bytes for AESkey_padded = pad(key_bytes, 16)  # Now pad is importedaes = AES.new(key_padded, AES.MODE_ECB)flag_padded = aes.decrypt(msg)flag = unpad(flag_padded, 64)  # Original padding was 64 bytesprint(f&quot;Flag: &#123;flag.decode()&#125;&quot;)

 key: 5273966641785501202
flag：LILCTF{Are_y0u_5till_4wake_que5t1on_m4ker!}
4.Space Travel原题：
from Crypto.Cipher import AESfrom hashlib import md5from params import vecsfrom os import urandomkey = int(&quot;&quot;.join([vecs[int.from_bytes(urandom(2)) &amp; 0xfff] for _ in range(50)]), 2)print(&quot;🎁 :&quot;, [[nonce := int(urandom(50*2).hex(), 16), (bin(nonce &amp; key).count(&quot;1&quot;)) % 2] for _ in range(600)])print(&quot;🚩 :&quot;, AES.new(key=md5(str(key).encode()).digest(), nonce=b&quot;Tiffany&quot;, mode=AES.MODE_CTR).encrypt(open(&quot;flag.txt&quot;, &quot;rb&quot;).read()))

1.题面逻辑（来自 task.py）

先从 params.py 里的 vecs（4096 个 16 位二进制串）中，用 12 位随机索引各取 50 次，拼成 50×16 &#x3D; 800 位的二进制串，作为大整数 key。
接着生成 600 组样本：每组里有一个 800 位随机数 nonce，以及一个比特 parity，它等于 bin(nonce &amp; key) 中 1 的个数的奇偶（即 (nonce · key) mod 2 的内积）。
最后用 md5(str(key)) 作为 AES-CTR 的 key，nonce 固定为 &quot;Tiffany&quot;，加密出密文 🚩。

2.观测与困难

600 组样本提供了 600 条线性方程（GF(2) 上的内积），但未知量 key 有 800 个比特，直接解有 200 维自由度，不唯一。
关键是 key 的结构：它是 50 个 16 位小块的串联，每块都来自 vecs。而 vecs 的 4096 项，其差分集合（取任意一个基准 v0，看 vecs ⊕ v0 的行空间）维度是 12。这意味着 vecs 其实是一个 12 维线性子空间的仿射陪集（coset），大小正好 2^12&#x3D;4096。
于是每个 16 位小块都可表示为 v0 ⊕ (B * α)，其中 B 是 12×16 的基矩阵，α 是 12 比特坐标。
50 个小块 → 一共 50×12 &#x3D; 600 个未知比特。
与 600 条线性方程正好匹配！从而把原本 800 维未知，降成 600 维，得到可解的线性系统。



3.建模方式（对齐 bit 顺序很重要！）

把 vecs 的 16 位字符串视作 LSB-first（与 (nonce &amp; key) 的位对齐一致），否则会解出错误的 key。
设第 t 个小块的未知 12 比特为 α_t。对每条样本方程，有
parity_i = ⊕_t &lt;nonce_chunk_i_t, v0 ⊕ (B * α_t)&gt; ``         = ⊕_t &lt;nonce_chunk_i_t, v0&gt; ⊕ ⊕_t &lt;nonce_chunk_i_t, B * α_t&gt;
把常量项 ⊕_t &lt;nonce_chunk_i_t, v0&gt; 移到右边，剩余是关于所有 α_t 的 600×600 线性方程组，直接在 GF(2) 解之即可。
方程组秩通常是 599（有 1 维自由度），但这 不影响：任意解出的 (α_t) 都映射到 v0 ⊕ B*α_t，这个集合刚好就是 vecs 的那个仿射陪集，不会跑出集合之外。对那 1 维自由度，测试两种可能都很快，直接看哪一个能把密文正确解出可读明文（一般是标准 CTF flag）。

4.解出 key 并还原明文

用解出来的 50 个 16 位小块拼成 800 位 key（注意保持 LSB-first 与构造一致）。
取 md5(str(key))（Python 的 str(key) 即十进制串）当 AES-CTR key，nonce 用 b&quot;Tiffany&quot;，解密 🚩。
能得到清晰的 ASCII flag。

import re, ast, numpy as np, hashlibfrom Crypto.Cipher import AES# ---- 工具：GF(2) 线性代数 ----def gf2_rref(M, rhs=None):    M = M.copy().astype(np.uint8)    if rhs is not None:        rhs = rhs.copy().astype(np.uint8)        M = np.concatenate([M, rhs.reshape(-1,1)], axis=1)    m, n_aug = M.shape    n = n_aug if rhs is None else n_aug - 1    row = 0    pivots = []    for col in range(n):        pivot = None        for r in range(row, m):            if M[r,col]:                pivot = r; break        if pivot is None:            continue        if pivot != row:            M[[row,pivot]] = M[[pivot,row]]        for r in range(m):            if r != row and M[r,col]:                M[r,:] ^= M[row,:]        pivots.append(col)        row += 1        if row == m: break    return M, pivotsdef int_to_bits_lsb(n, width):    return np.array([(n&gt;&gt;i) &amp; 1 for i in range(width)], dtype=np.uint8)def bits_to_int(bits_lsb):    v = 0    for i,b in enumerate(bits_lsb):        if b: v |= (1&lt;&lt;i)    return v# ---- 读取 vecs（params.py）并转为 LSB-first ----with open(&#x27;params.py&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:    text = f.read()vecs_list = re.findall(r&quot;&#x27;([01]&#123;16&#125;)&#x27;&quot;, text)vecs = np.array([[int(b) for b in s[::-1]] for s in vecs_list], dtype=np.uint8)  # reverse to LSB-first# 取一个基向量 v0，并构造差分集合的行空间基 B（12×16）v0 = vecs[0]diffs = (vecs ^ v0) % 2def gf2_basis_rows(M):    A = M.copy().astype(np.uint8)    m,n = A.shape    row=0    pivcols=[]    for col in range(n):        pivot=None        for r in range(row,m):            if A[r,col]:                pivot=r; break        if pivot is None: continue        if pivot!=row: A[[row,pivot]] = A[[pivot,row]]        for r in range(m):            if r!=row and A[r,col]:                A[r,:] ^= A[row,:]        pivcols.append(col); row+=1        if row==m: break    # 抽取基行    basis_rows=[]    used=set()    for lead in pivcols:        for r in range(m):            if r in used: continue            if A[r,lead]==1 and all(A[r,c]==0 for c in range(lead)):                basis_rows.append(A[r].copy()); used.add(r); break    return np.array(basis_rows, dtype=np.uint8)B = gf2_basis_rows(diffs)   # 12 x 16# ---- 解析样本和密文（output.txt）----with open(&#x27;output.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:    data = f.read()gift_text = re.search(r&quot;🎁\s*:\s*(\[\[.*?\]\])&quot;, data, flags=re.S).group(1)cipher_text_literal = re.search(r&quot;🚩\s*:\s*(b?[&#x27;\&quot;][^&#x27;\&quot;]+[&#x27;\&quot;])|🚩\s*:\s*([0-9a-fA-Fx,\s\[\]]+)&quot;, data).group(1) \                      or re.search(r&quot;🚩\s*:\s*(b?[&#x27;\&quot;][^&#x27;\&quot;]+[&#x27;\&quot;])|🚩\s*:\s*([0-9a-fA-Fx,\s\[\]]+)&quot;, data).group(2)gift = ast.literal_eval(gift_text)cipher_literal = ast.literal_eval(cipher_text_literal)if isinstance(cipher_literal, bytes):    ct = cipher_literalelif isinstance(cipher_literal, list):    ct = bytes(cipher_literal)elif isinstance(cipher_literal, str):    ct = bytes.fromhex(cipher_literal)else:    raise RuntimeError(&quot;Unknown ciphertext!&quot;)# ---- 建立 600×600 线性方程组，未知为 50 个块的 12 比特坐标 ----m = len(gift)T = 50k = B.shape[0]  # 12WIDTH = 16*TA2 = np.zeros((m, T*k), dtype=np.uint8)b2 = np.zeros(m, dtype=np.uint8)for i,(nonce, par) in enumerate(gift):    bits = int_to_bits_lsb(nonce, WIDTH)    const = 0    for t in range(T):        chunk = bits[16*t:16*(t+1)]        const ^= (np.dot(chunk, v0) % 2)        # 对 α_t（12 维），其系数即 &lt;chunk, B_row&gt;，等价于 (B @ chunk)        A2[i, t*k:(t+1)*k] = (B @ chunk) % 2    b2[i] = (par ^ const) % 2# ---- 解方程（可能秩 599，尝试两个候选）----rref_A2, pivs = gf2_rref(A2, b2)nvar = A2.shape[1]x_alpha = np.zeros(nvar, dtype=np.uint8)row=0for col in range(nvar):    if row &lt; len(pivs) and pivs[row]==col:        x_alpha[col] = rref_A2[row,-1]; row+=1rrefA_only, pivs_only = gf2_rref(A2, None)null = np.zeros(nvar, dtype=np.uint8)if len(pivs_only) &lt; nvar:    fcol = [c for c in range(nvar) if c not in pivs_only][0]    null[fcol]=1    row=0    for col in range(nvar):        if row &lt; len(pivs_only) and pivs_only[row]==col:            s=0            for kcol in range(col+1, nvar):                if rrefA_only[row,kcol] and null[kcol]:                    s ^= 1            null[col]=s%2            row+=1def build_key_bits(alpha_concat):    blocks=[]    for t in range(T):        alpha_t = alpha_concat[t*k:(t+1)*k]        vec_t = (v0 ^ (alpha_t @ B) % 2) % 2  # LSB-first 16 bits        blocks.append(vec_t)    return np.concatenate(blocks)cands = [x_alpha, (x_alpha ^ null) % 2]for cand in cands:    key_bits = build_key_bits(cand)    key_int = bits_to_int(key_bits)    aes_key = hashlib.md5(str(key_int).encode()).digest()    cipher = AES.new(key=aes_key, nonce=b&quot;Tiffany&quot;, mode=AES.MODE_CTR)    pt = cipher.decrypt(ct)    try:        s = pt.decode(&#x27;utf-8&#x27;)        if &quot;&#123;&quot; in s and &quot;&#125;&quot; in s:            print(&quot;FLAG:&quot;, s)            break    except:        pass

flag： LILCTF{Un1qUe_s0luti0n_1N_sUbSp4C3!}
5.baaaaaag原题：
from Crypto.Util.number import *import randomfrom Crypto.Cipher import AESimport hashlibfrom Crypto.Util.Padding import padfrom secret import flagp = random.getrandbits(72)assert len(bin(p)[2:]) == 72a = [getPrime(90) for _ in range(72)]b = 0t = pfor i in a:    temp = t % 2    b += temp * i    t = t &gt;&gt; 1key = hashlib.sha256(str(p).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)flag = pad(flag,16)ciphertext = cipher.encrypt(flag)print(f&#x27;a = &#123;a&#125;&#x27;)print(f&#x27;b = &#123;b&#125;&#x27;)print(f&quot;ciphertext = &#123;ciphertext&#125;&quot;)&#x27;&#x27;&#x27;a = [965032030645819473226880279, 699680391768891665598556373, 1022177754214744901247677527, 680767714574395595448529297, 1051144590442830830160656147, 1168660688736302219798380151, 796387349856554292443995049, 740579849809188939723024937, 940772121362440582976978071, 787438752754751885229607747, 1057710371763143522769262019, 792170184324681833710987771, 912844392679297386754386581, 906787506373115208506221831, 1073356067972226734803331711, 1230248891920689478236428803, 713426848479513005774497331, 979527247256538239116435051, 979496765566798546828265437, 836939515442243300252499479, 1185281999050646451167583269, 673490198827213717568519179, 776378201435505605316348517, 809920773352200236442451667, 1032450692535471534282750757, 1116346000400545215913754039, 1147788846283552769049123803, 994439464049503065517009393, 825645323767262265006257537, 1076742721724413264636318241, 731782018659142904179016783, 656162889354758353371699131, 1045520414263498704019552571, 1213714972395170583781976983, 949950729999198576080781001, 1150032993579134750099465519, 975992662970919388672800773, 1129148699796142943831843099, 898871798141537568624106939, 997718314505250470787513281, 631543452089232890507925619, 831335899173370929279633943, 1186748765521175593031174791, 884252194903912680865071301, 1016020417916761281986717467, 896205582917201847609656147, 959440423632738884107086307, 993368100536690520995612807, 702602277993849887546504851, 1102807438605649402749034481, 629539427333081638691538089, 887663258680338594196147387, 1001965883259152684661493409, 1043811683483962480162133633, 938713759383186904819771339, 1023699641268310599371568653, 784025822858960757703945309, 986182634512707587971047731, 1064739425741411525721437119, 1209428051066908071290286953, 667510673843333963641751177, 642828919542760339851273551, 1086628537309368288204342599, 1084848944960506663668298859, 667827295200373631038775959, 752634137348312783761723507, 707994297795744761368888949, 747998982630688589828284363, 710184791175333909291593189, 651183930154725716807946709, 724836607223400074343868079, 1118993538091590299721647899]b = 34962396275078207988771864327ciphertext = b&#x27;Lo~G\xf46&gt;\xd609\x8e\x8e\xf5\xf83\xb5\xf0\x8f\x9f6&amp;\xea\x02\xfa\xb1_L\x85\x93\x93\xf7,`|\xc6\xbe\x05&amp;\x85\x8bC\xcd\xe6?TV4q&#x27;&#x27;&#x27;&#x27;

一个背包密码，解出p就能梭出来了。但是问题是怎么解出p：
据我已知的背包密码：b是背包容量，a是将要装进背包的物品。p可以由十进制转化为二进制，其中满足a[i],pi。pi只能为0或1,0代表对应的a[i]没有被装进背包，1代表对应的a[i]被装进背包。b会被a装满。
大概是这个意思，但是列数学表达式得出p的二进制需要线性代数知识。lll算法和bkz规约
这是deepseek给出的详细：
如何解出 p？为了解决这个问题，我们使用格基归约算法（如 LLL 或 BKZ）。格基归约可以将子集和问题转化为寻找格中的短向量问题。具体步骤如下：

格基构造：构造一个 (n+1) x (n+1) 的矩阵（n 是 a 的长度），其中：

前 n 行：对角线元素为 2，最后一列为 a[i]。
最后一行：前 n 个元素为 1，最后一个元素为 b。

这种构造确保了解向量 (2*m_0 - 1, 2*m_1 - 1, ..., 2*m_&#123;n-1&#125; - 1, 0) 在格中，其中 m_i 是 p 的二进制位。转换 v_i = 2*m_i - 1 将二进制位映射到 ±1，使得解向量更短且更易识别。

格基归约：使用 BKZ 或 LLL 算法对格基进行归约。BKZ 通常更强（能找到更短的向量），但计算成本更高。如果 BKZ 失败，可以回退到 LLL。

搜索解向量：在归约后的基中搜索满足条件的向量：

前 n 个坐标为 ±1。
最后一个坐标为 0（或接近 0，容错处理）。

如果找到，则从解向量恢复二进制位：m_i = (v_i + 1) / 2。

恢复 p：将二进制位组合成整数 p（注意：最低位对应 m_0）。


from sage.all import Matrix, ZZ# --------- 已知参数 ----------a = [965032030645819473226880279, 699680391768891665598556373, 1022177754214744901247677527, 680767714574395595448529297,     1051144590442830830160656147, 1168660688736302219798380151, 796387349856554292443995049, 740579849809188939723024937,     940772121362440582976978071, 787438752754751885229607747, 1057710371763143522769262019, 792170184324681833710987771,     912844392679297386754386581, 906787506373115208506221831, 1073356067972226734803331711, 1230248891920689478236428803,     713426848479513005774497331, 979527247256538239116435051, 979496765566798546828265437, 836939515442243300252499479,     1185281999050646451167583269, 673490198827213717568519179, 776378201435505605316348517, 809920773352200236442451667,     1032450692535471534282750757, 1116346000400545215913754039, 1147788846283552769049123803, 994439464049503065517009393,     825645323767262265006257537, 1076742721724413264636318241, 731782018659142904179016783, 656162889354758353371699131,     1045520414263498704019552571, 1213714972395170583781976983, 949950729999198576080781001, 1150032993579134750099465519,     975992662970919388672800773, 1129148699796142943831843099, 898871798141537568624106939, 997718314505250470787513281,     631543452089232890507925619, 831335899173370929279633943, 1186748765521175593031174791, 884252194903912680865071301,     1016020417916761281986717467, 896205582917201847609656147, 959440423632738884107086307, 993368100536690520995612807,     702602277993849887546504851, 1102807438605649402749034481, 629539427333081638691538089, 887663258680338594196147387,     1001965883259152684661493409, 1043811683483962480162133633, 938713759383186904819771339, 1023699641268310599371568653,     784025822858960757703945309, 986182634512707587971047731, 1064739425741411525721437119, 1209428051066908071290286953,     667510673843333963641751177, 642828919542760339851273551, 1086628537309368288204342599, 1084848944960506663668298859,     667827295200373631038775959, 752634137348312783761723507, 707994297795744761368888949, 747998982630688589828284363,     710184791175333909291593189, 651183930154725716807946709, 724836607223400074343868079, 1118993538091590299721647899]b = 34962396275078207988771864327ciphertext = b&#x27;Lo~G\xf46&gt;\xd609\x8e\x8e\xf5\xf83\xb5\xf0\x8f\x9f6&amp;\xea\x02\xfa\xb1_L\x85\x93\x93\xf7,`|\xc6\xbe\x05&amp;\x85\x8bC\xcd\xe6?TV4q&#x27;n = len(a)   # 72# --------- 构造格基 ----------Ge = Matrix(ZZ, n+1, n+1)for i in range(n):    Ge[i, i] = 2    Ge[i, -1] = a[i]for i in range(n):    Ge[-1, i] = 1Ge[-1, -1] = b# --------- BKZ / LLL 归约 ----------print(&quot;Running BKZ...&quot;)try:    B = Ge.BKZ(block_size=28)except Exception as e:    print(&quot;BKZ 失败，退回 LLL：&quot;, e)    B = Ge.LLL()print(&quot;Reduction done. Searching for solution vector...&quot;)found = Falsecandidate = None# 搜索解向量for row_idx in range(B.nrows()):    v = [int(B[row_idx, j]) for j in range(n+1)]    last = v[-1]    front = v[:-1]    if last == 0 and all(x in (-1, 1) for x in front):        candidate = front        found = True        print(f&quot;Found exact candidate in basis row &#123;row_idx&#125;&quot;)        breakif not found:    for row_idx in range(B.nrows()):        v = [int(B[row_idx, j]) for j in range(n+1)]        front = v[:-1]        last = v[-1]        if abs(last) &lt;= 1 and all(abs(x) in (0,1,2) for x in front):            possibly = []            ok = True            for x in front:                if x &gt;= 1:                    possibly.append(1)                elif x &lt;= -1:                    possibly.append(-1)                else:                    ok = False                    break            if ok:                candidate = possibly                found = True                print(f&quot;Found tolerant candidate in basis row &#123;row_idx&#125; (last=&#123;last&#125;)&quot;)                breakif not found:    print(&quot;没有在基中直接找到满足 (±1,...,0) 形式的向量。&quot;)    print(&quot;你可以：\n - 提高 BKZ 的 block_size（更强但更慢），\n - 或尝试搜索基向量的短线性组合 / 使用 fpylll 的 shortest_vector.&quot;)    exit(1)# 恢复 pm_bits = [(x + 1) // 2 for x in candidate]p_recovered = 0for i, bit in enumerate(m_bits):    p_recovered |= (bit &lt;&lt; i)print(&quot;Recovered p (decimal):&quot;, p_recovered)print(&quot;Recovered p (bin length):&quot;, len(bin(p_recovered)) - 2)

Running BKZ…Reduction done. Searching for solution vector…Found exact candidate in basis row 0Recovered p (decimal): 4208626653103825685156Recovered p (bin length): 72
from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadimport hashlibciphertext=b&#x27;Lo~G\xf46&gt;\xd609\x8e\x8e\xf5\xf83\xb5\xf0\x8f\x9f6&amp;\xea\x02\xfa\xb1_L\x85\x93\x93\xf7,`|\xc6\xbe\x05&amp;\x85\x8bC\xcd\xe6?TV4q&#x27;p_recovered=4208626653103825685156key = hashlib.sha256(str(p_recovered).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)try:    plaintext = unpad(cipher.decrypt(ciphertext), 16)except ValueError:    plaintext = cipher.decrypt(ciphertext)    print(&quot;Warning: unpad failed; raw decrypted bytes shown.&quot;)print(&quot;Decrypted plaintext (bytes):&quot;, plaintext)try:    print(&quot;Decrypted plaintext (utf-8):&quot;, plaintext.decode())except Exception:    pass

Decrypted plaintext (bytes): b’LILCTF{M4ybe_7he_brut3_f0rce_1s_be5t}’Decrypted plaintext (utf-8): LILCTF{M4ybe_7he_brut3_f0rce_1s_be5t}
]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>2025天机学堂</title>
    <url>/2025/08/11/2025%E5%A4%A9%E6%9C%BA%E5%AD%A6%E5%A0%82/</url>
    <content><![CDATA[2025天机学堂day01：初始化项目虚拟机密码：root      123321
192.168.150.101 git.tianji.com  tjxt  123321192.168.150.101 jenkins.tianji.com    root  123192.168.150.101 mq.tianji.com    tjxt  123321192.168.150.101 nacos.tianji.com      nacos   nacos192.168.150.101 xxljob.tianji.com192.168.150.101 es.tianji.com192.168.150.101 api.tianji.com192.168.150.101 www.tianji.com      jack  123   Rose  123456192.168.150.101 manage.tianji.com192.168.150.101 cpolar.tianji.com





点击init初始化虚拟机：
在VMware得到：

然后初始化网络配置，改成这样：

启动虚拟机，虚拟机中的环境会自启动，我们可以访问一个进行测试，访问是要访问我画红框的url：192.168.150.101:8848

然后我们也可以使用switchhost来代理，具体可以看我switchhost的文章
nginx无法启动问题，尝试重启进行解决：解决失败，但最后耗时四小时左右解决了，问题在于nginx的conf的语法问题，大概改成这样就好了：

然后复制初始化项目到本地：
http://192.168.150.101:10880/tjxt/tianji.git
git clone http://192.168.150.101:10880/tjxt/tianji.git -b lesson-init

然后打开项目刷新一下maven下下依赖就好了
遇到bug：

解决了一下午，到最后还是依赖问题：把这个注释的# 删掉

查找bug，Rose删除订单时显示不能删除他人订单
想远程调试，改成这样：

然后关掉tj-trade，启动tj-trade-debug
当然也可以直接本地调试，但是注意调试前编辑配置改为local

回到bug问题，将&#x3D;改成equals或者&#x3D;&#x3D;就好了
然后推送到本地的git就好了
day02：我的课表导入domain和enums然后下载mybatisplus插件然后连接：
jdbc:mysql:&#x2F;&#x2F;localhost:192.168.150.101:3306&#x2F;tj_learning?useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC
但是遇到问题：

还没解决，因为我数据库能连上但是这个插件连不上，所以暂时没管还能继续学下去
然后写那个课程弄到我的课表的代码，这就不复制了，比较简单
然后进行测试，他会显示报名失败，因为数据库数据太老了，你自己改一下时间就能报名成功了
然后第二个是分页查询课表，也是不难，但是别忘了在请求头中加user-info，要不然会报401
第三个查询正在学习的课程也是一样
课后作业我直接搬了
但是day02有个问题，没有解决：

但是后端接口正常使用，我就没管他
day03学习计划和进度写完代码后出现bug：

然后发现是serviceImpl忘加service注解了，加了就能解决了
遇到了问题：

这是数据库建表的问题，但感觉修改太麻烦了，我不改了。代码本身没问题
另外还是前端问题，导致数据没回显但是接口测试没问题
day3基本是水过去的
day04高并发优化u1s1面对高并发你会怎么办？hm飞书的答案：

要我说，口头表达一下大概就是：
1.存入redis后续更新数据库
2.消息队列，慢慢处理
3.限流
4.异步请求，先返回东西后进行处理  &#x2F;&#x2F;感觉和2重复了
然后就是改造代码，懒得看了，太无聊。
day05问答系统]]></content>
      <categories>
        <category>Java</category>
        <category>complete_item</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>complete_item</tag>
      </tags>
  </entry>
  <entry>
    <title>2025moectf(Crypto)</title>
    <url>/2025/08/09/2025moectf(Crypto)/</url>
    <content><![CDATA[2025moectf(Crypto)1.moectf(Crypto)#!/usr/bin/env python3from Crypto.PublicKey import ElGamalfrom Crypto.Random import get_random_bytes, randomfrom Crypto.Util.number import *from random import *from secret import flagdef generate_elgamal_keypair(bits=512):p = getPrime(bits)for _ in range(1000):g = getRandomRange(2, 5)if pow(g, (p - 1) // 2, p) != 1:breakx = randrange(2, p - 1)注:此处的secret模块可以理解为存储了明文flag的python文件，属于未知信息，而非公开的可用模块。你需要尝试从密文去恢复原始的flag，而不是去下载secret模块。secrets则是一个用于生成管理密码的安全随机数的python标准库。bytes_to_long函数用于将flag编码为整数。Hint：什么是 Elgamal还是附个链接吧Elgamaly = pow(g, x, p)return p, g, y, xkey=generate_elgamal_keypair(bits=512)p, g, y ,x= keyprint(&quot;=== 公钥 (p, g, y) ===&quot;)print(&quot;p =&quot;, p)print(&quot;g =&quot;, g)print(&quot;y =&quot;, y)print()k = randrange(1, p - 2)m = bytes_to_long(flag)c1 = pow(g, k, p)c2 = (m * pow(y, k, p)) % pprint(&quot;=== 密文 (c1, c2) ===&quot;)print(&quot;c1 =&quot;, c1)print(&quot;c2 =&quot;, c2)#不小心把x输出了()print(&quot;x =&quot;, x)&quot;&quot;&quot;=== 公钥 (p, g, y) ===p =11540963715962144951763578255357417528966715904849014985547597657698304891044841099894993117258279094910424033273299863589407477091830213468539451196239863g = 2y =8313424783366011287014623582773521595333285291380540689467073212212931648415580065207081449784135835711205324186662482526357834042013400765421925274271853=== 密文 (c1, c2) ===c1 =6652053553055645358275362259554856525976931841318251152940464543175108560132949610916012490837970851191204144757409335011811874896056430105292534244732863c2 =2314913568081526428247981719100952331444938852399031826635475971947484663418362533363591441216570597417789120470703548843342170567039399830377459228297983x =8010957078086554284020959664124784479610913596560035011951143269559761229114027738791440961864150225798049120582540951874956255115884539333966429021004214&quot;&quot;&quot;注:此处的secret模块可以理解为存储了明文flag的python文件，属于未知信息，而非公开的可用模块。你需要尝试从密文去恢复原始的flag，而不是去下载secret模块。secrets则是一个用于生成管理密码的安全随机数的python标准库。bytes_to_long函数用于将flag编码为整数。

ai可以一把梭，明个再来写解题过程：

from Crypto.Util.number import long_to_bytes# 给定的公钥和私钥p = 11540963715962144951763578255357417528966715904849014985547597657698304891044841099894993117258279094910424033273299863589407477091830213468539451196239863g = 2y = 8313424783366011287014623582773521595333285291380540689467073212212931648415580065207081449784135835711205324186662482526357834042013400765421925274271853c1 = 6652053553055645358275362259554856525976931841318251152940464543175108560132949610916012490837970851191204144757409335011811874896056430105292534244732863c2 = 2314913568081526428247981719100952331444938852399031826635475971947484663418362533363591441216570597417789120470703548843342170567039399830377459228297983x = 8010957078086554284020959664124784479610913596560035011951143269559761229114027738791440961864150225798049120582540951874956255115884539333966429021004214# 计算共享密钥 s = c1^x mod ps = pow(c1, x, p)# 计算 s 的模逆元s_inv = pow(s, -1, p)# 解密消息 m = c2 * s_inv mod pm = (c2 * s_inv) % p# 将整数转换为字节串flag = long_to_bytes(m)print(&quot;解密后的 flag:&quot;, flag.decode())

flag:   moectf{th1s_1s_y0ur_f1rst_ElG@m@l}
2.ez_DES原题：
from Crypto.Cipher import DESimport secretsimport stringflag = &#x27;moectf&#123;???&#125;&#x27;characters = string.ascii_letters + string.digits + string.punctuationkey = &#x27;ezdes&#x27;+&#x27;&#x27;.join(secrets.choice(characters) for _ in range(3))assert key[:5] == &#x27;ezdes&#x27;key = key.encode(&#x27;utf-8&#x27;)l = 8def encrypt(text, key):    cipher = DES.new(key, DES.MODE_ECB)    padded_text = text + (l - len(text) % l) * chr(len(text))    data = cipher.encrypt(padded_text.encode(&#x27;utf-8&#x27;))    return datac = encrypt(flag, key)print(&#x27;c =&#x27;, c)# c = b&#x27;\xe6\x8b0\xc8m\t?\x1d\xf6\x99sA&gt;\xce \rN\x83z\xa0\xdc&#123;\xbc\xb8X\xb2\xe2q\xa4&quot;\xfc\x07&#x27;

爆破秘钥就好，ai能一把梭：
from Crypto.Cipher import DESimport stringfrom itertools import product# 给定的密文c = b&#x27;\xe6\x8b0\xc8m\t?\x1d\xf6\x99sA&gt;\xce \rN\x83z\xa0\xdc&#123;\xbc\xb8X\xb2\xe2q\xa4&quot;\xfc\x07&#x27;# 可能的字符集characters = string.ascii_letters + string.digits + string.punctuationdef decrypt(ciphertext, key):    &quot;&quot;&quot;尝试使用给定的密钥解密，使用题目特定的填充方案&quot;&quot;&quot;    try:        cipher = DES.new(key, DES.MODE_ECB)        data = cipher.decrypt(ciphertext)                # 获取原始消息长度（填充字符的值）        msg_len = data[-1]                # 计算填充长度        pad_len = 8 - (msg_len % 8)        if pad_len == 0:  # 如果长度是8的倍数            pad_len = 8                # 验证填充是否正确        if all(byte == msg_len for byte in data[-pad_len:]):            # 移除填充并返回原始消息            return data[:-pad_len]    except:        pass    return Nonedef main():    &quot;&quot;&quot;主函数，爆破密钥并解密&quot;&quot;&quot;    # 生成所有可能的3字符组合    total = len(characters) ** 3    count = 0        print(f&quot;开始爆破 &#123;total&#125; 种可能的密钥组合...&quot;)        # 使用笛卡尔积生成所有可能的3字符后缀    for suffix in product(characters, repeat=3):        count += 1        if count % 100000 == 0:            print(f&quot;进度: &#123;count&#125;/&#123;total&#125; (&#123;count/total*100:.1f&#125;%)&quot;)                # 构建完整密钥        key_str = &#x27;ezdes&#x27; + &#x27;&#x27;.join(suffix)        key = key_str.encode(&#x27;utf-8&#x27;)                # 尝试解密        result = decrypt(c, key)                # 如果解密成功并且结果包含 moectf 标志        if result and b&#x27;moectf&#123;&#x27; in result:            print(f&quot;\n找到有效密钥: &#123;key_str&#125;&quot;)            print(f&quot;解密结果: &#123;result.decode()&#125;&quot;)            return        print(&quot;爆破完成，未找到有效密钥。尝试检查填充逻辑或密钥空间。&quot;)if __name__ == &quot;__main__&quot;:    main()

找到有效密钥: ezdes8br解密结果: moectf{_Ju5t envmEra+e.!}
3.baby_next原题：
from Crypto.Util.number import *from gmpy2 import next_primefrom functools import reducefrom secret import flagassert len(flag) == 38assert flag[:7] == b&#x27;moectf&#123;&#x27;assert flag[-1:] == b&#x27;&#125;&#x27;def main():    p = getPrime(512)    q = int(reduce(lambda res, _: next_prime(res), range(114514), p))    n = p * q    e = 65537    m = bytes_to_long(flag)    c = pow(m, e, n)    print(f&#x27;&#123;n = &#125;&#x27;)    print(f&#x27;&#123;c = &#125;&#x27;)if __name__ == &#x27;__main__&#x27;:    main()&quot;&quot;&quot;n = 96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397c = 17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967&quot;&quot;&quot;

next_prime的应用，也是爆破一下，因为数据量不大，给点描述就能一把梭了
from gmpy2 import isqrt, next_prime, mpzfrom Crypto.Util.number import long_to_bytesn = mpz(96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397)c = mpz(17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967)e = 65537def factor_n(n):    &quot;&quot;&quot;高效分解接近的素数因子&quot;&quot;&quot;    a = isqrt(n)  # 精确整数平方根        # 从平方根开始向前搜索素数作为候选p    p = next_prime(a - 10**7)  # 从稍低于平方根的位置开始        # 尝试p和p后面的114514个素数作为q    for _ in range(10000000):  # 安全范围内搜索        q = n // p                # 检查是否找到有效因子        if p * q == n:            return p, q                # 移动到下一个候选p        p = next_prime(p)        return None, Nonep, q = factor_n(n)if p and q:    phi = (p-1)*(q-1)    d = pow(e, -1, phi)    m = pow(c, d, n)    flag = long_to_bytes(int(m))    print(&quot;Flag:&quot;, flag.decode())else:    print(&quot;未找到因子&quot;)



flag：  moectf{vv0W_p_m1nu5_q_i5_r34l1y_sm4lI}
4.ez_square原题：
from Crypto.Util.number import *from secret import flagassert len(flag) == 35assert flag[:7] == b&#x27;moectf&#123;&#x27;assert flag[-1:] == b&#x27;&#125;&#x27;def main():    p = getPrime(512)    q = getPrime(512)    n = p * q    e = 65537    m = bytes_to_long(flag)    c = pow(m, e, n)    hint = pow(p + q, 2, n)    print(f&#x27;&#123;n = &#125;&#x27;)    print(f&#x27;&#123;c = &#125;&#x27;)    print(f&#x27;&#123;hint = &#125;&#x27;)if __name__ == &#x27;__main__&#x27;:    main()&quot;&quot;&quot;n = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149c = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190hint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304&quot;&quot;&quot;

rsa加密公式的考察，不难，也能一把梭
import mathfrom Crypto.Util.number import long_to_bytes# 已知参数n = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149c = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190hint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304e = 65537# 关键推导：(p+q)² = (p-q)² + 4pq，而hint = (p+q)² mod n = (p-q)² mod n# 计算s = (p+q)² = 4n + hint（因为hint = (p-q)²且小于n）s = 4 * n + hint# 求s的平方根得到p+qs_sqrt = math.isqrt(s)assert s_sqrt * s_sqrt == s, &quot;s不是完全平方数，推导错误&quot;# 求hint的平方根得到p-qd_sqrt = math.isqrt(hint)assert d_sqrt * d_sqrt == hint, &quot;hint不是完全平方数，推导错误&quot;# 计算p和qp = (s_sqrt + d_sqrt) // 2q = (s_sqrt - d_sqrt) // 2# 验证p*q是否等于nassert p * q == n, &quot;分解n失败&quot;# 计算欧拉函数φ(n)phi = (p - 1) * (q - 1)# 计算私钥d（e的逆元）d = pow(e, -1, phi)# 解密得到明文mm = pow(c, d, n)# 转换为flagflag = long_to_bytes(m)print(&quot;解密得到的flag:&quot;, flag.decode())



flag：   moectf{Ma7hm4t1c5_is_@_k1nd_0f_a2t}
5.ezlegendre原题：
from Crypto.Util.number import getPrime, bytes_to_longfrom secret import flagp = 258669765135238783146000574794031096183a = 144901483389896508632771215712413815934def encrypt_flag(flag):    ciphertext = []    plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag])    for b in plaintext:        e = getPrime(16)        d = randint(1,10)        n = pow(a+int(b)*d, e, p)        ciphertext.append(n)    return ciphertextprint(encrypt_flag(flag))

数据都给你了，直接读数据得出未知数就好了
from Crypto.Util.number import isPrimefrom tqdm import tqdm# 已知参数p = 258669765135238783146000574794031096183a = 144901483389896508632771215712413815934# 假设我们有部分密文ciphertext = [102230607782303286066661803375943337852, 196795077203291879584123548614536291210, 41820965969318717978206410470942308653, 207485265608553973031638961376379316991, 126241934830164184030184483965965358511, 20250852993510047910828861636740192486, 103669039044817273633962139070912140023, 97337342479349334554052986501856387313, 159127719377115088432849153087501377529, 45764236700940832554086668329121194445, 35275004033464216369574866255836768148, 52905563179465420745275423120979831405, 17032180473319795641143474346227445013, 29477780450507011415073117531375947096, 55487351149573346854028771906741727601, 121576510894250531063152466107000055279, 69959515052241122548546701060784004682, 173839335744520746760315021378911211216, 28266103662329817802592951699263023295, 194965730205655016437216590690038884309, 208284966254343254016582889051763066574, 137680272193449000169293006333866420934, 250634504150859449051246497912830488025, 124228075953362483108097926850143387433, 232956176229023369857830577971626577196, 149441784891021006224395235471825205661, 118758326165875568431376314508740278934, 222296215466271835013184903421917936512, 49132466023594939909761224481560782731, 406286678537520849308828749751513339, 215122152883292859254246948661946520324, 81283590250399459209567683991648438199, 150395133067480380674905743031927410663, 5710878479977467762548400320726575491, 83627753774286426170934105100463456109, 164968224377869331545649899270867630850, 241057183685774160581265732812497247167, 109136287048010096863680430193408099828, 116313129605409961931811582899075031153, 202739016625709380026000805340243458300, 25408225921774957745573142542576755590, 151336258796933656160956289529558246702, 2947189044370494063643525166023973095, 228678413963736672394976193093568181979, 40627063032321835707220414670018641024, 55446789315226949622969082042881319148, 32219108726651509070669836923591948459, 134454924722414419191920784435633637634, 97952023967728640730045857104376826039, 20659076942504417479953787092276592682, 93281761173713729777326842152860901050, 133634773495582264000160065317239987936, 79976720152435218818731114555425458470, 234654694673289327542859971371886984118, 51332273108989067644245919615090753756, 134120280423303717489979349737802826605, 182001158305920226320085758522717203725, 98408798757865562737462169470346158516, 78200435603900368619334272308272773797, 232796357836930341547987600782979821555, 589106968861493082018132081244848952, 24186003230092331554886767628744415123, 236070626491251466741246103662922841423, 238699080882667864827094121849090696547, 141659873734297659078160283051728812410, 228977113517120063860252637394240795552, 236613527842969921794004708284265628300, 145522034982744654991661857596541755396, 249608374387044047328725156440984678776, 325110572051913836681821746093704556, 171492052199838424502681030556098576483, 156498865212994371079795360268866413702, 196747701509389071931992996873572785043, 70811811603137896158765356680364490781, 83672551582385607422240464086955462541, 117961603623637997457153763936550310698, 224448821395214505399297116719025174412, 4598815373009554321735225938200807251, 194892269604260726530091473301914449005, 127484628022155760909820605666827662175, 208706240846212140439291547368645656474, 14102286481104997303651684152195298336, 6129503335471304345451795609683770657, 103799668048593149396277157385628834185, 185813375481410513002496683918106238351, 233491689316882978147517340230794025796, 46274083097168831187719988888816378961, 119487551553664772614629936285345836934, 84340029922118279362389419277915602509, 88253743193124528032223101368846247085, 227895357640018330099501504941388167432, 92189947144174433744195727086236905626, 83114957902192791332190922428847199876, 173535754090441937731619031520699325122, 192309407933789484835602071782330798398, 255421921600128994923738650157598053776, 155535082468314012733563336837641958625, 49064798421022327310707074253263463055, 161216416471071644769301963857685054031, 252480348817188872515008985698620059851, 75854882798183185741756645038434215611, 256065006192683011190132982128640682537, 87507510173514424105732562474643251223, 163309795132131534875147566536485288212, 253583084320404985699510129361746869059, 253300112521651972637580307326576568313, 239027717080729650738678032571840680727, 117444657686971615526398894470673026034, 215470942802874046857958621181684551426, 58767098748728136687851735836323448020, 249357164697409977883764098879705065535, 174705348385893117518084017669958647345, 211108767177375215605155301209259781232, 57829566748907062397366819001461941421, 88265742700024922112974862134385921564, 80952107622167923709226013231566882261, 236078582132483864916117213281193714198, 193448482646563141692726575550417225891, 245972799166806058223048506073553726233, 10132977708896091601871557249244373666, 201785418152654519825849206312616081028, 15169816744048531212384271865884567710, 122545328290385950043826822277924297182, 202918646192255177261567701479991753600, 32696887488223731055835744711207261936, 88319352182963224921157305627381030375, 92381505322264045777004475690398861771, 189745654013352563126968415157143821842, 152254915005998949299817641843658795579, 198032433618991362619448347415342295581, 84073892809321676935569114878067118319, 82243805869584256211699602267760745768, 61994229948266781537191603999495995852, 253668765227759797787675352833142466255, 38865376724677211964966907748953557125, 134615436811268347303232550777225944929, 176932422465426107783498083830285780588, 207573742393618910694054452362826628208, 200033130835394442710748301293534928706, 127536063935293533700918451145963158658, 219125698281820710910675956971948816959, 179795893258398750139395156587561075767, 69649628109726874051635160004398498964, 241433717681314766463039563422535023524, 202664264135718511331695232476272832350, 205151096657425932591242432052912914182, 210305712465948130683966275157181140301, 196555690055906934925300527324955477733, 66817932643964538216259564711698986077, 95270796440975607179107356182889534333, 123226880424532374188134357659879826495, 53506495440223773538415807620524749240, 19253217887083870834249774316467647628, 165699356396365023442008488156823647206, 107809175498119862854792975070673056027, 250453989887421415931162217952559757164, 171492052199838424502681030556098576483, 133778166882550119563444625306816232463, 149009301604122447269581792013291889175, 9982418254629616281350713836647603294, 203486292122499140756846060502464655972, 157686696123400087437836943220926921848, 88338919773540412238116717043122711811, 113265824169274322024623493892867211478, 5549372099744960679418616304893848801, 12431828907518852062050349123660880165, 183957934738536914983862053251433028750, 42027289270308356303682029801998790750, 117406080036483925915502666019795783905, 154312255292300186042636734144948304054, 143706917273862261295046346995206133170, 50088136095338601440516112338120787526, 250634504150859449051246497912830488025, 8073010289877796888705519374892639903, 40049582814576788803483039836229025416, 227012342545923833983403067401561291645, 201776603581414625783054400184026088994, 55474945478884522762318445841998187357, 221515530211550293408010846844218019597, 172650752042211610909190315288155597255, 67046194931321172530462444254204111483, 207435868835185636819659137800256834557, 188063222224545200294767050268070647452, 58099349021260301211275261896736590564, 23598877596106927870697531042828774738, 58546308516383335224739442370238545000, 58125311541947998710088435169901475101, 238219925698115060748249043752036454438, 203910234934340893915761800653823457631, 190854889967769152565565000250829375099, 37573623890629846209257307181880876288, 226220240200270623843038279593586687278, 144246075981535671790438155977352345487, 14665770553338784222331493932533448756, 37992062606775322664977502677838074649, 47370175759976523832233910009306151684, 97047813247943880266351445874642842468, 237607444658797800072728280983357541134, 174853113478993738890584814806707459112, 17104608155861584438824639050715857607, 83639027011494777283064583268678718843, 237826165608708003941944469905843354705, 231707683915242052796886276983724691027, 146089830852925550139294146760718642221, 25604562707667550478623425477029052785, 108577663147976992047614498924706939204, 69040319834829375335287614995435269276, 169933229202934375632745753379104389929, 72693008284867494808267387710985847974, 158548279589965576940349068403862889270, 49458101234256610254825879149914255140, 24389558269688411084589654047215902968, 210567980379246548727819953025607019254, 110423375132252997825868399832298953831, 109589895677661968369424757992411668628, 66177577069199763925999718357846633613, 83602293803708828242273186265396676466, 172226271050176278536911356541786290551, 85799805809703976643034084477579915867, 179399990302447560847151603157937241688, 81687654752229170984692833277072534294, 160766441640281044008645821822296569868, 100306680611749750243920501921769642984, 42195187332833922597871030332905266026, 238918420772178508359295233180536910768, 221685929158944699801776621298532178665, 209349638787804999657456057184702655805, 183953393268431043006359511952782903516, 137364333131365794683132159746962959967, 15637689373906596015395350692459218048, 145956368418289159411911667337899986262, 197987711355277581048877821432652325207, 125421308989313724733467092345532539875, 90525081516582408488547894471421476595, 107405840115256692042814887586009104950, 71587500700172519801649824611045199280, 10155721246869986043302768283257682883, 100522792569358427133597834727509523742, 244473925018526409824670892423775482110, 50746138425761666610345252577572889037, 142188269919422432629363225167297071042, 8235113926890598897465093754260801947, 174540885017405784646782293055852044631, 171949847901434672429841435895697323702, 34391199559497599434575002007581170988, 7337868660819385932166025474594964373, 89608475952042154068811282935241824949, 162561097613906905390170334328135062933, 252566077272083954707900007055640560669, 4284637988579219107997224848114896904, 220026371387782427901244689037957398829, 86019060485320999498155965142619258089, 19304861731281576405798605142335886482, 123188238667151068575810494833929221938, 125089740978532716086813732154638565196, 252061524500088702951562270741214799294, 89528875472312768404823823905699760649, 63307407053590054220492282094909190524, 24389558269688411084589654047215902968, 43835777110183833958990705735152973942, 196543204310466258426232803779025620993, 225032412767857179129234169288824097261, 50292890880286260984317361296226049436, 64928956886509273090981701066528078331, 25408225921774957745573142542576755590, 235921667882292842303120860570747218086, 217132603855089441017750752624514343437, 11106129204256119599329380588789107048, 147501327490657927610543345089238991876, 158091159632919983870444592039392730373, 254215886971254771885657857148535673338, 129869106474614345624950211566868568809, 10425702332274469498479699675668087022, 136595953187315682777976356839442311764, 1607792140397737044118662059498732982, 23710000155612873207506044342091514799, 118571340370877720354330132780832828911, 194624784476702188629452374731837038856, 51332273108989067644245919615090753756, 240921043405288511960365826273938845156, 158670188709175825212687487436006138030, 133641825913283256858340618209700716053, 43054466484232130048301271684438593412, 20361972967806283315536154125012604660, 135700832615866572032111395529532615300, 160609169788639387827865051539103507016, 100576279475451993660766480883708996211, 215424685541583305069271024253690375127, 60018956375784961551937423504137141702, 107997941230633604720421526632224279451, 219482010609171816035007605036664317041, 22173526221024380740269311947729076493, 249746554302052221287371350978970766087, 93207359085331319264650563354951254906, 221421697282310997113867048083058096452, 61834092635779365101011109381392037516, 162215218701897689647766394615098617152, 141856131587452385513407955541400099703, 177910903795887762773545874929605680469, 228832704523723308335513552177377803295, 229427981969125094398744034150988525118, 217938760689082034514008764751385239765, 3238055163645731541423094980789895030, 42308449860804765793467328093112118974, 254764518926620089428032312378507653680, 215733901156118606036318409454786603209, 59640829345183339336712595595022506261, 33515071724475649656070325837411550208, 51175659069843551646353202764296812462, 211462959696081863041546889096760952490, 230559603938699838189391087728971115767, 85878911733601049548471257838175175563, 214134904074265214033878852207103328297, 160702405980652445507529591230654474171, 223755040649990285320102091954198427148, 166476753890268002826149533120107157745, 26283916639129998224675164834425763384, 232971495542024495583092055361321729894, 79741799146769724681649849525636816379, 228506526471280046809909301748098760369, 167502422063741368765891061653686283332, 26984184590668253713951516794937308166, 105952393031190074432183821281493254, 113823192955281698937767041115166174652, 93264047694114869263275726820602569731, 55481974783112950660682138071588408040, 108961894273530837550182447112767144669, 47975793549419083945738147934068241928, 204024371586357035343484206754422857590, 251859351272989525849999231358507018068, 75939709807860493804628805619699991501, 129031774446142139804436921156668129187, 110764318451937254261883856778359218969, 246404864722813298477426808193494673610, 153818236564405157581869620439634140065, 246125932167584353084676586883038397451]# 预计算16位素数primes_16bit = [i for i in range(2, 2**16) if isPrime(i)]def decrypt_bit(n):    for b in [0, 1]:  # 尝试0和1        for d in range(1, 11):  # 尝试d从1到10            for e in primes_16bit:  # 尝试所有16位素数                if pow(a + b*d, e, p) == n:                    return str(b)    return &#x27;?&#x27;  # 未找到# 解密所有位plain_bits = []for n in tqdm(ciphertext):    plain_bits.append(decrypt_bit(n))# 将二进制字符串转换回字节plaintext = &#x27;&#x27;.join(plain_bits)flag = bytes(int(plaintext[i:i+8], 2) for i in range(0, len(plaintext), 8))print(flag)

flag：b‘moectf{Y0u_h@v3_ju5t_s01v3d_7h1s_pr0b13m!}’
总结：为数不多能ak的密码（如果后续不上题的话），刚学两三个月的密码手适合做，可以增强一下信心以及练一下基本功
最后，测试一下图片：

哦，后续会继续上题
]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>SwitchHosts下载安装使用</title>
    <url>/2025/08/11/SwitchHosts%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[SwitchHosts下载安装使用github直接搜然后下载

然后直接修改

注意，要关代理并且重启浏览器！！！
]]></content>
      <categories>
        <category>Java</category>
        <category>util</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见八股</title>
    <url>/2025/08/26/Java%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[Java常见八股一、Java 基础 (Java Basics)1. 接口 (Interface) vs 抽象类 (Abstract Class)面试官： 说一下接口和抽象类的区别。
我：好的，接口和抽象类主要有以下几个核心区别：

设计目的不同：抽象类描述的是 “is-a” 关系，强调类的本质是什么，比如 Manager 是一个 Employee。而接口描述的是 “has-a” 或 “can-do” 关系，强调类具备什么能力，比如 Bird 可以 Fly。
方法实现：抽象类可以有抽象方法，也可以有实现了的具体方法，用于代码复用。在JDK 8之前，接口只能有抽象方法；JDK 8之后，接口可以拥有默认方法（default）和静态方法（static）。
成员变量：抽象类中的变量可以是普通的，也可以是常量。而接口中定义的变量默认都是 public static final 的常量。
构造方法：抽象类有构造方法，虽然不能实例化自己，但可以供子类初始化时调用。接口没有构造方法。
继承性：这是最关键的差别。Java是单继承，一个类只能继承一个抽象类。但一个类可以实现多个接口，从而获得多种能力。

选用场景：

如果需要定义一系列密切相关对象的共同模板和行为，优先使用抽象类。
如果需要定义一种能力或契约，让不相关的类都能拥有，或者需要实现多重继承的效果，就使用接口。


2. 单例模式 (Singleton Pattern) 与双重检查锁 (Double-Checked Locking)面试官： 了解单例模式吗？写一个线程安全的单例。
我：单例模式的核心是保证一个类在任何情况下都只有一个实例，并提供一个全局访问点。
实现线程安全的单例有多种方式，比如饿汉式、懒汉式加锁、静态内部类等。其中，双重检查锁（DCL） 是一种性能和线程安全兼顾的懒加载方案。
（如果让写代码，我会写出DCL的代码。但按您要求，这里不做代码展示）
它的核心思路是：

将实例引用用 volatile 关键字修饰。
在 getInstance 方法中，先进行一次判空，如果实例不存在，再进入同步代码块。
进入同步块后，再进行第二次判空，最后才创建实例。

面试官： 为什么这里必须要用 volatile 关键字？
我：volatile 在这里主要作用是禁止指令重排序。
instance = new Singleton() 这行代码不是一个原子操作，它分为三步：1.分配内存、2.初始化对象、3.将引用指向内存地址。JVM可能对步骤2和3进行重排序。
如果没有 volatile，可能发生：线程A执行了1和3，此时 instance 不为null，但对象还未初始化（步骤2未执行）。这时线程B进来判断 instance 不为null，就直接返回了一个半成品对象去使用，从而导致错误。
volatile 通过内存屏障禁止了这种重排序，保证了对象的初始化完成在前，引用赋值在后，从而解决了这个隐蔽的问题。
其他实现方式的对比：

饿汉式：最简单，线程安全，但不是懒加载，可能造成资源浪费。
同步方法懒汉式：线程安全，但锁粒度太大，性能差。
静态内部类：我个人认为是最优雅的实现之一。它利用类加载机制保证了线程安全，且实现了懒加载，无需加锁，性能高。
枚举：最安全的方式，不仅能避免多线程问题，还能防止反射和反序列化破坏单例。

二、Java 集合框架 (Java Collections Framework)1. HashMap 深度解析面试官： 能详细说说 HashMap 的实现原理吗？
我：好的。HashMap 的核心实现是“数组 + 链表 + 红黑树”。

面试官： 具体讲讲它的数据结构？
我：

数据结构：
底层是一个 Node&lt;K,V&gt;[] table 数组。
数组的每个位置称为一个“桶”（bucket）。存入时，根据 key 的 hash 值计算出数组下标。
如果不同的 key 落到了同一个桶里（哈希冲突），就用链表来存储。
当链表长度超过阈值（默认为8），并且数组总长度达到一定规模（默认为64）时，链表会转换为红黑树。
当树节点数小于阈值（默认为6）时，红黑树会退化成链表。




面试官： 为什么要引入红黑树？
我：

引入红黑树的原因：

- 解决极端情况下（例如大量数据哈希冲突），链表过长导致的查询效率从 O(1) 退化为 O(n) 的问题。- 红黑树是一种自平衡的二叉查找树，能将查询、插入、删除的时间复杂度控制在 O(log n)，保证了性能下限。

面试官： HashMap 什么时候扩容？怎么扩？
我：

扩容机制（Rehashing）：

- 当元素数量超过 容量 * 负载因子（默认0.75）时，数组会进行扩容（通常扩为原来的2倍）。- 扩容后，所有元素需要重新计算在新数组中的位置，这是一个比较耗时的操作。

面试官： 为什么 HashMap 的长度总是2的幂次方？
我：

长度为何是2的幂次方：

- 为了高效地通过 (n - 1) &amp; hash 计算 key 的索引位置。- &amp; 操作比取模运算 % 效率高得多。当数组长度 n 为 2 的幂时，(n - 1) &amp; hash 等价于 hash % n，但效率更高，同时能保证计算结果均匀分布。

面试官： 从 JDK7 到 JDK8，HashMap 在解决冲突时有什么重要变化？
我：

JDK7头插法 -&gt; JDK8尾插法：

- JDK7 使用头插法，认为新插入的元素更可能被马上访问。但在多线程扩容时，头插法会改变链表的顺序，可能导致形成环形链表，引起死循环和数据丢失。- JDK8 改为尾插法，扩容时链表元素顺序不变，解决了这个潜在问题。（但HashMap本身仍非线程安全，只是解决了这个特定的死循环Bug）。

面试官： 为什么选择这种链表和红黑树结合的方式？
我：

为何采用链表+红黑树：

- 这是一种在空间和时间上的权衡。- 链表结构简单，占用内存少，但在节点多时性能差。- 红黑树性能好，但结构复杂，占用内存更多。- 这种设计保证了在绝大多数冲突较少的情况下使用高效的链表，仅在少数冲突严重时转为红黑树，以空间换时间，达到整体最优。
2. ArrayList vs LinkedList面试官： 对比一下 ArrayList 和 LinkedList。
我：好的。它们核心区别在于底层数据结构和由此带来的性能差异。

底层结构：
ArrayList 基于动态数组。内存中是连续的存储空间。
LinkedList 基于双向链表。内存中是通过节点指针连接的离散存储。




面试官： 它们在操作效率上有什么不同？
我：

操作效率：

- 随机访问 (get&#x2F;set)：ArrayList 的复杂度是 O(1)，因为它可以通过下标直接计算内存地址。LinkedList 是 O(n)，需要遍历链表。- 头部插入&#x2F;删除：ArrayList 是 O(n)，因为需要移动后续所有元素。LinkedList 是 O(1)，只需修改指针。- 尾部插入&#x2F;删除：两者在已知尾节点的情况下都接近 O(1)。ArrayList 在无需扩容时是 O(1)；LinkedList 需要先遍历到尾部（如果没有尾指针记录）是 O(n)，但通常实现会记录尾指针，所以也是 O(1)。- 中间插入&#x2F;删除：ArrayList 平均需要移动一半元素，是 O(n)。LinkedList 查找位置是 O(n)，但插入&#x2F;删除操作本身是 O(1)。

面试官： 它们的内存占用有什么特点？
我：

内存占用：

- ArrayList 只在数组尾部预留空间，内存利用率高。但扩容时会造成临时浪费。- LinkedList 每个元素都需要消耗额外空间存放前后节点的指针，内存开销更大。

面试官： 实际开发中如何选择？
我：

适用场景：

- 优先选择 ArrayList。因为它CPU缓存友好（内存连续），综合性能在大多数读多写少的场景下更好。- 只有在需要频繁在列表头部或中间进行插入&#x2F;删除操作时，才考虑使用 LinkedList。
3. ConcurrentHashMap 原理与演进面试官： 讲一下 ConcurrentHashMap 的原理，以及它在 JDK7 和 JDK8 的实现有什么不同。
我：好的。ConcurrentHashMap 是 HashMap 的线程安全版本，它的实现原理在 JDK7 和 JDK8 有重大变化。

面试官： 先说下 JDK7 是怎么实现的？
我：

JDK7分段锁实现 (Segment Locking)：
它内部有一个 Segment 数组，每个 Segment 本质上就是一个独立的、继承了 ReentrantLock 的 HashEntry[] 数组（一个小HashMap）。
“分段锁” 的思想是：锁不再针对整个Map，而是只锁住其中一个 Segment。这样，不同 Segment 的读写操作可以完全并行，大大提升了并发度。
默认有 16 个 Segment，所以理论上最多可以支持 16 个线程同时写入。




面试官： 那 JDK8 呢？为什么又改了？
我：

JDK8 CAS + synchronized 实现：

- JDK8 抛弃了 Segment 分段锁的概念，它的底层数据结构变得和 HashMap 一样，是 Node[] 数组 + 链表 + 红黑树。- 实现线程安全的方式更加细化：- CAS (无锁算法)：用于初始化数组、向桶中插入节点（当桶为空时）等无竞争场景，性能极高。- synchronized (同步锁)：当发生哈希冲突，需要操作链表或红黑树时，则只锁住当前发生冲突的桶（链表头节点&#x2F;树根节点）。锁的粒度从 JDK7 的一个 Segment（管着很多桶）缩小到了一个桶，并发度更高。- 这种设计结合了 CAS 的高性能和 synchronized 的稳定性，并且在锁粒度上做到了极致。

面试官： 从 JDK7 到 JDK8 这次升级主要带来了哪些好处？
我：

JDK7 到 JDK8 的升级：

- 锁粒度更小：从锁一段（Segment）到锁一桶（Bucket），并发性能得到极大提升。- 数据结构优化：引入了红黑树，解决了链表过长时查询慢的问题，保证了最坏情况下的性能。- API 增强：提供了更多方便的流式 API（如 forEach, reduce）。- 代码更简化：移除了复杂的 Segment 结构，底层实现变得更简洁、更统一（和 HashMap 类似），更易于维护和理解。
三、Java 并发编程 (Java Concurrency)1. 乐观锁与悲观锁面试官： 说说你对乐观锁和悲观锁的理解。
我：好的，这是两种不同的并发控制策略。

悲观锁：
思想：认为并发冲突是大概率事件，每次操作数据时，都假定别人会修改，所以先加锁再操作。
实现：synchronized 关键字、ReentrantLock 等。
类比：就像“写文档时先锁门”，防止别人打扰。


乐观锁：
思想：认为并发冲突是小概率事件，每次操作数据时，不会先加锁，而是在更新时判断此期间数据是否被他人修改过。
实现：通常使用 CAS (Compare-And-Swap) 算法或版本号机制。
类比：就像“写文档时不锁门”，提交时才检查有没有人动过原稿，没动过就提交，动了就放弃或重试。



适用场景：

悲观锁：适合写多读少的场景，冲突严重时性能高。
乐观锁：适合读多写少的场景，冲突少时性能远高于悲观锁，能减少上下文切换。

2. CAS 原理与原子类实现面试官： 讲一下 CAS 的原理。
我：

CAS实现原理：
CAS 的全称是 Compare-And-Swap，即比较并交换。它是一个CPU原子指令，保证了操作的原子性。
操作包含三个操作数：内存地址 V、旧的预期值 A、要更新的新值 B。
原理：当且仅当内存地址 V 中的当前值等于预期值 A 时，处理器才会自动将地址 V 的值更新为新值 B，否则什么都不做。整个操作是一个原子操作。




面试官： CAS 有什么优缺点？
我：优点：

高性能：它是一种无锁操作，避免了传统互斥锁（如 synchronized）带来的线程阻塞、上下文切换的开销，在低竞争环境下性能很高。

缺点：

ABA 问题：这是最经典的缺点。一个线程读取内存值为 A，此时另一个线程将值改为 B，然后又改回 A。等第一个线程执行 CAS 时，发现值还是 A，于是操作成功，但它并不知道这个 A 已经被“中间修改过”了。
循环时间长开销大：如果 CAS 操作长时间不成功（竞争激烈），CPU 会一直进行自旋（循环重试），消耗资源。
只能保证一个共享变量的原子操作：对于多个共享变量，CAS 无法保证原子性，可能需要加锁。


面试官： 那怎么解决 ABA 问题呢？
我：

可以通过给数据加上版本号（Stamp） 或时间戳来解决。
Java 提供了 AtomicStampedReference 类。它不仅在比较值，还会比较一个 int 型的版本号标记。任何对值的修改都会使版本号递增，这样即使值从 A 变回 A，版本号也变了，CAS 就会失败。


面试官： 原子类（比如 AtomicInteger）是如何利用 CAS 实现的？
我：

原子类实现原理：

- 原子类（如 AtomicInteger）内部的核心字段（如 value）都由 volatile 修饰，保证了可见性。- 它们的所有原子性方法（如 getAndIncrement()）内部都调用了 Unsafe 类的 CAS 方法（compareAndSwapInt）。- 以 i++ 为例，getAndIncrement() 的实现是一个 CAS 自旋循环：先获取当前值，计算新值，然后用 CAS 尝试更新。如果失败（值已被其他线程修改），就重新获取当前值，再次计算和尝试，直到成功为止。
3. synchronized 与 ReentrantLock 详解面试官： 对比一下 synchronized 和 ReentrantLock。
我：好的，它们的核心区别如下：

本质不同：synchronized 是 Java 关键字，由 JVM 底层实现；ReentrantLock 是一个 Java 类，基于 AQS 实现。
锁的释放：synchronized 在代码块执行完或发生异常时，由 JVM 自动释放锁；ReentrantLock 必须手动调用 unlock() 方法释放锁，通常在 finally 块中完成，否则容易造成死锁。
功能丰富性：ReentrantLock 功能更丰富。
可中断：lockInterruptibly() 可以响应中断，在等待锁的过程中可以被中断。
公平锁：可以选择创建公平锁（先等待的线程先获得锁），synchronized 是非公平锁。
条件队列：可以通过 Condition 实现多路通知，更精细地控制线程的等待与唤醒。


灵活性：synchronized 的加锁和释放锁是固化的；ReentrantLock 可以在方法内加锁，在另一方法内解锁，更灵活。
锁的实现机制：synchronized 在 JDK6 后引入了锁升级机制来优化性能；ReentrantLock 则通过 AQS 内部的 CAS 自旋来实现。

选用建议：

除非需要 ReentrantLock 的高级功能（如可中断、公平锁、Condition），否则优先使用 synchronized，因为它的写法更简洁，且由 JVM 维护和优化。


面试官： 详细说一下 synchronized 的锁升级流程。
我：

synchronized 的锁升级流程：

为了在性能和开销之间取得平衡，JVM 将 synchronized 的锁状态分为4级，并可以从低到高进行升级，但不可降级。
- **无锁 (No Lock)**：对象未作为同步锁使用。- **偏向锁 (Biased Locking)**：    - **目的**：在**没有竞争**的情况下，消除同步开销。假设锁总是由同一线程获得。    - **流程**：第一个线程访问同步块时，会通过 CAS 操作将对象头中的 Mark Word 里存储的线程 ID 改为自己的 ID。之后该线程再进入时，只需检查线程 ID 是否匹配，匹配则无需任何同步操作。- **轻量级锁 (Lightweight Lock)**：    - **触发条件**：当有**轻微竞争**（第二个线程来尝试获取锁）时，偏向锁会升级为轻量级锁。    - **流程**：线程会在自己的栈帧中创建一个锁记录（Lock Record），然后通过 **CAS** 操作尝试将对象头的 Mark Word 更新为指向该锁记录的指针。如果成功，当前线程就获得了锁。如果失败，会**自旋**重试一定次数。- **重量级锁 (Heavyweight Lock)**：    - **触发条件**：**自旋失败**（竞争加剧，线程数多或等待时间长）后，锁会升级为重量级锁。    - **流程**：此时，未获得锁的线程会**被挂起**，进入阻塞状态，等待操作系统调度，需要进行用户态到内核态的切换，开销最大。


面试官： 什么是 synchronized 的可重入性？
我：

synchronized 的可重入性：

- 概念：指同一个线程在执行完外层同步方法&#x2F;块后，再次进入它的内层同步方法&#x2F;块时，可以直接获得锁而不会被自己阻塞。- 原理：JVM 会为每个锁对象维护一个计数器和一个持有者线程标识。当线程第一次获取锁时，计数器变为1。每次重入，计数器就+1。退出同步块，计数器就-1。直到计数器为0，锁才被真正释放。- 重要性：可重入性避免了线程死锁自己，是设计同步代码的基础。
4. volatile 关键字的作用与原理面试官： 讲一下 volatile 关键字的作用和原理。
我：好的。volatile 是 Java 提供的轻量级同步机制，它主要有两大核心作用：保证内存可见性 和 禁止指令重排序。

面试官： 先解释一下什么是内存可见性，volatile 是如何保证的？
我：

内存可见性 (Memory Visibility)：
问题：根据 Java 内存模型 (JMM)，每个线程有自己的工作内存，用于缓存共享变量的副本。当一个线程修改了共享变量，可能只是先修改了自己的工作内存，未能立即写回主内存，导致其他线程读取到的仍然是旧的副本值。
volatile 的作用：当一个变量被声明为 volatile 后：
任何线程修改这个变量，都会立即强制将新值刷新到主内存。
任何线程读取这个变量，都会强制从主内存中重新读取最新的值，使当前工作内存中的副本失效。


原理：底层是通过内存屏障 (Memory Barrier) 来实现的。写操作前后会插入屏障，强制将缓存数据刷回主存；读操作前后也会插入屏障，强制使本地缓存失效，从主存拉取新数据。




面试官： 那禁止指令重排序呢？这又是什么？
我：

禁止指令重排序 (Prevention of Instruction Reordering)：

- 问题：为了提升性能，编译器和处理器常常会对指令进行重排序。但在多线程环境下，不恰当的重排序可能会导致程序运行结果与预期不符。（最经典的例子就是双重检查锁单例模式中，instance = new Singleton() 这行代码可能被重排序，导致其他线程拿到一个未初始化完全的对象）。- volatile 的作用：通过添加内存屏障，volatile 关键字禁止了 JVM 和处理器对修饰了 volatile 的变量的读写操作与其他指令进行重排序，从而保证了操作的有序性。- 原理：内存屏障就像一个“栅栏”，告诉编译器和 CPU，必须在这个屏障之前的所有操作都完成后，才能执行屏障之后的操作。
总结：volatile 的核心是通过内存屏障这一 CPU 指令来实现可见性和有序性。但它不保证原子性，像 i++ 这种复合操作依然需要加锁或使用原子类。
5. Java 内存模型 (JMM) 与 Happens-Before面试官： 谈谈你对 Java 内存模型 (JMM) 的理解。
我：好的。JMM 是一个抽象的概念，它定义了程序中各种变量（线程共享变量）的访问规则，以及如何在内存中进行读写操作的细节。它屏蔽了底层硬件内存结构的差异，旨在解决多线程下的可见性、原子性和有序性问题。

面试官： JMM 是如何抽象内存结构的？
我：

JMM抽象模型（主内存、工作内存）：

主内存 (Main Memory)：存储所有的共享变量。所有线程都能访问，但速度较慢。
工作内存 (Working Memory)：每个线程都有自己的工作内存，可以看作是CPU高速缓存和寄存器的抽象。它存储了该线程使用到的共享变量的副本。
交互协议：JMM 规定了线程如何与主内存进行交互：
read：从主内存读取数据到工作内存。
load：将 read 得到的值放入工作内存的变量副本中。
use：执行引擎使用工作内存中的变量值。
assign：执行引擎将新值赋给工作内存中的变量。
store：将工作内存中的变量值传送到主内存。
write：将 store 传来的值写入主内存的变量中。



JMM 通过这8种原子操作（还有 lock 和 unlock）来控制主内存与工作内存之间的同步，从而决定一个线程对共享变量的写入何时对另一个线程可见。volatile 的特殊规则就体现在它强制 read&#x2F;load&#x2F;use 和 assign&#x2F;store&#x2F;write 必须连续、按顺序执行。



面试官： 什么是指令重排序？它为什么会带来问题？
我：

指令重排序：

- 原因：为了充分发挥 CPU 性能，编译器和处理器常常会在不改变程序单线程执行结果的前提下，对指令的执行顺序进行重新排序优化。- 问题：在多线程环境下，这种重排序可能会破坏程序的语义，导致线程执行结果出现不可预测的错误。（例如，双重检查锁单例模式中，由于 new 操作的非原子性可能被重排序，导致其他线程拿到一个未初始化完全的对象引用）。

面试官： JMM 如何解决可见性和有序性问题？什么是 Happens-Before 原则？
我：

Happens-Before 原则：

- 这是 JMM 最核心的概念。它本质上是一种可见性保证规则，用于描述两个操作之间的内存可见性。如果操作 A Happens-Before 于操作 B，那么 A 操作所产生的所有内存更改（结果）对 B 操作都是可见的。- 它是一些规则的集合，无需任何同步手段就天然具有 Happens-Before 关系：

程序次序规则：在一个线程内，书写在前面的操作 Happens-Before 于后面的操作。（注意：这仅指执行结果上的顺序，依然可能被重排序，但重排序后的结果必须与按代码顺序执行的结果一致）。
监视器锁规则：对一个锁的 unlock 操作 Happens-Before 于后续对这个锁的 lock 操作。
volatile变量规则：对一个 volatile 变量的写操作 Happens-Before 于后续对这个变量的读操作。
线程启动规则：Thread 对象的 start() 方法调用 Happens-Before 于此线程的任何动作。
线程终止规则：线程中的所有操作都 Happens-Before 于其他线程检测到该线程已经终止（如 thread.join() 返回）。
传递性：如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

**总结**：Happens-Before 关系并不代表实际执行的时间顺序，而是**内存可见性的保证**。它是判断数据是否存在竞争、线程是否安全的主要依据。

6. AQS 原理浅析面试官： 讲一下 AQS 的核心原理。
我：好的。AQS (AbstractQueuedSynchronizer) 是 JUC 并发包的核心基础组件，像 ReentrantLock、CountDownLatch 等工具都是基于它实现的。它的核心思想是 “一个状态位（state）+ 一个FIFO线程等待队列（CLH）”。

面试官： 具体说说 state 和 CLH 队列的作用。
我：

AQS核心思想（state、CLH队列）：
状态 (state)：这是一个由 volatile 修饰的 int 成员变量，表示共享资源的状态。具体含义由子类定义，例如：
在 ReentrantLock 中，state=0 表示锁未被占用，state&gt;0 表示锁被占用，且数值表示重入次数。
在 Semaphore 中，state 表示剩余的许可证数量。


CLH队列：这是一个虚拟的双向 FIFO 队列，用于管理获取资源失败的线程。当线程争抢资源失败时，AQS 会将当前线程及其等待状态等信息构造成一个节点（Node）并加入队尾，然后阻塞该线程（LockSupport.park()）。队列头节点表示当前正持有资源的线程。




面试官： AQS 是如何基于这个核心思想来实现公平锁的？
我：

如何实现公平锁：

- 公平锁 的核心原则是：先来后到，即等待时间最长的线程（队列头节点的后继节点）优先获取资源。- 实现机制：当一个线程（Thread-A）尝试通过 lock() 方法获取锁时，它的核心逻辑是：

检查 state 是否为 0（锁是否空闲）。
在判断锁空闲后，公平锁的实现会先调用 hasQueuedPredecessors() 方法检查等待队列中是否有其他线程在排队。

- 如果队列为空，或者当前线程自己就是队列的头节点（即将被唤醒的下一个），那么它才有资格去用 CAS 竞争锁。- 如果发现队列中有其他线程在等待，那么当前线程会放弃竞争，直接将自己加入队列末尾进行等待，这就保证了“先来后到”的公平性。- 与非公平锁的区别：非公平锁（ReentrantLock 的默认方式）在尝试获取锁时，不管队列里有没有线程在等，都会直接去用 CAS 抢锁。抢失败了才入队。这提高了吞吐量但可能导致“插队”现象，造成线程饥饿。
四、Java 虚拟机 (JVM)1. JVM 内存区域与分配面试官： 说一下 JVM 的内存区域是如何划分的。
我：好的。JVM 内存区域主要分为线程共享区和线程私有区。

面试官： 线程共享区包含哪些？各自的作用是什么？
我：

线程共享区：
堆 (Heap)：
作用：这是最大的一块内存区域，用于存放对象实例和数组。GC（垃圾回收）主要发生在这里。
细分：从垃圾回收角度，可分为新生代 (Young Generation) 和老年代 (Old Generation)。新生代又分为 Eden 区和两个 Survivor区 (S0&#x2F;S1)。


方法区 (Method Area)：
作用：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
实现：在 JDK8 之前，它的实现是“永久代”(PermGen)。在 JDK8 及之后，改为了元空间 (Metaspace)，并使用本地内存 (Native Memory) 来实现，大大降低了OOM的风险。






面试官： 那线程私有区呢？
我：

线程私有区：

- 虚拟机栈 (VM Stack)：- 作用：描述的是 Java 方法执行的内存模型。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。我们常说的“栈内存”就是指这里。- 异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError；如果栈可以动态扩展但无法申请到足够内存，则抛出 OutOfMemoryError。- 本地方法栈 (Native Method Stack)：- 作用：与虚拟机栈非常相似，区别在于它为虚拟机使用的 Native 方法服务。- 程序计数器 (Program Counter Register)：- 作用：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域。

面试官： 你刚才还提到了直接内存，它属于 JVM 内存区域吗？
我：

直接内存 (Direct Memory)：

- 不属于 JVM 运行时数据区，也不是 JVM 规范中定义的内存区域。- 作用：它是由 NIO 的 DirectByteBuffer 引用的内存区域，通常直接在物理内存上分配，避免了在 Java 堆和 Native 堆之间来回复制数据，从而能显著提高性能。- 影响：虽然不受 JVM 内存管理，但其大小也会受到本机总内存的限制。如果各个内存区域的总和大于物理内存限制，动态扩展时可能导致 OutOfMemoryError。
2. 垃圾回收算法与收集器面试官： 讲一下 JVM 如何确定一个对象是垃圾？以及有哪些垃圾回收算法。
我：好的。垃圾回收主要分两步：首先确定对象是否存活（是垃圾），然后进行回收。

面试官： 先说下如何确定垃圾。
我：

确定垃圾的算法：
引用计数法：
原理：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为0的对象就是不可能再被使用的。
缺点：它无法解决对象之间循环引用的问题（即A引用B，B也引用A，但再无第三方引用它们俩），从而导致内存泄漏。因此，主流的 Java 虚拟机都没有选用引用计数法。


可达性分析算法：
原理：这是 JVM 采用的算法。通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。如果某个对象到 GC Roots 间没有任何引用链相连（即从 GC Roots 到这个对象不可达），则证明此对象是不可能再被使用的。
哪些对象可以作为 GC Roots：
虚拟机栈（栈帧中的局部变量表）中引用的对象。
本地方法栈中 JNI（即 Native 方法）引用的对象。
方法区中类静态属性引用的对象。
方法区中常量引用的对象。
Java 虚拟机内部的引用（如基本类型对应的 Class 对象，常驻的异常对象等）。
被同步锁（synchronized）持有的对象。








面试官： 确定了垃圾之后，有哪些回收算法？
我：

回收垃圾的算法：

- 标记-清除算法：- 过程：分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。- 缺点：效率不高，且会产生大量不连续的内存碎片，导致以后需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次 GC。
- **复制算法**：    - **过程**：将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象**复制**到另外一块上面，然后再把已使用过的内存空间一次清理掉。    - **优点**：实现简单，运行高效，且没有内存碎片。    - **缺点**：**内存代价太高**，可用内存缩小为了原来的一半。    - **应用**：是**新生代**垃圾回收的主要算法。商业虚拟机都采用这种算法来回收新生代，但并不是按1:1的比例划分，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。- **标记-整理算法**：    - **过程**：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。    - **优点**：避免了内存碎片，也避免了复制算法的空间浪费。    - **缺点**：移动存活对象并更新所有引用地址是一项负重操作，需要暂停用户线程（Stop The World）。    - **应用**：主要用于**老年代**的垃圾回收。- **分代收集算法**：    - **本质**：这不是一种具体的算法，而是一种**理论**。当前商业虚拟机的垃圾收集器都采用它。    - **思想**：根据对象存活周期的不同，将 Java 堆划分为**新生代**和**老年代**，然后根据各个年代的特点采用最适当的收集算法。        - 在**新生代**中，每次垃圾收集时都有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。        - 在**老年代**中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记-清除**或**标记-整理**算法来进行回收。

3. 性能调优、OOM与内存泄漏面试官： 谈谈JVM调优的目标和常用参数。
我：好的。JVM调优的核心目标是在吞吐量、延迟和内存占用三者间找到最佳平衡。

JVM调优目标：
低延迟：减少 GC停顿时间（Stop-The-World），提高应用响应速度，适合Web等交互式应用。
高吞吐量：减少GC总耗时，增大应用运行时间占比，适合后台计算型任务。
减少内存占用：在满足需求的前提下，控制堆内存大小。


常用参数：
-Xms 和 -Xmx：设置堆的初始大小(-Xms)和最大大小(-Xmx)，通常设为相同值以避免扩容带来的性能抖动。
-Xmn：设置新生代大小。整个JVM堆大小 &#x3D; 新生代 + 老年代。
-XX:SurvivorRatio：设置Eden区与一个Survivor区的比例（默认为8，即Eden:S0:S1&#x3D;8:1:1）。
-XX:+UseG1GC：指定使用G1垃圾收集器。
-XX:+PrintGC &#x2F; -XX:+PrintGCDetails：打印GC日志，用于排查。
-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize：设置元空间初始大小和最大大小。




面试官： 什么是逃逸分析？栈上分配又是什么？
我：

逃逸分析：是JIT编译器的一种高级优化技术。它通过分析对象的作用域，判断一个对象是否会被外部方法或外部线程所引用。
方法逃逸：对象被作为参数传递给其他方法。
线程逃逸：对象被赋值给其他线程可访问的实例变量。


栈上分配：
如果逃逸分析证明一个对象不会逃逸出方法，那么这个对象就可以在栈上分配内存，而不是在堆上。
好处：对象随方法栈帧出栈而自动销毁，无需垃圾回收器介入，极大减轻了GC压力，提升了性能。




面试官： 常见的OutOfMemoryError有哪些？如何排查？
我：

OutOfMemoryError避免与排查：

OOM错误有多种类型，每种原因不同：- Java heap space：堆内存溢出。最常见，原因是对象太多或存在内存泄漏，堆空间不足。- 排查：使用-XX:+HeapDumpOnOutOfMemoryError参数在OOM时自动生成堆转储文件，然后用MAT、JProfiler等工具分析，找到是哪些对象占用了大量内存以及它们的GC Roots引用链。- Metaspace &#x2F; PermGen space：元空间（方法区）溢出。原因是加载的类过多，如大量动态代理、反射。- GC overhead limit exceeded：GC overhead limit exceeded：GC回收效率过低导致的溢出。默认如果超过98%的时间都在做GC并且回收不到2%的堆空间，就会抛出此错误。本质是堆内存太小或内存泄漏。- Unable to create new native thread：无法创建本地线程。原因是创建的线程数超过系统限制（如Linux的ulimit）或内存不足。

面试官： 什么是内存泄漏？举几个常见例子。
我：

内存泄漏概念与常见案例：

- 概念：指程序中已动态分配的堆内存由于某种原因未能被释放或无法被释放，造成系统内存的浪费，最终可能导致OOM。- 它与内存溢出的关系：内存泄漏是原因，内存溢出是结果。持续的泄漏最终会导致溢出。
**常见案例**：- **缓存泄漏**：使用了无大小限制的缓存（如`HashMap`作为缓存），对象只放入不取出。应使用`WeakHashMap`或类似Guava Cache的、具有LRU淘汰机制的缓存。- **监听器未移除**：向全局集合（如一个静态List）注册了监听器，但在对象不用后没有取消注册，导致集合一直持有对象的引用，无法被回收。- **数据库连接、文件流未关闭**：这些资源不仅占用内存，还占用系统句柄。- **内部类持有外部类引用**：非静态内部类会隐式持有外部类的引用。如果这个内部类的实例被一个长生命周期对象引用，就会导致外部类也无法被回收。



五、Java 多线程 (Java Multithreading)1. 线程池核心原理与参数配置面试官： 说一下线程池的7个核心参数。
我：好的。通过 ThreadPoolExecutor 的构造函数，可以看到7个核心参数：

corePoolSize：核心线程数。线程池维护的最小线程数量，即使它们处于空闲状态，也不会被回收（除非设置了 allowCoreThreadTimeOut）。
maximumPoolSize：最大线程数。线程池允许创建的最大线程数量。
keepAliveTime：空闲线程存活时间。当线程数超过 corePoolSize 时，多余的空闲线程在终止前等待新任务的最长时间。
unit：keepAliveTime 参数的时间单位。
workQueue：任务队列。用于保存等待执行的任务的阻塞队列（如 ArrayBlockingQueue, LinkedBlockingQueue）。
threadFactory：线程工厂。用于创建新线程，可以设置线程名、优先级等，便于排查问题。
handler：拒绝策略。当线程池和队列都已满时，用于处理新提交任务的策略（如抛出异常、直接丢弃等）。


面试官： 描述一下任务提交到线程池后的执行流程。
我：

任务提交流程：

当一个新任务被提交 (execute()) 时，流程如下：

首先，判断当前运行的线程数是否小于 corePoolSize。如果是，则创建新的核心线程来执行该任务（即使有其他空闲线程）。
如果当前线程数已达到 corePoolSize，则尝试将任务放入工作队列 (workQueue) 等待。
如果队列已满，则判断当前线程数是否小于 maximumPoolSize。如果是，则创建新的非核心线程来执行该任务。
如果线程数也已达到 maximumPoolSize，并且队列已满，则触发拒绝策略 (handler)。

**简单记法**：**先核心 -&gt; 再入队 -&gt; 后扩容 -&gt; 最后拒绝**。


面试官： 在实际项目中，如何设置核心线程数？
我：

核心参数计算：

这是一个经验值，需要根据任务类型是 CPU密集型 还是 IO密集型 来调整。
- **CPU密集型**：    - **特点**：任务主要消耗CPU资源，需要进行大量计算（例如，计算圆周率、视频编码）。    - **设置**：线程数不宜过多，通常设置为 **`CPU核心数 + 1`**。设置过多会导致大量的线程上下文切换，反而降低性能。- **IO密集型**：    - **特点**：任务大部分时间在等待IO操作（如数据库查询、网络请求、文件读写），CPU空闲。    - **设置**：线程数可以设置得多一些，以充分利用CPU资源。通常可以设置为 **`2 * CPU核心数`**，或者更高。更精确的估算公式是：**`线程数 = CPU核心数 * (1 + 平均等待时间 / 平均计算时间)`**。**注意**：这只是一个理论上的起始值，**实际生产中需要通过压测来找到最适合自己应用的参数**。



六、数据库 (Database)1. MySQL1.1 事务与 ACID 属性
面试官： 你先说说 MySQL 的事务和它的 ACID 属性吧。
我：
好的。事务是数据库操作的基本单元，它是一个不可分割的工作序列，要么全部执行成功，要么全部执行失败，能保证数据的一致性和完整性。
事务的 ACID 属性是其核心特性，具体指：

原子性（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成，不会存在部分执行的情况。比如转账时，“从 A 账户扣钱” 和 “给 B 账户加钱” 这两个操作要么都成功，要么都失败，不会出现 A 扣了钱但 B 没收到的情况。

一致性（Consistency）：事务执行前后，数据库的完整性约束不会被破坏。例如，假设表中有 “总金额 &#x3D; A 账户金额 + B 账户金额” 的约束，转账事务执行后，这个等式依然成立。

隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应被其他事务干扰，每个事务都像在独立执行一样。避免因并发操作导致的数据不一致问题。

持久性（Durability）：一旦事务提交成功，它对数据库中数据的修改就是永久性的，即使之后发生数据库崩溃等故障，修改的数据也不会丢失。


1.2 事务隔离级别与 MVCC 机制
面试官： 那事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？MVCC 机制你了解吗？
我：
事务隔离级别是为了应对并发事务可能出现的问题（如脏读、不可重复读、幻读）而设定的，主要有 4 种：

读未提交（Read Uncommitted）：最低的隔离级别。一个事务可以读取到另一个未提交事务修改的数据，可能导致脏读（读取到未提交的无效数据）。

读已提交（Read Committed）：一个事务只能读取到另一个已提交事务修改的数据，解决了脏读问题，但可能出现不可重复读（同一事务中多次读取同一数据，结果因其他事务提交的修改而不同）。

可重复读（Repeatable Read）：MySQL 的默认隔离级别。保证同一事务中多次读取同一数据时，结果一致，解决了不可重复读问题，但在默认情况下可能出现幻读（同一事务中，按同一条件多次查询，结果集行数因其他事务的插入 &#x2F; 删除而变化）。

串行化（Serializable）：最高的隔离级别。事务串行执行，完全避免了并发问题，但性能极低，通常只在数据一致性要求极高且并发量低的场景使用。


MVCC（Multi-Version Concurrency Control，多版本并发控制）是 MySQL 实现读已提交和可重复读隔离级别的核心机制，它通过为数据保存多个版本，让读写操作不相互阻塞，提升并发性能。其实现原理主要涉及版本链和ReadView：

版本链：每行数据在被修改时，会生成一个新的版本，旧版本不会被立即删除，而是保留下来并通过隐藏列（如DB_TRX_ID记录修改事务 ID、DB_ROLL_PTR指向旧版本数据）形成链表，即版本链。

ReadView：事务在进行快照读（普通 SELECT 操作）时，会生成一个 ReadView，它包含当前活跃事务的 ID 列表等信息。通过比较数据版本的DB_TRX_ID与 ReadView 中的信息，来判断该版本数据是否可见：若数据版本的事务 ID 不在活跃列表中且小于 ReadView 中的最大事务 ID 等（不同隔离级别下判断逻辑有差异），则数据可见。


读已提交隔离级别下，每次执行 SELECT 都会生成一个新的 ReadView，所以能看到其他事务已提交的修改；可重复读隔离级别下，仅在第一次 SELECT 时生成 ReadView，之后复用该 ReadView，因此能保证同一事务中多次读取结果一致。
面试官： 那可重复读级别下是怎么解决幻读的呢？
我：
MySQL 的可重复读级别通过 “MVCC 快照读 + Next-Key Lock 当前读” 的组合来解决幻读问题：

MVCC 快照读：对于普通的 SELECT 查询（快照读），由于复用第一次生成的 ReadView，即使其他事务插入了新数据，新数据的事务 ID 在当前 ReadView 中可能被判定为不可见，因此不会读取到新插入的数据，避免了快照读场景下的幻读。

Next-Key Lock 当前读：对于加锁的查询（如SELECT … FOR UPDATE、UPDATE、DELETE等当前读操作），MySQL 会使用 Next-Key Lock。它是行锁和间隙锁的组合，不仅会锁定符合条件的行，还会锁定这些行所在间隙（即不存在的、可能被插入数据的区间），防止其他事务在间隙中插入新数据，从而避免了当前读场景下的幻读。


1.3 锁机制：间隙锁与临键锁
面试官： 聊完隔离级别，再说说 MySQL 的锁机制吧，特别是间隙锁和临键锁。
我：
MySQL 的锁机制按粒度可分为表锁、行锁等，行锁是并发控制的关键，而间隙锁和临键锁是行锁的扩展：

间隙锁（Gap Lock）：锁定的是一个区间，而不是具体的行。当事务对某条记录加锁时，若该记录所在索引区间存在未使用的间隙，会对这些间隙加锁。例如，表中有 id 为 1、3、5 的记录，对 id&#x3D;3 的记录加锁时，可能会锁定 (1,3)、(3,5) 这样的间隙，防止其他事务在这些间隙中插入 id&#x3D;2、4 的记录，主要用于解决幻读。

临键锁（Next-Key Lock）：是行锁和间隙锁的结合，锁定的是 “记录 + 间隙”。它会锁定当前记录以及该记录前面的间隙。比如上述 id&#x3D;3 的例子，临键锁会锁定 (1,3] 这个区间（包含 3 这条记录和 1 到 3 之间的间隙）。在可重复读隔离级别下，MySQL 默认使用临键锁进行当前读操作，当查询条件是唯一索引且精确匹配时，临键锁会降级为行锁。


1.4 索引与优化：回表查询与覆盖索引
面试官： 索引相关的，回表查询和覆盖索引你清楚吗？
我：
这两个概念和索引的结构密切相关，MySQL 中最常用的索引是 B + 树索引：

回表查询：B + 树索引分为聚簇索引和非聚簇索引（二级索引）。聚簇索引的叶子节点存储的是完整的行数据，而非聚簇索引的叶子节点存储的是行数据的主键值。当使用非聚簇索引查询数据时，若查询的字段不在非聚簇索引中，需要先通过非聚簇索引找到主键值，再到聚簇索引中根据主键值查找完整的行数据，这个过程就叫回表查询。回表会增加 IO 操作，影响查询效率。

覆盖索引：若查询的所有字段都包含在非聚簇索引中（即非聚簇索引的叶子节点已包含查询所需的全部数据），则不需要回表，直接通过非聚簇索引就能获取到数据，这种索引就是覆盖索引。例如，表有索引idx_name(name)，执行SELECT name, age FROM table WHERE name&#x3D;’xxx’，若age也在idx_name索引中（如联合索引idx_name_age(name, age)），则该索引就是覆盖索引，能避免回表，提升查询效率。


1.5 性能分析：EXPLAIN 与索引失效
面试官： 那怎么分析 SQL 性能？索引为什么会失效呢？
我：
分析 MySQL SQL 性能最常用的工具是EXPLAIN命令，在 SQL 语句前加上EXPLAIN，执行后会得到查询计划，通过查看各列（如type、key、rows、extra等）的信息，能判断索引是否被使用、查询效率如何：

type：表示访问类型，从好到差有system、const、eq_ref、ref、range、index、ALL等，range及以上通常表示使用了索引，ALL是全表扫描，效率低。

key：显示实际使用的索引，若为NULL则未使用索引。

rows：预估需要扫描的行数，行数越少越好。

extra：包含额外信息，如Using index表示使用了覆盖索引，Using filesort表示需要额外排序（效率低），Using temporary表示使用了临时表（效率低）等。


索引失效的原因有很多，常见的有：

索引列上使用了函数或表达式，如WHERE SUBSTR(name, 1, 1)&#x3D;’a’，会导致索引无法被使用。

索引列进行了隐式类型转换，如索引列是varchar类型，查询时用WHERE id&#x3D;123（123 是数字），MySQL 会进行类型转换，导致索引失效。

使用NOT IN、!&#x3D;、&lt;&gt;等否定操作符，可能导致索引失效（视情况而定，部分场景下可能使用索引）。

LIKE查询以%开头，如WHERE name LIKE ‘%abc’，无法使用索引的前缀匹配，导致索引失效。

联合索引未遵循 “最左前缀原则”，即查询条件不包含联合索引的第一个列，如联合索引(a,b,c)，查询WHERE b&#x3D;1 AND c&#x3D;2，会导致索引失效。

表中数据量极少，MySQL 认为全表扫描比使用索引更高效，会放弃使用索引。


1.6 日志系统：三大日志解析（undo log、redo log、binlog）
面试官： 最后说说 MySQL 的三大日志吧，undo log、redo log、binlog。
我：
MySQL 的三大日志在数据一致性、事务恢复、主从复制等方面起着关键作用：

undo log（回滚日志）：

作用：用于事务回滚和 MVCC。当事务修改数据时，会先将数据的旧版本记录到 undo log 中。若事务需要回滚（如执行ROLLBACK），可以通过 undo log 恢复数据到修改前的状态；同时，undo log 也是 MVCC 中版本链的重要组成部分，供快照读时获取旧版本数据。

特点：是逻辑日志，记录的是 “做了什么操作可以恢复数据”，且会随着事务的提交或回滚被清理。

redo log（重做日志）：

作用：保证事务的持久性。事务执行过程中，对数据的修改会先写入内存的缓冲池，同时将修改操作记录到 redo log（先写 redo log buffer，再刷到磁盘）。若数据库发生崩溃，重启后可以通过 redo log 重新执行已提交的事务操作，恢复数据，避免因内存数据丢失导致的数据不一致。

特点：是物理日志，记录的是 “某个数据页做了什么修改”，采用循环写的方式，有固定大小。

binlog（二进制日志）：

作用：用于主从复制和数据备份恢复。它记录了所有对数据库的修改操作（如INSERT、UPDATE、DELETE等），不记录查询操作。主库将 binlog 发送给从库，从库通过执行 binlog 中的操作实现主从数据同步；同时，若数据库发生故障，可通过 binlog 结合备份恢复到指定时间点的数据。

特点：是逻辑日志，记录的是操作的逻辑（如 “插入一条 id&#x3D;1 的记录”），采用追加写的方式，不会覆盖旧日志，可通过expire_logs_days等参数设置自动清理策略。


三者的配合：事务执行时，先写 undo log，再修改缓冲池数据，同时写 redo log（prepare 阶段），事务提交时，写 binlog，最后将 redo log 标记为提交（commit 阶段），确保数据的一致性和持久性。
2. Redis2.1 核心数据类型与应用场景（String, Hash, List, Set, ZSet 等）
面试官： 说说 Redis 的核心数据类型有哪些，各自的应用场景是什么？
我：
Redis 的核心数据类型是其基础，常见的有 String、Hash、List、Set、ZSet 这五种，每种都有独特的结构和适用场景：

String（字符串）：

结构：最基础的数据类型，底层可存储字符串、整数或浮点数，最大能存储 512MB。

应用场景：缓存简单数据（如用户信息 JSON 串）、计数器（用INCR&#x2F;DECR实现点赞数、访问量统计）、分布式锁（通过SETNX命令）、Session 共享等。

Hash（哈希）：

结构：键值对的集合，类似 Java 中的 HashMap，适合存储对象类数据，每个 Hash 可包含最多 2^32-1 个字段。

应用场景：存储用户信息（如user:100为 key，name“age” 等为字段）、商品属性存储等，能只修改对象的某个字段，节省内存和带宽。

List（列表）：

结构：有序的字符串列表，底层是双向链表，支持从两端插入 &#x2F; 删除元素，按索引访问。

应用场景：消息队列（用LPUSH生产消息、RPOP消费消息）、最新消息展示（如朋友圈点赞列表）、排行榜前 N 条数据等。

Set（集合）：

结构：无序且不重复的字符串集合，支持交集、并集、差集等运算。

应用场景：好友关系（如共同好友用交集SINTER）、标签存储（如用户兴趣标签）、去重操作（如 UV 统计）等。

ZSet（有序集合）：

结构：在 Set 基础上给每个元素关联一个分数（score），按分数排序，元素唯一但分数可重复。

应用场景：排行榜（如游戏积分排名用ZREVRANGE）、带权重的消息队列、范围查询（如查询分数在 80-100 的用户）等。


2.2 缓存问题：穿透、击穿、雪崩及解决方案
面试官： Redis 作为缓存时，常见的缓存穿透、击穿、雪崩问题怎么解决？
我：
这三类问题都是缓存使用中可能遇到的并发或数据一致性问题，具体及解决方案如下：

缓存穿透：

问题：查询不存在的数据（如用户查 id&#x3D;-1 的用户），缓存和数据库都无结果，请求直接打向数据库，大量此类请求会压垮数据库。

解决方案：① 空值缓存，对不存在的 key 缓存空值（设较短过期时间，避免占用内存）；② 布隆过滤器，在缓存前加布隆过滤器，先判断 key 是否存在，不存在直接返回，过滤无效请求；③ 接口层校验，对非法参数（如 id 为负）直接拦截。

缓存击穿：

问题：一个热点 key 突然过期，此时大量并发请求同时访问该 key，缓存未命中，都去查数据库，导致数据库瞬间压力骤增。

解决方案：① 热点 key 永不过期，在业务层不设置过期时间，手动更新；② 互斥锁，缓存未命中时，用分布式锁（如 Redis 的SETNX）保证只有一个线程去查数据库，其他线程等待重试；③ 预热缓存，在高峰前主动加载热点数据到缓存并设合理过期时间。

缓存雪崩：

问题：大量缓存 key 在同一时间过期，或 Redis 集群宕机，导致大量请求穿透到数据库，数据库因压力过大崩溃。

解决方案：① 过期时间随机化，给 key 的过期时间加随机值（如 10±2 秒），避免同时过期；② 多级缓存，用本地缓存（如 Caffeine）+ Redis 缓存，减少 Redis 压力；③ Redis 集群高可用，部署主从 + 哨兵或 Redis Cluster，避免单点故障；④ 限流降级，在数据库前加限流组件（如 Sentinel），超过阈值则降级返回默认数据。


2.3 数据一致性问题与解决方案（Cache-Aside 策略、延迟双删、监听 binlog）
面试官： Redis 和数据库如何保证数据一致性？有哪些常用方案？
我：
缓存与数据库的数据一致性指两者数据保持同步，常用方案需根据业务场景选择：

Cache-Aside 策略（旁路缓存）：

流程：读操作时，先查缓存，命中直接返回；未命中查数据库，再把数据写入缓存。写操作时，先更数据库，再删除缓存（而非更新缓存，避免多次写缓存浪费资源）。

适用场景：大多数普通业务场景，简单易实现，但可能因删除缓存失败导致不一致（可配合重试机制）。

延迟双删：

流程：写操作时，① 先删除缓存；② 再更新数据库；③ 过一段时间（如 500ms）再次删除缓存。

作用：解决 “更新数据库时，其他线程可能已从旧数据库读数据写入缓存” 的问题，第二次删除可清除可能的旧缓存。

适用场景：并发较高，对一致性要求稍高的场景，需合理设置延迟时间（根据业务耗时调整）。

监听 binlog 同步：

流程：借助数据库的 binlog（如 MySQL 的 binlog），通过中间件（如 Canal）监听 binlog 变化，解析后异步更新或删除 Redis 缓存。

优势：解耦业务代码，可靠性高，适合复杂的更新场景。

注意：异步更新有延迟，需接受短暂的不一致，且需保证中间件的高可用。


2.4 高性能原理：I&#x2F;O 多路复用模型（Reactor 模式、epoll）
面试官： Redis 为什么性能高？I&#x2F;O 多路复用模型是怎么回事？
我：
Redis 高性能的原因包括基于内存、单线程（避免线程切换开销）等，其中 I&#x2F;O 多路复用模型是关键：

I&#x2F;O 多路复用：允许单个线程同时监听多个文件描述符（Socket），当某个描述符就绪（如可读、可写）时，通知应用程序处理。Redis 用它解决了单线程下处理多客户端连接的问题，避免了阻塞等待。

Reactor 模式：Redis 的 I&#x2F;O 模型基于 Reactor 模式实现，核心是 “事件驱动”：① 主线程负责监听 Socket，将就绪的事件（如连接、读写）放入事件队列；② 工作线程（Redis 单线程下主线程即工作线程）从队列取事件并处理（如解析命令、执行操作）。

epoll：Redis 在 Linux 下采用 epoll 作为 I&#x2F;O 多路复用的实现（不同系统有差异，如 FreeBSD 用 kqueue），相比 select&#x2F;poll 更高效：① select&#x2F;poll 需轮询所有描述符，epoll 通过回调通知就绪描述符，无轮询开销；② select 支持的描述符数量有限（默认 1024），epoll 无此限制；③ epoll 能精准获取就绪描述符，减少无效操作。


正是 I&#x2F;O 多路复用让 Redis 单线程也能高效处理数万并发连接。
2.5 实战应用：登录机制与防抖节流实现
面试官： Redis 在实战中有哪些典型应用？比如登录和防抖节流怎么用它实现？
我：
Redis 在业务中有很多实用场景，登录机制和防抖节流是常见案例：

登录机制实现：

流程：用户登录成功后，生成唯一 token（如 UUID），以token:xxx为 key，用户信息为 value 存入 Redis（设过期时间，如 2 小时）；客户端后续请求携带 token，服务端查 Redis 验证 token 是否有效，有效则允许访问。

扩展：可结合 Redis 的EXPIRE续期（如用户操作时刷新过期时间），或用DEL实现登出；还能通过SETNX防止同一账号多设备登录（登录时先删旧 token，再存新 token）。

防抖节流实现：

防抖（避免重复触发）：如按钮点击，用 Redis 记录触发时间，规定 “n 秒内再次触发则重置时间”。例：用SET key timestamp NX PX n*1000，若 key 不存在则设置（触发操作），存在则不处理。

节流（控制触发频率）：如接口限流，规定 “n 秒内最多触发 m 次”。例：用INCR key计数，EXPIRE key n设过期时间，若计数≤m 则允许，否则拒绝。


2.6 高可用与持久化：主从同步与 AOF&#x2F;RDB
面试官： Redis 如何保证高可用？持久化机制 AOF 和 RDB 有什么区别？
我：
高可用涉及主从、持久化等，确保 Redis 不丢失数据且持续可用：

主从同步：

作用：实现数据备份和读写分离。主库负责写操作，从库通过复制主库数据实现备份，同时可分担读请求。

流程：① 从库连接主库，发送SYNC命令；② 主库生成 RDB 文件并发送给从库，从库加载 RDB 同步全量数据；③ 之后主库将写命令异步发送给从库，从库执行命令保持增量同步。

高可用：配合哨兵（Sentinel），哨兵监控主从节点，主库故障时自动将从库切换为主库，实现故障转移。

持久化机制：

RDB：在指定时间间隔生成数据集的快照（如save 60 1000表示 60 秒内 1000 次修改则触发），将数据写入二进制文件（dump.rdb）。

优势：文件小，恢复速度快；适合全量备份。

劣势：快照间隔内数据可能丢失（如宕机）；生成快照时可能阻塞主线程（用bgsave可异步，但有资源开销）。

AOF：记录所有写命令（如SET、HSET），追加到日志文件（appendonly.aof），恢复时重新执行命令。

优势：数据安全性高（可设appendfsync always实时写入）；日志可读懂，便于排查问题。

劣势：文件大，恢复慢；写命令追加可能影响性能。

实际选择：通常混合使用 AOF+RDB，RDB 用于快速恢复，AOF 弥补 RDB 的数据丢失风险。


2.7 生产优化：大 Key 与热 Key 处理
面试官： 生产环境中，Redis 的大 Key 和热 Key 怎么处理？
我：
大 Key 和热 Key 会影响 Redis 性能（如大 Key 导致阻塞，热 Key 导致节点过载），需针对性优化：

大 Key 处理：

识别：用redis-cli –bigkeys命令扫描大 Key（如 String&gt;100MB，Hash&#x2F;List 元素过多）。

拆分：① String 大 Key 拆分为多个小 Key（如user:info拆为user:info:name、user:info:age）；② Hash&#x2F;List 大 Key 按范围拆分（如 Hash 按字段首字母拆分，List 按索引分段）。

删除：大 Key 直接DEL会阻塞线程，用UNLINK（异步删除）或逐步删除（如 List 用LPOP分批删）。

热 Key 处理：

识别：通过监控工具（如 Redis Insight）统计访问频率高的 Key，或根据业务判断（如秒杀商品 ID）。

分散存储：① 给热 Key 加前缀 &#x2F; 后缀（如key:1、key:2），分散到不同 Redis 节点；② 用本地缓存（如应用内存）分担部分请求，减少 Redis 访问。

优化缓存：热 Key 设永不过期，或用主从复制（从库分担读请求），避免单节点压力过大。


七、开发框架 (Development Framework)SpringBoot 1. 核心思想：IoC (控制反转) 与 DI (依赖注入)
面试官： 请说说 SpringBoot 的核心思想 IoC 和 DI 分别是什么，它们之间有什么关系？
我：
IoC（Inversion of Control，控制反转）是 Spring 框架的核心思想，它颠覆了传统程序中对象创建和依赖管理的方式：传统方式中，对象由开发者主动通过new关键字创建，依赖关系也由开发者手动维护；而在 IoC 思想下，对象的创建权、生命周期管理以及依赖关系的组装都交给了 Spring 容器，开发者只需定义对象的需求，由容器 “反向” 将所需对象注入，实现了 “控制权从开发者到容器的转移”。
DI（Dependency Injection，依赖注入）是 IoC 的具体实现方式。当一个对象需要依赖另一个对象时，Spring 容器会主动将被依赖的对象 “注入” 到依赖对象中，无需开发者手动设置。比如在 Service 层中需要 Dao 层对象，只需用@Autowired注解标记，Spring 就会自动将 Dao 实例注入到 Service 中。
简单来说，IoC 是设计思想，DI 是实现该思想的手段，二者相辅相成，共同降低了组件间的耦合度，让代码更易维护和扩展。
2. 进阶特性：循环依赖解决机制（三级缓存）
面试官： SpringBoot 是如何解决 Bean 之间的循环依赖问题的？三级缓存在这里起到了什么作用？
我：
循环依赖指的是两个或多个 Bean 之间互相依赖，比如 A 依赖 B，B 又依赖 A。Spring 通过三级缓存机制来解决单例 Bean 的循环依赖问题，核心是提前暴露未初始化完成的 Bean 实例。
三级缓存具体指 Spring 容器中的三个 Map 结构：

一级缓存（singletonObjects）：存储已完全初始化完成的单例 Bean，是最终供外部使用的 Bean 实例。

二级缓存（earlySingletonObjects）：存储提前暴露的、已完成实例化但未完成属性注入和初始化的 Bean 实例（半成品 Bean）。

三级缓存（singletonFactories）：存储 Bean 的工厂对象（ObjectFactory），该工厂可以生成 Bean 的早期代理对象或原始实例。


解决循环依赖的流程以 A 和 B 循环依赖为例：

容器创建 A 时，先实例化 A（完成构造方法调用），然后将 A 的工厂对象放入三级缓存。

A 需要注入 B，容器开始创建 B，同样先实例化 B，将 B 的工厂对象放入三级缓存。

B 需要注入 A，容器先查一级缓存（无 A），再查二级缓存（无 A），最后查三级缓存，通过 A 的工厂对象获取 A 的早期实例，将 A 从三级缓存移到二级缓存，然后将 A 注入到 B 中。

B 完成属性注入和初始化，成为完整 Bean，放入一级缓存，之后将 B 注入到 A 中。

A 完成属性注入和初始化，放入一级缓存，循环依赖解决。


三级缓存的关键作用是应对 Bean 被 AOP 代理的场景：若 Bean 需要生成代理对象，工厂对象会提前生成代理实例并暴露，避免注入原始实例导致的代理失效问题，二级缓存则用于快速获取提前暴露的实例，减少工厂对象的重复执行。不过三级缓存仅能解决单例 Bean 的循环依赖，原型 Bean（prototype）的循环依赖无法解决，会直接抛出异常。
3. 面向切面编程：AOP 实现原理（JDK 动态代理 vs CGLIB）
面试官： SpringBoot 的 AOP 是如何实现的？JDK 动态代理和 CGLIB 代理有什么区别，Spring 会如何选择？
我：
AOP（Aspect-Oriented Programming，面向切面编程）通过将日志、事务、权限控制等通用功能抽取为 “切面”，在不修改业务代码的情况下，通过 “织入” 机制将切面与业务逻辑结合，实现代码复用。Spring AOP 的底层通过动态代理技术实现，主要有 JDK 动态代理和 CGLIB 代理两种方式。
二者的区别主要体现在实现方式和适用场景上：

JDK 动态代理：

基于 Java 反射机制实现，要求被代理的类必须实现接口，代理对象是接口的实现类。

原理是通过Proxy类生成代理实例，代理实例在调用方法时，会回调InvocationHandler中的invoke方法，在该方法中执行切面逻辑和目标方法。

优势：JDK 原生支持，无需依赖第三方库，效率较高（在代理逻辑简单时）。

局限：只能代理实现了接口的类，无法代理无接口的类。

CGLIB 代理：

基于字节码生成技术实现，通过继承被代理类生成子类作为代理对象，无需被代理类实现接口。

原理是通过 ASM 框架修改字节码，在子类中重写父类的方法，在重写方法中嵌入切面逻辑和目标方法调用。

优势：可代理无接口的类，适用范围更广。

局限：若被代理类被final修饰（无法继承），则无法生成代理对象；由于是继承实现，父类的final方法无法被重写，也就无法被增强。


Spring 对代理方式的选择逻辑：

若被代理的类实现了接口，默认使用 JDK 动态代理。

若被代理的类未实现接口，默认使用 CGLIB 代理。

可通过配置spring.aop.proxy-target-class&#x3D;true强制使用 CGLIB 代理（SpringBoot 2.x 后该配置默认值为 true）。


4. 事务管理：@Transactional 注解失效场景分析
面试官： 在 SpringBoot 中使用@Transactional注解时，哪些情况会导致事务失效？
我：
@Transactional注解通过 AOP 实现事务管理，但在一些场景下会因不符合 AOP 代理机制或注解生效条件而失效，常见场景有：

非公共方法上使用注解：@Transactional默认只对公共（public）方法生效，若在 private、protected 或 default 修饰的方法上使用，Spring 不会生成事务代理，注解失效。

自身方法调用（内部调用）：在同一个类中，一个无事务的方法调用另一个有@Transactional注解的方法，由于内部调用不会经过代理对象，事务切面无法生效。例如：


TypeScript取消自动换行复制
public class Service {
​    public void methodA() {
​        methodB(); &#x2F;&#x2F; 内部调用，methodB的事务失效
​    }
​    @Transactional
​    public void methodB() {
​        &#x2F;&#x2F; 业务逻辑
​    }
}

异常被捕获未抛出：事务默认在遇到未捕获的 RuntimeException 或 Error 时回滚，若方法内部捕获了异常且未重新抛出，事务管理器无法感知异常，会认为事务执行成功，导致不回滚。

错误的异常类型：若注解指定了rollbackFor属性（如@Transactional(rollbackFor &#x3D; IOException.class)），但实际抛出的异常不是该类型且未被rollbackFor包含，事务不会回滚；若未指定rollbackFor，checked 异常（如 IOException）默认不会触发回滚。

Bean 未被 Spring 管理：若类未通过@Service、@Component等注解交给 Spring 容器管理，@Transactional注解无法被解析，自然失效。

事务传播机制设置不当：若传播机制设置为PROPAGATION_NOT_SUPPORTED（不支持事务）、PROPAGATION_NEVER（禁止事务）等，会导致当前方法不使用事务；或PROPAGATION_REQUIRES_NEW等在特定场景下因事务嵌套逻辑导致预期外的结果。


5. 设计模式应用（工厂、单例、代理、模板方法等）
面试官： SpringBoot 中应用了哪些常见的设计模式？能举例说明吗？
我：
SpringBoot 基于 Spring 框架，内部大量应用了设计模式，以下是几种典型模式的应用：

工厂模式：Spring 的 Bean 创建过程主要依赖工厂模式。BeanFactory是 Bean 工厂的核心接口，负责创建和管理 Bean；DefaultListableBeanFactory等实现类通过读取配置（如注解、XML），根据 Bean 的定义信息生成 Bean 实例，开发者无需关心 Bean 的创建细节，只需通过工厂获取。

单例模式：Spring 容器中的 Bean 默认是单例的（scope 为 singleton），通过一级缓存（singletonObjects）保证一个 Bean 在容器中只有一个实例。容器启动时创建 Bean 并缓存，后续多次获取的都是同一个实例，减少了对象创建的开销。

代理模式：如 AOP 的实现中，JDK 动态代理和 CGLIB 代理都是代理模式的应用。代理对象在目标对象的方法前后嵌入切面逻辑（如事务、日志），既扩展了功能，又不修改目标对象的代码，符合 “开闭原则”。

模板方法模式：在数据访问层（如 JdbcTemplate、RedisTemplate）中大量使用。模板类定义了操作的整体流程（如数据库连接、执行 SQL、关闭连接），将可变的步骤（如 SQL 语句、结果集处理）抽象为抽象方法或通过回调接口让用户实现，避免了重复代码，同时保证流程的一致性。

观察者模式：Spring 的事件驱动模型基于观察者模式。ApplicationEvent是事件源，ApplicationListener是观察者，当事件发布（如ContextRefreshedEvent表示容器刷新完成）时，所有监听该事件的 Listener 会被触发执行，常用于业务解耦（如订单创建后发送通知）。


这些设计模式的应用让 SpringBoot 的架构更灵活、可扩展，也是其能快速集成各类组件的重要原因。
]]></content>
      <categories>
        <category>Java</category>
        <category>为了实习说是</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>为了实习说是</tag>
      </tags>
  </entry>
</search>
